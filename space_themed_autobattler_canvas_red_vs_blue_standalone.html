<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Space Autobattler ‚Äì Red vs Blue (standalone)</title>
  <style>
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 40%, #0b1220, #05070c); color: #eaeff8; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; }
    #ui { position: fixed; top: 12px; left: 12px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; z-index: 10; background: rgba(10,12,20,0.5); border: 1px solid rgba(255,255,255,0.08); padding: 10px; border-radius: 14px; backdrop-filter: blur(6px); box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    .btn { cursor: pointer; padding: 8px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: linear-gradient(#1b2335,#141b2a); color: #eaeff8; font-weight: 600; letter-spacing: .2px; }
    .btn:hover { filter: brightness(1.15); }
    .btn:active { transform: translateY(1px); }
    .badge { font-weight: 700; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.1); }
    .red { color:#ffd1d1; background: linear-gradient(180deg, rgba(255,79,79,0.2), rgba(255,79,79,0.05)); border-color: rgba(255,79,79,0.35); }
    .blue { color:#cfe0ff; background: linear-gradient(180deg, rgba(64,160,255,0.2), rgba(64,160,255,0.05)); border-color: rgba(64,160,255,0.35); }
    #stats { margin-left: 8px; font-variant-numeric: tabular-nums; opacity:.95 }
    #bottomRight { position: fixed; right: 12px; bottom: 12px; z-index: 10; display: flex; gap: 8px; align-items: center; background: rgba(10,12,20,0.5); border-radius: 14px; padding: 8px 10px; border: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(6px); }
    #world { position: fixed; inset: 0; display:block; }
    #toast { position: fixed; top: 12px; right: 12px; background: rgba(15,18,30,.85); border: 1px solid rgba(255,255,255,0.08); padding: 10px 14px; border-radius: 12px; opacity: 0; transform: translateY(-8px); transition: all .35s ease; pointer-events: none; }
    #toast.show { opacity: 1; transform: translateY(0); }
    a { color: #9ecbff; text-decoration: none; }
  </style>
</head>
<body>
  <canvas id="world"></canvas>
  <div id="ui">
    <button id="startPause" class="btn">‚ñ∂ Start</button>
    <button id="reset" class="btn">‚Ü∫ Reset</button>
    <button id="addRed" class="btn" title="Add Red ship">+ Red</button>
    <button id="addBlue" class="btn" title="Add Blue ship">+ Blue</button>
    <button id="toggleTrails" class="btn">‚òÑ Trails: On</button>
    <div class="btn" id="speed">Speed: 1√ó</div>
    <div class="badge red" id="redScore">Red 0</div>
    <div class="badge blue" id="blueScore">Blue 0</div>
    <div id="stats"></div>
  </div>
  <div id="bottomRight">
    <button id="seedBtn" class="btn" title="Re-seed RNG for reproducible battles">üé≤ Seed</button>
    <button id="formationBtn" class="btn" title="Re-form fleets">üõ∞Ô∏è Form</button>
    <span style="opacity:.7">Space Autobattler</span>
  </div>
  <div id="toast"></div>

  <!-- Inline module bundle: concatenated src files so the page works via file:// without a server -->
  <script type="module">
// --- src/rng (inlined) ---
let _seeded = false; let _seed = 123456789;
function srand(s){ _seeded = true; _seed = s >>> 0; }
function unseed(){ _seeded = false; }
function srandom(){ if (!_seeded) return Math.random(); _seed = (1664525 * _seed + 1013904223) >>> 0; return _seed / 4294967296; }
function srange(a=0,b=1){ return a + (b-a) * srandom(); }
function srangeInt(a,b){ return Math.floor(srange(a,b+1)); }

// --- src/entities (inlined) ---
const Team = { RED: 0, BLUE: 1 };
class Bullet { constructor(x,y,vx,vy,team){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.team=team; this.life=2.5; this.radius=2.2; this.dmg=srange(8,14); } update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; } alive(bounds=null){ if (this.life<=0) return false; if (!bounds) return true; const {W,H}=bounds; return this.x>-50 && this.x<W+50 && this.y>-50 && this.y<H+50; } }
class Ship { static _id=1; constructor(team,x,y,type='corvette'){ this.team=team; this.x=x; this.y=y; this.vx=0; this.vy=0; this.angle=0; this.type=type; const classes={ corvette:{ radius:8, maxSpeed:srange(120,160), accel:240, hp:srange(40,70), reload:srange(0.18,0.28), vision:220, range:140 }, frigate:{ radius:10, maxSpeed:srange(90,120), accel:200, hp:srange(80,120), reload:srange(0.24,0.4), vision:280, range:180 }, destroyer:{ radius:14, maxSpeed:srange(60,90), accel:150, hp:srange(150,220), reload:srange(0.4,0.7), vision:320, range:220 }, carrier:{ radius:18, maxSpeed:srange(40,70), accel:90, hp:srange(220,300), reload:srange(0.6,1.2), vision:360, range:260, launchBase:srange(3.5,6.0) }, fighter:{ radius:6, maxSpeed:srange(160,220), accel:300, hp:srange(18,32), reload:srange(0.12,0.22), vision:180, range:120 } }; const cfg = classes[type] || classes.corvette; this.radius=cfg.radius; this.maxSpeed=cfg.maxSpeed; this.accel=cfg.accel; this.turn=4.5; this.hpMax=cfg.hp; this.hp=this.hpMax; this.cooldown=0; this.reload=cfg.reload; this.vision=cfg.vision; this.range=cfg.range; this.id=Ship._id++; this.kills=0; this.alive=true; this._exploded=false; if (type==='carrier'){ this.isCarrier=true; this.launchCooldown = cfg.launchBase * srange(0.8,1.4); this.launchAmount = Math.max(1, Math.floor(srange(1,3))); } else { this.isCarrier=false; this.launchCooldown=0; } }
  pickTarget(ships){ let best=null; let bd=Infinity; const v2=this.vision*this.vision; for (const s of ships){ if (!s.alive || s.team===this.team) continue; const dx=s.x-this.x, dy=s.y-this.y, d2=dx*dx+dy*dy; if (d2<v2 && d2<bd){ bd=d2; best=s; } } return best; }
  update(dt,ships){ if (!this.alive) return; const target=this.pickTarget(ships); let ax=0, ay=0; if (target){ const dx=target.x-this.x, dy=target.y-this.y; const dist=Math.hypot(dx,dy)||1; const lead = Math.max(0, Math.min(1.2, dist/240)); const tx=target.x + (target.vx||0)*lead, ty=target.y + (target.vy||0)*lead; const sx=tx-this.x, sy=ty-this.y, sl=Math.hypot(sx,sy)||1; ax += (sx/sl)*this.accel; ay += (sy/sl)*this.accel; if (dist < this.range){ const facing = ((this.vx||1)*dx + (this.vy||1)*dy) / (Math.hypot(this.vx,this.vy)+1); if (this.cooldown <= 0 && facing > 0){ const spd = 300 + srange(-20,20); const bdx = dx/dist, bdy = dy/dist; if (arguments.length >= 3 && Array.isArray(arguments[2])) { const bullets = arguments[2]; bullets.push(new Bullet(this.x + bdx*12, this.y + bdy*12, bdx*spd + this.vx*0.2, bdy*spd + this.vy*0.2, this.team)); } this.cooldown = this.reload; } } } else { ax += Math.cos(this.angle) * (this.accel*0.3); ay += Math.sin(this.angle) * (this.accel*0.3); } let sx=0, sy=0, n=0; const sepR=26; for (const s of ships){ if (!s.alive || s===this || s.team!==this.team) continue; const dx = this.x - s.x, dy = this.y - s.y, d2 = dx*dx + dy*dy; if (d2 < sepR*sepR && d2 > 1){ const d = Math.sqrt(d2); sx += dx/d; sy += dy/d; n++; } } if (n>0){ ax += (sx/n) * this.accel*0.9; ay += (sy/n) * this.accel*0.9; } this.vx += ax*dt; this.vy += ay*dt; const sp = Math.hypot(this.vx,this.vy); if (sp > this.maxSpeed){ const k = this.maxSpeed / sp; this.vx *= k; this.vy *= k; } this.x += this.vx*dt; this.y += this.vy*dt; this.angle = Math.atan2(this.vy, this.vx); this.cooldown -= dt; }
  damage(d){ this.hp -= d; if (this.hp <= 0 && this.alive){ this.alive = false; this._exploded = true; return { x: this.x, y: this.y, team: this.team }; } return null; }
}
function spawnFleet(team,n,x,y,spread=80){ const ships=[]; for (let i=0;i<n;i++){ const ox=(i%6)*20 + srange(-10,10); const oy=Math.floor(i/6)*20 + srange(-10,10); const r=srange(0,1); let type='corvette'; if (r<0.45) type='corvette'; else if (r<0.75) type='frigate'; else if (r<0.92) type='destroyer'; else type='carrier'; ships.push(new Ship(team, x + (team===Team.RED ? -ox : ox), y + oy, type)); } return ships; }

// --- src/simulate (inlined) ---
function simulateStep(state, dt, bounds={W:800,H:600}){
  for (const s of state.ships){ if (s.alive) s.update(dt, state.ships, state.bullets); }

  // Wrap ships across edges
  if (bounds && typeof bounds.W === 'number' && typeof bounds.H === 'number'){
    const W = bounds.W, H = bounds.H;
    for (const s of state.ships){
      if (!s.alive) continue;
      const r = s.radius || 0;
      if (s.x < -r) s.x += (W + r*2);
      else if (s.x > W + r) s.x -= (W + r*2);
      if (s.y < -r) s.y += (H + r*2);
      else if (s.y > H + r) s.y -= (H + r*2);
    }
  }

  for (const s of state.ships){ if (!s.alive || !s.isCarrier) continue; s.launchCooldown -= dt; if (s.launchCooldown <= 0){ const toLaunch = Math.max(1, Math.floor(s.launchAmount||1)); for (let k=0;k<toLaunch;k++){ const a=srange(0,Math.PI*2); const dist = s.radius + 12 + srange(4,12); const fx = s.x + Math.cos(a)*dist, fy = s.y + Math.sin(a)*dist; const f = new Ship(s.team, fx, fy, 'fighter'); const spd = srange(40,120); f.vx = Math.cos(a)*spd + (s.vx||0)*0.2; f.vy = Math.sin(a)*spd + (s.vy||0)*0.2; state.ships.push(f); } s.launchCooldown = srange(2.5,6.0); } }
  for (let i=state.bullets.length-1;i>=0;i--){ const b=state.bullets[i]; b.update(dt); if (!b.alive(bounds)) state.bullets.splice(i,1); }
  for (let i=state.bullets.length-1;i>=0;i--){ const b=state.bullets[i]; for (const s of state.ships){ if (!s.alive || s.team === b.team) continue; const dx=s.x-b.x, dy=s.y-b.y, d2=dx*dx+dy*dy; const R = s.radius + b.radius; if (d2 < R*R){ const exp = s.damage(b.dmg); state.bullets.splice(i,1); if (exp && state.explosions) state.explosions.push(exp); if (!s.alive){ if (b.team === 0) state.score.red++; else state.score.blue++; } break; } } }
}

// --- src/renderer (inlined) ---
const canvasEl = document.getElementById('world'); const ctx = canvasEl.getContext('2d'); let W = canvasEl.width = window.innerWidth; let H = canvasEl.height = window.innerHeight; window.addEventListener('resize', () => { W = canvasEl.width = window.innerWidth; H = canvasEl.height = window.innerHeight; });
const TAU = Math.PI*2; const clamp = (v,a,b)=>Math.max(a,Math.min(b,v)); const rand=(min=0,max=1)=>min+(max-min)*Math.random();
function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1400); }
const stars=[]; function initStars(){ stars.length=0; const layers=[0.2,0.5,1.0]; for (const depth of layers){ for (let i=0;i<120;i++){ stars.push({ x: rand(0,W), y: rand(0,H), r: rand(0.3,1.8)*depth, d: depth, tw: rand(0.4,1), phase: rand(0,TAU) }); } } } initStars();
const teamColor = (t,alpha=1) => t===Team.RED ? `rgba(255,90,90,${alpha})` : `rgba(80,160,255,${alpha})`;
class Particle{ constructor(x,y,vx,vy,life,color){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.max=life; this.color=color; } update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.vx*=Math.pow(0.9,dt*60); this.vy*=Math.pow(0.9,dt*60); this.life-=dt; } draw(){ if (this.life<=0) return; const a=this.life/this.max; ctx.fillStyle = this.color.replace('$a', a.toFixed(3)); ctx.fillRect(this.x,this.y,2,2); } }
class ShipV{ constructor(shipLogic){ this.logic=shipLogic; this.id=shipLogic.id; this.team=shipLogic.team; this.x=shipLogic.x; this.y=shipLogic.y; this.type=shipLogic.type; } syncFromLogic(){ this.x=this.logic.x; this.y=this.logic.y; this.type=this.logic.type; this.alive=this.logic.alive; } draw(){ const s=this.logic; if (!s.alive) return; if (showTrails){ const tx = s.x - Math.cos(s.angle)*s.radius*1.2; const ty = s.y - Math.sin(s.angle)*s.radius*1.2; particles.push(new Particle(tx, ty, -s.vx*0.05 + srange(-10,10), -s.vy*0.05 + srange(-10,10), .25, teamColor(s.team,'$a'))); } ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.angle); ctx.shadowBlur=12; ctx.shadowColor=teamColor(s.team,.9); const r=s.radius||8; ctx.fillStyle=teamColor(s.team,.96); if (s.type==='corvette'){ ctx.beginPath(); ctx.moveTo(r*1.5,0); ctx.lineTo(-r,-r*0.7); ctx.lineTo(-r*0.4,0); ctx.lineTo(-r,r*0.7); ctx.closePath(); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.85)'; ctx.beginPath(); ctx.ellipse(0,0,r*0.35,r*0.25,0,0,TAU); ctx.fill(); } else if (s.type==='frigate'){ ctx.beginPath(); ctx.moveTo(r*1.6,0); ctx.quadraticCurveTo(r*0.2,-r*1.1,-r*1.1,-r*0.6); ctx.lineTo(-r*0.6,0); ctx.lineTo(-r*1.1,r*0.6); ctx.quadraticCurveTo(r*0.2,r*1.1,r*1.6,0); ctx.closePath(); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.75)'; ctx.fillRect(-r*0.2,-r*0.25,r*0.6,r*0.5); } else if (s.type==='destroyer'){ ctx.beginPath(); ctx.moveTo(r*1.9,0); ctx.lineTo(r*0.3,-r*1.1); ctx.lineTo(-r*1.4,-r*0.6); ctx.lineTo(-r*1.4,r*0.6); ctx.lineTo(r*0.3,r*1.1); ctx.closePath(); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.7)'; ctx.fillRect(-r*0.9,-r*0.18,r*1.2,r*0.36); } else if (s.type==='carrier'){ ctx.beginPath(); ctx.ellipse(0,0,r*1.6,r*1.0,0,0,TAU); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.18)'; ctx.fillRect(-r*0.8,-r*0.25,r*1.6,r*0.5); } else if (s.type==='fighter'){ ctx.beginPath(); ctx.moveTo(r*1.2,0); ctx.lineTo(-r*0.6,-r*0.45); ctx.lineTo(-r*0.2,0); ctx.lineTo(-r*0.6,r*0.45); ctx.closePath(); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.ellipse(r*0.25,0,r*0.25,r*0.15,0,0,TAU); ctx.fill(); } else { ctx.beginPath(); ctx.moveTo(r*1.4,0); ctx.lineTo(-r,-r*0.8); ctx.lineTo(-r*0.4,0); ctx.lineTo(-r,r*0.8); ctx.closePath(); ctx.fill(); } ctx.restore(); const w=Math.max(16,r*3.2), h=Math.max(3,r*0.4), p=s.hp/s.hpMax; const x=s.x-w/2, y=s.y-(r+10); ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(x,y,w,h); ctx.fillStyle=teamColor(s.team,.9); ctx.fillRect(x,y,w*p,h); } }
let ships=[]; let bullets=[]; let particles=[]; let flashes=[]; let shipsVMap=new Map(); let running=false; let speed=1; let showTrails=true; let lastTime=0; const score={ red:0, blue:0 };
function reset(seedValue=null){ ships.length=0; bullets.length=0; particles.length=0; flashes.length=0; score.red=0; score.blue=0; if (seedValue!==null){ srand(seedValue>>>0); toast(`Seed set to ${seedValue>>>0}`); } else { unseed(); } ships.push(...spawnFleet(Team.RED, 12, W*0.25, H*0.5)); ships.push(...spawnFleet(Team.BLUE,12, W*0.75, H*0.5)); }
function simulate(dt){ for (const s of stars){ s.phase += dt * 0.8 * s.d; } for (const s of ships){ s.update(dt, ships); } for (let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.update(dt); if (!b.alive()){ bullets.splice(i,1); continue; } } const state = { ships, bullets, score, particles, explosions: [] }; simulateStep(state, dt, { W, H }); if (state.explosions && state.explosions.length){ for (const e of state.explosions){ flashes.push({ x: e.x, y: e.y, r: 2, life: .25, team: e.team }); for (let i=0;i<20;i++){ const a = srange(0,TAU); const sp = srange(40,220); particles.push(new Particle(e.x, e.y, Math.cos(a)*sp, Math.sin(a)*sp, srange(.2,1), teamColor(e.team, '$a'))); } } } for (let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.update(dt); if (p.life<=0) particles.splice(i,1); } for (let i=flashes.length-1;i>=0;i--){ const f=flashes[i]; f.life -= dt; f.r += 600*dt; if (f.life<=0) flashes.splice(i,1); } const aliveIds=new Set(ships.map(s=>s.id)); for (const s of ships){ if (shipsVMap.has(s.id)) shipsVMap.get(s.id).syncFromLogic(); else shipsVMap.set(s.id, new ShipV(s)); } for (const id of Array.from(shipsVMap.keys())){ if (!aliveIds.has(id)) shipsVMap.delete(id); } }
function render(){ ctx.clearRect(0,0,W,H); const g=ctx.createRadialGradient(W*0.6,H*0.3,50,W*0.6,H*0.3,Math.max(W,H)); g.addColorStop(0,'rgba(60,80,140,0.10)'); g.addColorStop(1,'rgba(10,12,20,0.0)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); for (const s of stars){ const tw=0.6+0.4*Math.sin(s.phase); ctx.globalAlpha = clamp(0.5*tw*(0.6+0.5*s.d),0,1); ctx.fillStyle='#e9f2ff'; ctx.fillRect(s.x,s.y,s.r,s.r); } ctx.globalAlpha=1; for (const f of flashes){ const a=clamp(f.life/0.25,0,1); ctx.strokeStyle=teamColor(f.team,a*0.6); ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,TAU); ctx.stroke(); } for (const b of bullets){ ctx.save(); ctx.shadowBlur=12; ctx.shadowColor=teamColor(b.team,.9); ctx.fillStyle=teamColor(b.team,.95); ctx.beginPath(); ctx.arc(b.x,b.y,b.radius||2.2,0,TAU); ctx.fill(); ctx.restore(); } for (const p of particles) p.draw(); for (const sv of shipsVMap.values()) sv.draw(); const redAlive = ships.some(s=>s.alive && s.team===Team.RED); const blueAlive = ships.some(s=>s.alive && s.team===Team.BLUE); if (!redAlive || !blueAlive){ ctx.save(); ctx.textAlign='center'; ctx.font = '700 36px Inter, system-ui, sans-serif'; const winner = redAlive? 'Red' : blueAlive? 'Blue' : 'Nobody'; const col = redAlive? teamColor(Team.RED,.95) : blueAlive? teamColor(Team.BLUE,.95) : 'rgba(255,255,255,.9)'; ctx.fillStyle=col; ctx.shadowBlur=14; ctx.shadowColor=col; ctx.fillText(`${winner} Wins!`, W/2, 64); ctx.restore(); } }
function loop(t){ if (!lastTime) lastTime=t; const rawDt=(t-lastTime)/1000; lastTime=t; const dt = clamp(rawDt,0,0.033) * (running? speed: 0); simulate(dt); render(); updateUI(); requestAnimationFrame(loop); }
const startBtn = document.getElementById('startPause'); const resetBtn = document.getElementById('reset'); const addRedBtn = document.getElementById('addRed'); const addBlueBtn = document.getElementById('addBlue'); const trailsBtn = document.getElementById('toggleTrails'); const speedBtn = document.getElementById('speed'); const redBadge = document.getElementById('redScore'); const blueBadge = document.getElementById('blueScore'); const statsDiv = document.getElementById('stats'); const seedBtn = document.getElementById('seedBtn'); const formationBtn = document.getElementById('formationBtn'); function updateUI(){ redBadge.textContent=`Red ${score.red}`; blueBadge.textContent=`Blue ${score.blue}`; statsDiv.textContent=`Ships: ${ships.filter(s=>s.alive).length}  Bullets: ${bullets.length}  Particles: ${particles.length}`; }
startBtn.addEventListener('click', ()=>{ running=!running; startBtn.textContent = running? '‚è∏ Pause' : '‚ñ∂ Start'; }); resetBtn.addEventListener('click', ()=>reset()); addRedBtn.addEventListener('click', ()=>{ ships.push(new Ship(Team.RED, srange(40, W*0.35), srange(80,H-80))); toast('+1 Red'); }); addBlueBtn.addEventListener('click', ()=>{ ships.push(new Ship(Team.BLUE, srange(W*0.65, W-40), srange(80,H-80))); toast('+1 Blue'); }); trailsBtn.addEventListener('click', ()=>{ showTrails=!showTrails; trailsBtn.textContent = `‚òÑ Trails: ${showTrails? 'On' : 'Off'}`; });
speedBtn.addEventListener('click', ()=>{ const steps=[0.5,1,2,4]; const idx=(steps.indexOf(speed)+1)%steps.length; speed=steps[idx]; speedBtn.textContent = `Speed: ${speed}√ó`; }); seedBtn.addEventListener('click', ()=>{ const s = prompt('Enter numeric seed (32-bit):', (Math.random()*1e9>>>0)); if (s!==null) reset(Number(s)); }); formationBtn.addEventListener('click', ()=>{ const aliveR = ships.filter(s=>s.alive && s.team===Team.RED); const aliveB = ships.filter(s=>s.alive && s.team===Team.BLUE); const spaceY=20; const cols=6; aliveR.forEach((s,i)=>{ const c=i%cols, r=Math.floor(i/cols); s.x=W*0.25 - c*20; s.y=H*0.5 + (r-cols/2)*spaceY; s.vx=s.vy=0; }); aliveB.forEach((s,i)=>{ const c=i%cols, r=Math.floor(i/cols); s.x=W*0.75 + c*20; s.y=H*0.5 + (r-cols/2)*spaceY; s.vx=s.vy=0; }); toast('Fleets re-formed'); });
canvasEl.addEventListener('click', (e)=>{ const r=24; flashes.push({x:e.clientX,y:e.clientY,r,life:.25,team:srangeInt(0,1)}); for (let i=0;i<24;i++){ const a=srange(0,TAU), sp=srange(40,220); particles.push(new Particle(e.clientX,e.clientY,Math.cos(a)*sp,Math.sin(a)*sp,srange(.2,1),'rgba(255,255,255,$a)')); } });
reset(); requestAnimationFrame(loop);
  </script>
</body>
</html>