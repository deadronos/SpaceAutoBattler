{
  "version": 3,
  "sources": ["../src/core/svgRasterWorker.ts"],
  "sourcesContent": ["// SVG Raster Worker - Converts SVG text to ImageBitmap with caching and change detection\n// Runs in Web Worker to avoid blocking main thread during rasterization\n\ninterface RasterizeRequest {\n  type: 'rasterize';\n  svgText: string;\n  width: number;\n  height: number;\n  assetKey: string;\n  teamColor?: string;\n  filePath?: string;\n  fileModTime?: number;\n}\n\ninterface CacheRequest {\n  type: 'clear-cache' | 'set-cache-max-entries' | 'set-cache-max-age';\n  value?: number;\n}\n\ninterface GetCanvasRequest {\n  type: 'get-canvas';\n  assetKey: string;\n  mappingHash: string;\n  outW: number;\n  outH: number;\n}\n\ntype WorkerRequest = RasterizeRequest | CacheRequest | GetCanvasRequest;\n\ninterface RasterizeResponse {\n  type: 'rasterized';\n  assetKey: string;\n  imageBitmap: ImageBitmap;\n  width: number;\n  height: number;\n}\n\ninterface CacheResponse {\n  type: 'cache-cleared' | 'cache-config-updated';\n}\n\ninterface GetCanvasResponse {\n  type: 'canvas-result';\n  assetKey: string;\n  canvas: OffscreenCanvas;\n  present: boolean;\n}\n\ntype WorkerResponse = RasterizeResponse | CacheResponse | GetCanvasResponse;\n\n// Simple LRU cache for rasterized SVGs\nclass RasterCache {\n  private cache = new Map<string, { bitmap: ImageBitmap; timestamp: number; modTime?: number }>();\n  private maxEntries = 50;\n  private maxAge = 300000; // 5 minutes\n\n  set(assetKey: string, bitmap: ImageBitmap, modTime?: number) {\n    // Clean up old entries if needed\n    if (this.cache.size >= this.maxEntries) {\n      this.evictOldest();\n    }\n\n    this.cache.set(assetKey, {\n      bitmap,\n      timestamp: Date.now(),\n      modTime\n    });\n  }\n\n  get(assetKey: string, modTime?: number): ImageBitmap | null {\n    const entry = this.cache.get(assetKey);\n    if (!entry) return null;\n\n    // Check if cache entry is stale\n    if (Date.now() - entry.timestamp > this.maxAge) {\n      this.cache.delete(assetKey);\n      return null;\n    }\n\n    // Check if file has been modified since caching\n    if (modTime && entry.modTime && modTime > entry.modTime) {\n      this.cache.delete(assetKey);\n      return null;\n    }\n\n    return entry.bitmap;\n  }\n\n  clear() {\n    // Close all ImageBitmaps to free memory\n    for (const entry of this.cache.values()) {\n      entry.bitmap.close();\n    }\n    this.cache.clear();\n  }\n\n  setMaxEntries(max: number) {\n    this.maxEntries = max;\n    // Evict excess entries\n    while (this.cache.size > this.maxEntries) {\n      this.evictOldest();\n    }\n  }\n\n  setMaxAge(maxAgeMs: number) {\n    this.maxAge = maxAgeMs;\n  }\n\n  private evictOldest() {\n    let oldestKey = '';\n    let oldestTime = Date.now();\n\n    for (const [key, entry] of this.cache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      const entry = this.cache.get(oldestKey);\n      if (entry) {\n        entry.bitmap.close();\n      }\n      this.cache.delete(oldestKey);\n    }\n  }\n}\n\nconst rasterCache = new RasterCache();\n\n// SVG to ImageBitmap rasterization function\nasync function rasterizeSvgToImageBitmap(\n  svgText: string,\n  width: number,\n  height: number,\n  teamColor?: string\n): Promise<ImageBitmap> {\n  // Create canvas for rasterization\n  const canvas = new OffscreenCanvas(width, height);\n  const ctx = canvas.getContext('2d')!;\n\n  // Clear canvas\n  ctx.clearRect(0, 0, width, height);\n\n  try {\n    // Instead of using createImageBitmap directly on SVG blob,\n    // use a different approach that's more compatible\n    \n    // First, try to create a data URL from the SVG\n    const svgDataUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgText)}`;\n    \n    // Create a mock Image-like object for OffscreenCanvas context\n    // Since we can't use Image in a worker, we'll need to parse the SVG manually\n    // For now, fall back to creating a geometric shape\n    throw new Error('Worker SVG parsing not yet implemented - using geometric fallback');\n    \n  } catch (error) {\n    // Fallback: create a geometric representation\n    console.log('[svgRasterWorker] Creating geometric fallback shape');\n    \n    const centerX = width / 2;\n    const centerY = height / 2;\n    const size = Math.min(width, height) * 0.8;\n    \n    // Fill background with semi-transparent team color\n    if (teamColor) {\n      ctx.fillStyle = teamColor;\n      ctx.globalAlpha = 0.3;\n      ctx.fillRect(0, 0, width, height);\n      ctx.globalAlpha = 1.0;\n    }\n    \n    // Draw ship-like arrow shape\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY - size/2);      // Top point\n    ctx.lineTo(centerX + size/4, centerY);      // Right middle\n    ctx.lineTo(centerX + size/6, centerY + size/3); // Right back\n    ctx.lineTo(centerX - size/6, centerY + size/3); // Left back\n    ctx.lineTo(centerX - size/4, centerY);      // Left middle\n    ctx.closePath();\n    ctx.fill();\n    \n    // Add team color outline\n    if (teamColor) {\n      ctx.strokeStyle = teamColor;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n\n    // Convert canvas to ImageBitmap\n    return canvas.transferToImageBitmap();\n  }\n}\n\n// Apply team color tinting to the rasterized SVG\nfunction applyTeamColorTint(\n  ctx: OffscreenCanvasRenderingContext2D,\n  width: number,\n  height: number,\n  teamColor: string\n) {\n  // Get image data\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const data = imageData.data;\n\n  // Parse team color\n  const colorMatch = teamColor.match(/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n  if (!colorMatch) return;\n\n  const r = parseInt(colorMatch[1], 16) / 255;\n  const g = parseInt(colorMatch[2], 16) / 255;\n  const b = parseInt(colorMatch[3], 16) / 255;\n\n  // Apply tint to non-transparent pixels\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3];\n    if (alpha > 0) {\n      // Blend with team color\n      data[i] = Math.min(255, data[i] * r);     // Red\n      data[i + 1] = Math.min(255, data[i + 1] * g); // Green\n      data[i + 2] = Math.min(255, data[i + 2] * b); // Blue\n      // Alpha remains unchanged\n    }\n  }\n\n  // Put modified image data back\n  ctx.putImageData(imageData, 0, 0);\n}\n\n// Get file modification time (simplified - in real implementation would need file system access)\nasync function getFileModTime(filePath: string): Promise<number | null> {\n  // This is a placeholder - in a real implementation, you'd need to check file system\n  // For now, we'll use a simple approach that could be extended\n  try {\n    // In a browser environment, we can't directly access file modification times\n    // This would need to be implemented server-side or with a different approach\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n// Handle worker messages\nself.addEventListener('message', async (e: MessageEvent<WorkerRequest>) => {\n  const request = e.data;\n\n  try {\n    switch (request.type) {\n      case 'rasterize': {\n        const { svgText, width, height, assetKey, teamColor, filePath, fileModTime } = request;\n\n        // Check cache first\n        const cached = rasterCache.get(assetKey, fileModTime || undefined);\n        if (cached) {\n          (self as any).postMessage({\n            type: 'rasterized',\n            assetKey,\n            imageBitmap: cached,\n            width,\n            height\n          } as RasterizeResponse);\n          return;\n        }\n\n        // Rasterize SVG\n        const imageBitmap = await rasterizeSvgToImageBitmap(svgText, width, height, teamColor);\n\n        // Cache the result\n        rasterCache.set(assetKey, imageBitmap, fileModTime);\n\n        // Send response\n        (self as any).postMessage({\n          type: 'rasterized',\n          assetKey,\n          imageBitmap,\n          width,\n          height\n        } as RasterizeResponse);\n        break;\n      }\n\n      case 'get-canvas': {\n        // This is a simplified implementation - in practice you'd maintain a canvas cache\n        const { assetKey, mappingHash, outW, outH } = request;\n\n        // For now, just return whether we have a cached bitmap\n        const cached = rasterCache.get(assetKey);\n        const canvas = new OffscreenCanvas(outW, outH);\n\n        if (cached) {\n          const ctx = canvas.getContext('2d')!;\n          ctx.drawImage(cached, 0, 0, outW, outH);\n        }\n\n        (self as any).postMessage({\n          type: 'canvas-result',\n          assetKey,\n          canvas,\n          present: !!cached\n        } as GetCanvasResponse);\n        break;\n      }\n\n      case 'clear-cache': {\n        rasterCache.clear();\n        (self as any).postMessage({ type: 'cache-cleared' } as CacheResponse);\n        break;\n      }\n\n      case 'set-cache-max-entries': {\n        if (request.value !== undefined) {\n          rasterCache.setMaxEntries(request.value);\n          (self as any).postMessage({ type: 'cache-config-updated' } as CacheResponse);\n        }\n        break;\n      }\n\n      case 'set-cache-max-age': {\n        if (request.value !== undefined) {\n          rasterCache.setMaxAge(request.value);\n          (self as any).postMessage({ type: 'cache-config-updated' } as CacheResponse);\n        }\n        break;\n      }\n    }\n  } catch (error) {\n    console.error('[svgRasterWorker] Error processing request:', error);\n    // Send error response if needed\n  }\n});\n\nexport {};"],
  "mappings": "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",
  "names": []
}
