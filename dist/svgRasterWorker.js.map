{
  "version": 3,
  "sources": ["../src/core/svgRasterWorker.ts"],
  "sourcesContent": ["// SVG Raster Worker - Converts SVG text to ImageBitmap with caching and change detection\r\n// Runs in Web Worker to avoid blocking main thread during rasterization\r\n\r\ninterface RasterizeRequest {\r\n  type: 'rasterize';\r\n  svgText: string;\r\n  width: number;\r\n  height: number;\r\n  assetKey: string;\r\n  teamColor?: string;\r\n  filePath?: string;\r\n  fileModTime?: number;\r\n}\r\n\r\ninterface CacheRequest {\r\n  type: 'clear-cache' | 'set-cache-max-entries' | 'set-cache-max-age';\r\n  value?: number;\r\n}\r\n\r\ninterface GetCanvasRequest {\r\n  type: 'get-canvas';\r\n  assetKey: string;\r\n  mappingHash: string;\r\n  outW: number;\r\n  outH: number;\r\n}\r\n\r\ntype WorkerRequest = RasterizeRequest | CacheRequest | GetCanvasRequest;\r\n\r\ninterface RasterizeResponse {\r\n  type: 'rasterized';\r\n  assetKey: string;\r\n  imageBitmap: ImageBitmap;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ninterface CacheResponse {\r\n  type: 'cache-cleared' | 'cache-config-updated';\r\n}\r\n\r\ninterface GetCanvasResponse {\r\n  type: 'canvas-result';\r\n  assetKey: string;\r\n  canvas: OffscreenCanvas;\r\n  present: boolean;\r\n}\r\n\r\ntype WorkerResponse = RasterizeResponse | CacheResponse | GetCanvasResponse;\r\n\r\n// Simple LRU cache for rasterized SVGs\r\nclass RasterCache {\r\n  private cache = new Map<string, { bitmap: ImageBitmap; timestamp: number; modTime?: number }>();\r\n  private maxEntries = 50;\r\n  private maxAge = 300000; // 5 minutes\r\n\r\n  set(assetKey: string, bitmap: ImageBitmap, modTime?: number) {\r\n    // Clean up old entries if needed\r\n    if (this.cache.size >= this.maxEntries) {\r\n      this.evictOldest();\r\n    }\r\n\r\n    this.cache.set(assetKey, {\r\n      bitmap,\r\n      timestamp: Date.now(),\r\n      modTime\r\n    });\r\n  }\r\n\r\n  get(assetKey: string, modTime?: number): ImageBitmap | null {\r\n    const entry = this.cache.get(assetKey);\r\n    if (!entry) return null;\r\n\r\n    // Check if cache entry is stale\r\n    if (Date.now() - entry.timestamp > this.maxAge) {\r\n      this.cache.delete(assetKey);\r\n      return null;\r\n    }\r\n\r\n    // Check if file has been modified since caching\r\n    if (modTime && entry.modTime && modTime > entry.modTime) {\r\n      this.cache.delete(assetKey);\r\n      return null;\r\n    }\r\n\r\n    return entry.bitmap;\r\n  }\r\n\r\n  clear() {\r\n    // Close all ImageBitmaps to free memory\r\n    for (const entry of this.cache.values()) {\r\n      entry.bitmap.close();\r\n    }\r\n    this.cache.clear();\r\n  }\r\n\r\n  setMaxEntries(max: number) {\r\n    this.maxEntries = max;\r\n    // Evict excess entries\r\n    while (this.cache.size > this.maxEntries) {\r\n      this.evictOldest();\r\n    }\r\n  }\r\n\r\n  setMaxAge(maxAgeMs: number) {\r\n    this.maxAge = maxAgeMs;\r\n  }\r\n\r\n  private evictOldest() {\r\n    let oldestKey = '';\r\n    let oldestTime = Date.now();\r\n\r\n    for (const [key, entry] of this.cache) {\r\n      if (entry.timestamp < oldestTime) {\r\n        oldestTime = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      const entry = this.cache.get(oldestKey);\r\n      if (entry) {\r\n        entry.bitmap.close();\r\n      }\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n}\r\n\r\nconst rasterCache = new RasterCache();\r\n\r\n// SVG to ImageBitmap rasterization function\r\nasync function rasterizeSvgToImageBitmap(\r\n  svgText: string,\r\n  width: number,\r\n  height: number,\r\n  teamColor?: string\r\n): Promise<ImageBitmap> {\r\n  // Create canvas for rasterization\r\n  const canvas = new OffscreenCanvas(width, height);\r\n  const ctx = canvas.getContext('2d')!;\r\n\r\n  // Clear canvas\r\n  ctx.clearRect(0, 0, width, height);\r\n\r\n  try {\r\n    // Instead of using createImageBitmap directly on SVG blob,\r\n    // use a different approach that's more compatible\r\n    \r\n    // First, try to create a data URL from the SVG\r\n    const svgDataUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgText)}`;\r\n    \r\n    // Create a mock Image-like object for OffscreenCanvas context\r\n    // Since we can't use Image in a worker, we'll need to parse the SVG manually\r\n    // For now, fall back to creating a geometric shape\r\n    throw new Error('Worker SVG parsing not yet implemented - using geometric fallback');\r\n    \r\n  } catch (error) {\r\n    // Fallback: create a geometric representation\r\n    console.log('[svgRasterWorker] Creating geometric fallback shape');\r\n    \r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const size = Math.min(width, height) * 0.8;\r\n    \r\n    // Fill background with semi-transparent team color\r\n    if (teamColor) {\r\n      ctx.fillStyle = teamColor;\r\n      ctx.globalAlpha = 0.3;\r\n      ctx.fillRect(0, 0, width, height);\r\n      ctx.globalAlpha = 1.0;\r\n    }\r\n    \r\n    // Draw ship-like arrow shape\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.beginPath();\r\n    ctx.moveTo(centerX, centerY - size/2);      // Top point\r\n    ctx.lineTo(centerX + size/4, centerY);      // Right middle\r\n    ctx.lineTo(centerX + size/6, centerY + size/3); // Right back\r\n    ctx.lineTo(centerX - size/6, centerY + size/3); // Left back\r\n    ctx.lineTo(centerX - size/4, centerY);      // Left middle\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Add team color outline\r\n    if (teamColor) {\r\n      ctx.strokeStyle = teamColor;\r\n      ctx.lineWidth = 2;\r\n      ctx.stroke();\r\n    }\r\n\r\n    // Convert canvas to ImageBitmap\r\n    return canvas.transferToImageBitmap();\r\n  }\r\n}\r\n\r\n// Apply team color tinting to the rasterized SVG\r\nfunction applyTeamColorTint(\r\n  ctx: OffscreenCanvasRenderingContext2D,\r\n  width: number,\r\n  height: number,\r\n  teamColor: string\r\n) {\r\n  // Get image data\r\n  const imageData = ctx.getImageData(0, 0, width, height);\r\n  const data = imageData.data;\r\n\r\n  // Parse team color\r\n  const colorMatch = teamColor.match(/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\r\n  if (!colorMatch) return;\r\n\r\n  const r = parseInt(colorMatch[1], 16) / 255;\r\n  const g = parseInt(colorMatch[2], 16) / 255;\r\n  const b = parseInt(colorMatch[3], 16) / 255;\r\n\r\n  // Apply tint to non-transparent pixels\r\n  for (let i = 0; i < data.length; i += 4) {\r\n    const alpha = data[i + 3];\r\n    if (alpha > 0) {\r\n      // Blend with team color\r\n      data[i] = Math.min(255, data[i] * r);     // Red\r\n      data[i + 1] = Math.min(255, data[i + 1] * g); // Green\r\n      data[i + 2] = Math.min(255, data[i + 2] * b); // Blue\r\n      // Alpha remains unchanged\r\n    }\r\n  }\r\n\r\n  // Put modified image data back\r\n  ctx.putImageData(imageData, 0, 0);\r\n}\r\n\r\n// Get file modification time (simplified - in real implementation would need file system access)\r\nasync function getFileModTime(filePath: string): Promise<number | null> {\r\n  // This is a placeholder - in a real implementation, you'd need to check file system\r\n  // For now, we'll use a simple approach that could be extended\r\n  try {\r\n    // In a browser environment, we can't directly access file modification times\r\n    // This would need to be implemented server-side or with a different approach\r\n    return null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Handle worker messages\r\nself.addEventListener('message', async (e: MessageEvent<WorkerRequest>) => {\r\n  const request = e.data;\r\n\r\n  try {\r\n    switch (request.type) {\r\n      case 'rasterize': {\r\n        const { svgText, width, height, assetKey, teamColor, filePath, fileModTime } = request;\r\n\r\n        // Check cache first\r\n        const cached = rasterCache.get(assetKey, fileModTime || undefined);\r\n        if (cached) {\r\n          (self as any).postMessage({\r\n            type: 'rasterized',\r\n            assetKey,\r\n            imageBitmap: cached,\r\n            width,\r\n            height\r\n          } as RasterizeResponse);\r\n          return;\r\n        }\r\n\r\n        // Rasterize SVG\r\n        const imageBitmap = await rasterizeSvgToImageBitmap(svgText, width, height, teamColor);\r\n\r\n        // Cache the result\r\n        rasterCache.set(assetKey, imageBitmap, fileModTime);\r\n\r\n        // Send response\r\n        (self as any).postMessage({\r\n          type: 'rasterized',\r\n          assetKey,\r\n          imageBitmap,\r\n          width,\r\n          height\r\n        } as RasterizeResponse);\r\n        break;\r\n      }\r\n\r\n      case 'get-canvas': {\r\n        // This is a simplified implementation - in practice you'd maintain a canvas cache\r\n        const { assetKey, mappingHash, outW, outH } = request;\r\n\r\n        // For now, just return whether we have a cached bitmap\r\n        const cached = rasterCache.get(assetKey);\r\n        const canvas = new OffscreenCanvas(outW, outH);\r\n\r\n        if (cached) {\r\n          const ctx = canvas.getContext('2d')!;\r\n          ctx.drawImage(cached, 0, 0, outW, outH);\r\n        }\r\n\r\n        (self as any).postMessage({\r\n          type: 'canvas-result',\r\n          assetKey,\r\n          canvas,\r\n          present: !!cached\r\n        } as GetCanvasResponse);\r\n        break;\r\n      }\r\n\r\n      case 'clear-cache': {\r\n        rasterCache.clear();\r\n        (self as any).postMessage({ type: 'cache-cleared' } as CacheResponse);\r\n        break;\r\n      }\r\n\r\n      case 'set-cache-max-entries': {\r\n        if (request.value !== undefined) {\r\n          rasterCache.setMaxEntries(request.value);\r\n          (self as any).postMessage({ type: 'cache-config-updated' } as CacheResponse);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'set-cache-max-age': {\r\n        if (request.value !== undefined) {\r\n          rasterCache.setMaxAge(request.value);\r\n          (self as any).postMessage({ type: 'cache-config-updated' } as CacheResponse);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('[svgRasterWorker] Error processing request:', error);\r\n    // Send error response if needed\r\n  }\r\n});\r\n\r\nexport {};"],
  "mappings": "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",
  "names": []
}
