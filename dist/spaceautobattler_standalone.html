<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Space AutoBattler UI</title>
  <style>
/* src/styles/ui.css */
html,
body {
  height: 100%;
  margin: 0;
  background:
    radial-gradient(
      1200px 800px at 50% 40%,
      #0b1220,
      #05070c);
  color: #eaeff8;
  font-family:
    Inter,
    system-ui,
    -apple-system,
    Segoe UI,
    Roboto,
    Ubuntu,
    Cantarell,
    "Helvetica Neue",
    Arial,
    "Noto Sans",
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
}
#ui {
  position: fixed;
  top: 12px;
  left: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  z-index: 10;
  background: rgba(10, 12, 20, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 10px;
  border-radius: 14px;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
}
.btn {
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  background: linear-gradient(#1b2335, #141b2a);
  color: #eaeff8;
  font-weight: 600;
  letter-spacing: .2px;
}
.btn:hover {
  filter: brightness(1.15);
}
.badge {
  font-weight: 700;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}
.red {
  color: #ffd1d1;
  background:
    linear-gradient(
      180deg,
      rgba(255, 79, 79, 0.2),
      rgba(255, 79, 79, 0.05));
  border-color: rgba(255, 79, 79, 0.35);
}
.blue {
  color: #cfe0ff;
  background:
    linear-gradient(
      180deg,
      rgba(64, 160, 255, 0.2),
      rgba(64, 160, 255, 0.05));
  border-color: rgba(64, 160, 255, 0.35);
}
#stats {
  margin-left: 8px;
  font-variant-numeric: tabular-nums;
  opacity: .95;
}
#bottomRight {
  position: fixed;
  right: 12px;
  bottom: 12px;
  z-index: 10;
  display: flex;
  gap: 8px;
  align-items: center;
  background: rgba(10, 12, 20, 0.5);
  border-radius: 14px;
  padding: 8px 10px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}
#bottomRight .continuous-label {
  color: var(--ui-color,#eaeff8);
  margin-right: 6px;
}
#bottomRight .muted {
  opacity: .7;
}
#world {
  position: fixed;
  inset: 0;
  display: block;
}
#devControls {
  position: fixed;
  left: 12px;
  bottom: 80px;
  background: rgba(0, 0, 0, 0.5);
  padding: 8px;
  border-radius: 6px;
  color: #fff;
  font-size: 13px;
  z-index: 11;
}
#devControls input[type=range] {
  width: 180px;
  display: block;
  margin-top: 6px;
}

/* src/styles/bundle.css */
/*# sourceMappingURL=bundled.css.map */

</style>
</head>
<body>
  <canvas id="world"></canvas>
  <div id="ui">
    <button id="startPause" class="btn">‚ñ∂ Start</button>
    <button id="reset" class="btn">‚Ü∫ Reset</button>
    <button id="addRed" class="btn" title="Add Red ship">+ Red</button>
    <button id="addBlue" class="btn" title="Add Blue ship">+ Blue</button>
    <button id="toggleTrails" class="btn">‚òÑ Trails: On</button>
    <div class="btn" id="speed">Speed: 1√ó</div>
    <div class="badge red" id="redScore">Red 0</div>
    <div class="badge blue" id="blueScore">Blue 0</div>
  <div id="stats">Ships: 0 (R:0 B:0) Bullets: 0</div>
  </div>
  <!-- Developer control: renderer scale slider (dev-only) -->
  <div id="devControls">
    <label for="rendererScaleRange">Renderer scale: <span id="rendererScaleValue">1.00</span></label>
  <input id="rendererScaleRange" type="range" min="0.5" max="2.0" step="0.01" value="1.0" />
  </div>
  <div id="bottomRight">
    <input id="continuousCheckbox" type="checkbox" />
    <label for="continuousCheckbox" class="continuous-label">Continuous</label>
    <button id="seedBtn" class="btn" title="Re-seed RNG for reproducible battles">üé≤ Seed</button>
    <button id="formationBtn" class="btn" title="Re-form fleets">üõ∞Ô∏è Form</button>
    <span class="muted">Space Autobattler</span>
  </div>
  <div id="toast"></div>
  <script type="module">

	const __workerCode = "// src/config/progressionConfig.ts\nvar progression = {\n  xpPerDamage: 1,\n  xpPerKill: 50,\n  xpToLevel: (level) => 100 * Math.pow(1.25, level - 1),\n  hpPercentPerLevel: (level) => Math.min(0.1, 0.05 + 0.05 / Math.sqrt(level)),\n  dmgPercentPerLevel: 0.08,\n  shieldPercentPerLevel: 0.06,\n  speedPercentPerLevel: 0.03,\n  regenPercentPerLevel: 0.04\n};\n\n// src/simulate.ts\nfunction dist2(a, b) {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\nfunction simulateStep(state2, dtSeconds, bounds2) {\n  state2.t = (state2.t || 0) + dtSeconds;\n  for (let i = (state2.bullets || []).length - 1; i >= 0; i--) {\n    const b = state2.bullets[i];\n    b.x += (b.vx || 0) * dtSeconds;\n    b.y += (b.vy || 0) * dtSeconds;\n    b.ttl = (b.ttl || 0) - dtSeconds;\n    if (b.ttl <= 0) state2.bullets.splice(i, 1);\n  }\n  for (const s of state2.ships || []) {\n    s.x += (s.vx || 0) * dtSeconds;\n    s.y += (s.vy || 0) * dtSeconds;\n    if (typeof bounds2.W === \"number\" && bounds2.W > 0) {\n      s.x = (s.x % bounds2.W + bounds2.W) % bounds2.W;\n    }\n    if (typeof bounds2.H === \"number\" && bounds2.H > 0) {\n      s.y = (s.y % bounds2.H + bounds2.H) % bounds2.H;\n    }\n  }\n  for (let bi = (state2.bullets || []).length - 1; bi >= 0; bi--) {\n    const b = state2.bullets[bi];\n    for (let si = (state2.ships || []).length - 1; si >= 0; si--) {\n      const s = state2.ships[si];\n      if (s.team === b.team) continue;\n      const r = (s.radius || 6) + (b.radius || 1);\n      if (dist2(b, s) <= r * r) {\n        const attacker = typeof b.ownerId === \"number\" || typeof b.ownerId === \"string\" ? (state2.ships || []).find((sh) => sh.id === b.ownerId) : void 0;\n        let dealtToShield = 0;\n        let dealtToHealth = 0;\n        const shield = s.shield || 0;\n        if (shield > 0) {\n          const absorbed = Math.min(shield, b.damage || 0);\n          s.shield = shield - absorbed;\n          const hitAngle = Math.atan2((b.y || 0) - (s.y || 0), (b.x || 0) - (s.x || 0));\n          (state2.shieldHits ||= []).push({ id: s.id, hitX: b.x, hitY: b.y, team: s.team, amount: absorbed, hitAngle });\n          (state2.damageEvents ||= []).push({ id: s.id, type: \"shield\", amount: absorbed, x: b.x, y: b.y, team: s.team, attackerId: attacker && attacker.id });\n          const remaining = (b.damage || 0) - absorbed;\n          if (remaining > 0) {\n            s.hp -= remaining;\n            (state2.healthHits ||= []).push({ id: s.id, hitX: b.x, hitY: b.y, team: s.team, amount: remaining });\n            (state2.damageEvents ||= []).push({ id: s.id, type: \"hp\", amount: remaining, x: b.x, y: b.y, team: s.team, attackerId: attacker && attacker.id });\n          }\n          dealtToShield = absorbed;\n          dealtToHealth = Math.max(0, (b.damage || 0) - absorbed);\n        } else {\n          s.hp -= b.damage || 0;\n          (state2.healthHits ||= []).push({ id: s.id, hitX: b.x, hitY: b.y, team: s.team, amount: b.damage || 0 });\n          (state2.damageEvents ||= []).push({ id: s.id, type: \"hp\", amount: b.damage || 0, x: b.x, y: b.y, team: s.team, attackerId: attacker && attacker.id });\n          dealtToHealth = b.damage || 0;\n        }\n        s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n        s.shieldPercent = typeof s.maxShield === \"number\" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;\n        if (attacker) {\n          attacker.xp = (attacker.xp || 0) + (dealtToShield + dealtToHealth) * (progression.xpPerDamage || 0);\n          while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {\n            attacker.xp -= progression.xpToLevel(attacker.level || 1);\n            attacker.level = (attacker.level || 1) + 1;\n            const resolveScalar = (s2, lvl2) => typeof s2 === \"function\" ? s2(lvl2) : s2 || 0;\n            const lvl = attacker.level || 1;\n            const hpScalar = resolveScalar(progression.hpPercentPerLevel, lvl);\n            const shScalar = resolveScalar(progression.shieldPercentPerLevel, lvl);\n            const dmgScalar = resolveScalar(progression.dmgPercentPerLevel, lvl);\n            const speedScalar = resolveScalar(progression.speedPercentPerLevel, lvl);\n            const regenScalar = resolveScalar(progression.regenPercentPerLevel, lvl);\n            const hpMul = 1 + hpScalar;\n            const shMul = 1 + shScalar;\n            const dmgMul = 1 + dmgScalar;\n            attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n            attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);\n            if (typeof attacker.maxShield === \"number\") {\n              attacker.maxShield = (attacker.maxShield || 0) * shMul;\n              attacker.shield = Math.min(attacker.maxShield, (attacker.shield || 0) * shMul);\n            }\n            if (Array.isArray(attacker.cannons)) {\n              for (const c of attacker.cannons) {\n                if (typeof c.damage === \"number\") c.damage *= dmgMul;\n              }\n            }\n            if (typeof speedScalar === \"number\" && typeof attacker.accel === \"number\") attacker.accel = attacker.accel * (1 + speedScalar);\n            if (typeof regenScalar === \"number\" && typeof attacker.shieldRegen === \"number\") attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n          }\n        }\n        state2.bullets.splice(bi, 1);\n        if (s.hp <= 0) {\n          if (attacker) {\n            attacker.xp = (attacker.xp || 0) + (progression.xpPerKill || 0);\n            while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {\n              attacker.xp -= progression.xpToLevel(attacker.level || 1);\n              attacker.level = (attacker.level || 1) + 1;\n              const resolveScalar = (s2, lvl2) => typeof s2 === \"function\" ? s2(lvl2) : s2 || 0;\n              const lvl = attacker.level || 1;\n              const hpScalar = resolveScalar(progression.hpPercentPerLevel, lvl);\n              const shScalar = resolveScalar(progression.shieldPercentPerLevel, lvl);\n              const dmgScalar = resolveScalar(progression.dmgPercentPerLevel, lvl);\n              const speedScalar = resolveScalar(progression.speedPercentPerLevel, lvl);\n              const regenScalar = resolveScalar(progression.regenPercentPerLevel, lvl);\n              const hpMul = 1 + hpScalar;\n              const shMul = 1 + shScalar;\n              const dmgMul = 1 + dmgScalar;\n              attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n              attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);\n              if (typeof attacker.maxShield === \"number\") {\n                attacker.maxShield = (attacker.maxShield || 0) * shMul;\n                attacker.shield = Math.min(attacker.maxShield, (attacker.shield || 0) * shMul);\n              }\n              if (Array.isArray(attacker.cannons)) {\n                for (const c of attacker.cannons) {\n                  if (typeof c.damage === \"number\") c.damage *= dmgMul;\n                }\n              }\n              if (typeof speedScalar === \"number\" && typeof attacker.accel === \"number\") attacker.accel = attacker.accel * (1 + speedScalar);\n              if (typeof regenScalar === \"number\" && typeof attacker.shieldRegen === \"number\") attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n            }\n          }\n          (state2.explosions ||= []).push({ x: s.x, y: s.y, team: s.team });\n          state2.ships.splice(si, 1);\n        }\n        break;\n      }\n    }\n  }\n  for (const s of state2.ships || []) {\n    if (s.maxShield) s.shield = Math.min(s.maxShield, (s.shield || 0) + (s.shieldRegen || 0) * dtSeconds);\n  }\n  for (const s of state2.ships || []) {\n    s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n    s.shieldPercent = typeof s.maxShield === \"number\" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;\n  }\n  return state2;\n}\n\n// src/rng.ts\nvar _seed = 1;\nfunction srand(seed = 1) {\n  _seed = seed >>> 0;\n}\nfunction mulberry32(a) {\n  return function() {\n    let t = (a += 1831565813) >>> 0;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nfunction srandom() {\n  const f = mulberry32(_seed);\n  _seed = _seed + 2654435761 >>> 0;\n  return f();\n}\nfunction srange(min, max) {\n  return min + (max - min) * srandom();\n}\n\n// src/config/assets/assetsConfig.ts\nvar AssetsConfig = {\n  meta: {\n    orientation: \"+X\",\n    coordinateSystem: \"topdown-2d\"\n  },\n  palette: {\n    shipHull: \"#b0b7c3\",\n    shipAccent: \"#6c7380\",\n    bullet: \"#ffd166\",\n    turret: \"#94a3b8\",\n    // Scene background color used by renderers\n    background: \"#0b1220\"\n  },\n  // 2D vector shapes defined as polygons and circles. Points are unit-sized\n  // profiles (roughly radius 1). Renderer should multiply by entity radius or\n  // provided scale before drawing.\n  shapes2d: {\n    fighter: {\n      type: \"compound\",\n      parts: [\n        { type: \"polygon\", points: [[1.2, 0], [-0.8, 0.6], [-0.5, 0], [-0.8, -0.6]] },\n        { type: \"polygon\", points: [[0, 0.35], [-0.6, 0.65], [-0.35, 0]] },\n        { type: \"polygon\", points: [[0, -0.35], [-0.35, 0], [-0.6, -0.65]] }\n      ],\n      strokeWidth: 0.08,\n      model3d: { url: void 0, scale: 1, type: \"gltf\", mesh: void 0 }\n    },\n    corvette: {\n      type: \"compound\",\n      parts: [\n        { type: \"polygon\", points: [[1, 0], [0.2, 0.6], [-0.9, 0.5], [-1.1, 0], [-0.9, -0.5], [0.2, -0.6]] },\n        { type: \"polygon\", points: [[1.2, 0.18], [1, 0.1], [1, -0.1], [1.2, -0.18]] }\n      ],\n      strokeWidth: 0.08,\n      model3d: { url: void 0, scale: 1.4, type: \"gltf\", mesh: void 0 }\n    },\n    frigate: {\n      type: \"polygon\",\n      points: [[1.1, 0], [0.6, 0.55], [-0.2, 0.8], [-1.2, 0.45], [-1.2, -0.45], [-0.2, -0.8], [0.6, -0.55]],\n      strokeWidth: 0.1,\n      model3d: { url: void 0, scale: 1.8, type: \"gltf\", mesh: void 0 }\n    },\n    destroyer: {\n      type: \"polygon\",\n      points: [[1.4, 0], [0.8, 0.5], [0.1, 0.7], [-0.6, 0.6], [-1.4, 0.4], [-1.4, -0.4], [-0.6, -0.6], [0.1, -0.7], [0.8, -0.5]],\n      strokeWidth: 0.12,\n      model3d: { url: void 0, scale: 2.2, type: \"gltf\", mesh: void 0 }\n    },\n    carrier: {\n      type: \"compound\",\n      parts: [\n        { type: \"polygon\", points: [[1.1, 0], [0.6, 0.7], [-0.5, 0.9], [-1.4, 0.7], [-1.6, 0], [-1.4, -0.7], [-0.5, -0.9], [0.6, -0.7]] },\n        { type: \"polygon\", points: [[1.4, 0.25], [1.1, 0.15], [1.1, -0.15], [1.4, -0.25]] }\n      ],\n      strokeWidth: 0.12,\n      model3d: { url: void 0, scale: 3, type: \"gltf\", mesh: void 0 }\n    },\n    bulletSmall: { type: \"circle\", r: 0.18 },\n    bulletMedium: { type: \"circle\", r: 0.25 },\n    bulletLarge: { type: \"circle\", r: 0.36 },\n    turretBasic: {\n      type: \"compound\",\n      parts: [\n        { type: \"circle\", r: 0.5 },\n        { type: \"polygon\", points: [[-0.2, 0.2], [0.7, 0.2], [0.7, -0.2], [-0.2, -0.2]] }\n      ],\n      strokeWidth: 0.08\n    }\n  }\n};\nAssetsConfig.animations = {\n  engineFlare: {\n    type: \"polygon\",\n    points: [[0, 0], [-0.3, 0.15], [-0.5, 0], [-0.3, -0.15]],\n    pulseRate: 8,\n    // configurable alpha multiplier for engine overlay\n    alpha: 0.4,\n    // local-space X offset (negative = behind ship)\n    offset: -0.9\n  },\n  shieldEffect: {\n    type: \"circle\",\n    r: 1.2,\n    strokeWidth: 0.1,\n    color: \"#88ccff\",\n    pulseRate: 2,\n    // map shieldPct -> alpha = base + scale * shieldPct\n    alphaBase: 0.25,\n    alphaScale: 0.75\n  },\n  damageParticles: {\n    type: \"particles\",\n    color: \"#ff6b6b\",\n    count: 6,\n    lifetime: 0.8,\n    spread: 0.6\n  }\n};\nAssetsConfig.damageStates = {\n  light: { opacity: 0.9, accentColor: \"#b0b7c3\" },\n  moderate: { opacity: 0.75, accentColor: \"#d4a06a\" },\n  heavy: { opacity: 0.5, accentColor: \"#ff6b6b\" }\n};\nAssetsConfig.visualStateDefaults = {\n  fighter: { engine: \"engineFlare\", shield: \"shieldEffect\", damageParticles: \"damageParticles\" },\n  corvette: { engine: \"engineFlare\", shield: \"shieldEffect\", damageParticles: \"damageParticles\" },\n  frigate: { engine: \"engineFlare\", shield: \"shieldEffect\", damageParticles: \"damageParticles\" },\n  destroyer: { engine: \"engineFlare\", shield: \"shieldEffect\", damageParticles: \"damageParticles\" },\n  carrier: { engine: \"engineFlare\", shield: \"shieldEffect\", damageParticles: \"damageParticles\" }\n};\nAssetsConfig.damageThresholds = { moderate: 0.66, heavy: 0.33 };\n\n// src/config/entitiesConfig.ts\nvar ShipConfig = {\n  fighter: {\n    maxHp: 15,\n    armor: 0,\n    maxShield: 8,\n    shieldRegen: 1,\n    dmg: 3,\n    damage: 3,\n    radius: 4,\n    cannons: [{ damage: 3, rate: 3, spread: 0.1, muzzleSpeed: 300, bulletRadius: 1.5, bulletTTL: 1.2 }],\n    accel: 600,\n    turnRate: 6\n  },\n  corvette: {\n    maxHp: 50,\n    armor: 0,\n    maxShield: Math.round(50 * 0.6),\n    shieldRegen: 0.5,\n    dmg: 5,\n    damage: 5,\n    radius: 8,\n    accel: 200,\n    turnRate: 3,\n    cannons: [{ damage: 6, rate: 1.2, spread: 0.05, muzzleSpeed: 220, bulletRadius: 2, bulletTTL: 2 }]\n  },\n  frigate: {\n    maxHp: 80,\n    armor: 1,\n    maxShield: Math.round(80 * 0.6),\n    shieldRegen: 0.4,\n    dmg: 8,\n    damage: 8,\n    radius: 12,\n    cannons: [{ damage: 8, rate: 1, spread: 0.06, muzzleSpeed: 200, bulletRadius: 2.5, bulletTTL: 2.2 }],\n    accel: 120,\n    turnRate: 2.2\n  },\n  destroyer: {\n    maxHp: 120,\n    armor: 2,\n    maxShield: Math.round(120 * 0.6),\n    shieldRegen: 0.3,\n    dmg: 12,\n    damage: 12,\n    radius: 16,\n    cannons: new Array(6).fill(0).map(() => ({ damage: 6, rate: 0.8, spread: 0.08, muzzleSpeed: 240, bulletRadius: 2.5, bulletTTL: 2.4 })),\n    accel: 80,\n    turnRate: 1.6\n  },\n  carrier: {\n    maxHp: 200,\n    armor: 3,\n    maxShield: Math.round(200 * 0.6),\n    shieldRegen: 0.2,\n    dmg: 2,\n    damage: 2,\n    radius: 24,\n    cannons: new Array(4).fill(0).map(() => ({ damage: 4, rate: 0.6, spread: 0.12, muzzleSpeed: 180, bulletRadius: 3, bulletTTL: 2.8 })),\n    accel: 40,\n    turnRate: 0.8,\n    carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 }\n  }\n};\n\n// src/entities.ts\nvar nextId = 1;\nfunction genId() {\n  return nextId++;\n}\nfunction createBullet(x, y, vx, vy, team = \"red\", ownerId = null, damage = 1, ttl = 2) {\n  return {\n    id: genId(),\n    x,\n    y,\n    vx,\n    vy,\n    team,\n    ownerId,\n    damage,\n    ttl\n  };\n}\n\n// src/behavior.ts\nfunction len2(vx, vy) {\n  return vx * vx + vy * vy;\n}\nfunction clampSpeed(s, max) {\n  const v2 = len2(s.vx || 0, s.vy || 0);\n  const max2 = max * max;\n  if (v2 > max2 && v2 > 0) {\n    const inv = max / Math.sqrt(v2);\n    s.vx = (s.vx || 0) * inv;\n    s.vy = (s.vy || 0) * inv;\n  }\n}\nfunction aimWithSpread(from, to, spread = 0) {\n  let dx = (to.x || 0) - (from.x || 0);\n  let dy = (to.y || 0) - (from.y || 0);\n  const d = Math.hypot(dx, dy) || 1;\n  dx /= d;\n  dy /= d;\n  if (spread > 0) {\n    const ang = Math.atan2(dy, dx);\n    const jitter = srange(-spread, spread);\n    const na = ang + jitter;\n    return { x: Math.cos(na), y: Math.sin(na) };\n  }\n  return { x: dx, y: dy };\n}\nfunction tryFire(state2, ship, target, dt) {\n  if (!Array.isArray(ship.cannons) || ship.cannons.length === 0) return;\n  for (const c of ship.cannons) {\n    if (typeof c.__cd !== \"number\") c.__cd = 0;\n    c.__cd -= dt;\n    if (c.__cd > 0) continue;\n    const spread = typeof c.spread === \"number\" ? c.spread : 0;\n    const dir = aimWithSpread(ship, target, spread);\n    const speed = typeof c.muzzleSpeed === \"number\" ? c.muzzleSpeed : 240;\n    const dmg = typeof c.damage === \"number\" ? c.damage : typeof ship.damage === \"number\" ? ship.damage : typeof ship.dmg === \"number\" ? ship.dmg : 3;\n    const ttl = typeof c.bulletTTL === \"number\" ? c.bulletTTL : 2;\n    const radius = typeof c.bulletRadius === \"number\" ? c.bulletRadius : 1.5;\n    const vx = dir.x * speed;\n    const vy = dir.y * speed;\n    const b = Object.assign(\n      createBullet(ship.x || 0, ship.y || 0, vx, vy, ship.team || \"red\", ship.id || null, dmg, ttl),\n      { radius }\n    );\n    state2.bullets.push(b);\n    const rate = typeof c.rate === \"number\" && c.rate > 0 ? c.rate : 1;\n    c.__cd = 1 / rate;\n  }\n}\nfunction ensureShipAiState(s) {\n  if (!s.__ai) {\n    s.__ai = { state: \"idle\", decisionTimer: 0, targetId: null };\n  }\n  return s.__ai;\n}\nfunction chooseNewTarget(state2, ship) {\n  const enemies = (state2.ships || []).filter((sh) => sh && sh.team !== ship.team);\n  if (!enemies.length) return null;\n  const idx = Math.floor(srandom() * enemies.length);\n  return enemies[idx];\n}\nfunction steerAway(s, tx, ty, accel, dt) {\n  const dx = (s.x || 0) - tx;\n  const dy = (s.y || 0) - ty;\n  const d = Math.hypot(dx, dy) || 1;\n  const nx = dx / d;\n  const ny = dy / d;\n  s.vx = (s.vx || 0) + nx * accel * dt;\n  s.vy = (s.vy || 0) + ny * accel * dt;\n}\nfunction applySimpleAI(state2, dt, bounds2 = { W: 800, H: 600 }) {\n  if (!state2 || !Array.isArray(state2.ships)) return;\n  for (const s of state2.ships) {\n    const ai = ensureShipAiState(s);\n    ai.decisionTimer = Math.max(0, (ai.decisionTimer || 0) - dt);\n    let target = null;\n    if (ai.targetId != null) target = (state2.ships || []).find((sh) => sh && sh.id === ai.targetId) || null;\n    if (!target) target = chooseNewTarget(state2, s);\n    if (target) ai.targetId = target.id;\n    const accel = typeof s.accel === \"number\" ? s.accel : 100;\n    const maxSpeed = 160;\n    if (!target) {\n      s.vx = (s.vx || 0) + srange(-1, 1) * 8 * dt;\n      s.vy = (s.vy || 0) + srange(-1, 1) * 8 * dt;\n      ai.state = \"idle\";\n    } else {\n      if (ai.decisionTimer <= 0) {\n        const hpFrac = (s.hp || 0) / Math.max(1, s.maxHp || 1);\n        const rnd = srandom();\n        if (hpFrac < 0.35 || rnd < 0.15) ai.state = \"evade\";\n        else if (rnd < 0.85) ai.state = \"engage\";\n        else ai.state = \"idle\";\n        ai.decisionTimer = 0.5 + srandom() * 1.5;\n      }\n      if (ai.state === \"engage\") {\n        const aim = aimWithSpread(s, target, 0.05);\n        s.vx = (s.vx || 0) + aim.x * accel * dt;\n        s.vy = (s.vy || 0) + aim.y * accel * dt;\n        tryFire(state2, s, target, dt);\n      } else if (ai.state === \"evade\") {\n        steerAway(s, target.x || 0, target.y || 0, accel * 0.8, dt);\n        const ang = Math.atan2(s.vy || 0, s.vx || 0);\n        const perp = ang + Math.PI / 2 * (srandom() < 0.5 ? 1 : -1);\n        s.vx = (s.vx || 0) + Math.cos(perp) * accel * 0.2 * dt;\n        s.vy = (s.vy || 0) + Math.sin(perp) * accel * 0.2 * dt;\n      } else {\n        s.vx = (s.vx || 0) + srange(-0.5, 0.5) * 6 * dt;\n        s.vy = (s.vy || 0) + srange(-0.5, 0.5) * 6 * dt;\n      }\n    }\n    clampSpeed(s, maxSpeed);\n  }\n}\n\n// src/simWorker.ts\nvar state = null;\nvar bounds = { W: 800, H: 600 };\nvar simDtMs = 16;\nvar running = false;\nvar acc = 0;\nvar last = 0;\nfunction postSnapshot() {\n  try {\n    postMessage({ type: \"snapshot\", state });\n    try {\n      clearTransientEvents(state);\n    } catch (e) {\n    }\n  } catch (e) {\n  }\n}\nfunction clearTransientEvents(s) {\n  if (!s || typeof s !== \"object\") return;\n  try {\n    if (Array.isArray(s.explosions)) s.explosions.length = 0;\n    if (Array.isArray(s.shieldHits)) s.shieldHits.length = 0;\n    if (Array.isArray(s.healthHits)) s.healthHits.length = 0;\n  } catch (e) {\n  }\n}\nfunction tick() {\n  if (!running) return;\n  const now = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  if (!last) last = now;\n  acc += now - last;\n  last = now;\n  if (acc > 250) acc = 250;\n  while (acc >= simDtMs) {\n    try {\n      applySimpleAI(state, simDtMs / 1e3, bounds);\n      simulateStep(state, simDtMs / 1e3, bounds);\n    } catch (e) {\n      const errAny = e;\n      const stack = errAny && errAny.stack ? errAny.stack : \"\";\n      postMessage({ type: \"error\", message: String(e), stack });\n    }\n    acc -= simDtMs;\n  }\n  postSnapshot();\n  setTimeout(tick, 0);\n}\nself.onmessage = (ev) => {\n  const msg = ev.data;\n  try {\n    switch (msg && msg.type) {\n      case \"init\":\n        if (typeof msg.seed === \"number\") srand(msg.seed);\n        if (msg.bounds) bounds = msg.bounds;\n        if (typeof msg.simDtMs === \"number\") simDtMs = msg.simDtMs;\n        if (msg.state) state = msg.state;\n        postMessage({ type: \"ready\" });\n        break;\n      case \"start\":\n        if (!state) {\n          postMessage({ type: \"error\", message: \"no state\" });\n          break;\n        }\n        running = true;\n        acc = 0;\n        last = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n        tick();\n        break;\n      case \"stop\":\n        running = false;\n        break;\n      case \"snapshotRequest\":\n        postSnapshot();\n        break;\n      case \"setSeed\":\n        if (typeof msg.seed === \"number\") {\n          srand(msg.seed);\n        }\n        break;\n      case \"command\":\n        if (msg.cmd === \"spawnShip\" && state) {\n          state.ships.push(msg.args.ship);\n        } else if (msg.cmd === \"spawnShipBullet\" && state) {\n          state.bullets.push(msg.args.bullet);\n        } else if (msg.cmd === \"setState\") {\n          state = msg.args.state;\n        }\n        break;\n      default:\n        break;\n    }\n  } catch (err) {\n    const stack = err && err.stack ? err.stack : \"\";\n    postMessage({ type: \"error\", message: String(err), stack });\n  }\n};\nvar simWorker_default = null;\nexport {\n  clearTransientEvents,\n  simWorker_default as default\n};\n//# sourceMappingURL=simWorker.js.map\n";
	const __workerBlob = new Blob([__workerCode], { type: 'text/javascript' });
	const __workerUrl = URL.createObjectURL(__workerBlob);
	const __OrigWorker = window.Worker;
	window.Worker = class extends __OrigWorker {
		constructor(url, opts) {
			// redirect requests ending with simWorker.js to the blob URL; otherwise, pass-through
			try {
				const s = typeof url === 'string' ? url : String(url);
				if (s.endsWith('simWorker.js')) {
					super(__workerUrl, { type: 'module', ...(opts||{}) });
					return;
				}
			} catch {}
			super(url, opts);
		}
	};
	
// src/gamemanager.js
var createGameManager = createGameManager;
var shieldFlashIndex = shieldFlashIndex;
var healthFlashIndex = healthFlashIndex;
var FLASH_TTL_DEFAULT = FLASH_TTL_DEFAULT;

// src/gamemanager.ts
var createGameManager2 = createGameManager;
var shieldFlashIndex2 = shieldFlashIndex;
var healthFlashIndex2 = healthFlashIndex;
var FLASH_TTL_DEFAULT2 = FLASH_TTL_DEFAULT;

// src/config/assets/assetsConfig.ts
var AssetsConfig = {
  meta: {
    orientation: "+X",
    coordinateSystem: "topdown-2d"
  },
  palette: {
    shipHull: "#b0b7c3",
    shipAccent: "#6c7380",
    bullet: "#ffd166",
    turret: "#94a3b8",
    // Scene background color used by renderers
    background: "#0b1220"
  },
  // 2D vector shapes defined as polygons and circles. Points are unit-sized
  // profiles (roughly radius 1). Renderer should multiply by entity radius or
  // provided scale before drawing.
  shapes2d: {
    fighter: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.2, 0], [-0.8, 0.6], [-0.5, 0], [-0.8, -0.6]] },
        { type: "polygon", points: [[0, 0.35], [-0.6, 0.65], [-0.35, 0]] },
        { type: "polygon", points: [[0, -0.35], [-0.35, 0], [-0.6, -0.65]] }
      ],
      strokeWidth: 0.08,
      model3d: { url: void 0, scale: 1, type: "gltf", mesh: void 0 }
    },
    corvette: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1, 0], [0.2, 0.6], [-0.9, 0.5], [-1.1, 0], [-0.9, -0.5], [0.2, -0.6]] },
        { type: "polygon", points: [[1.2, 0.18], [1, 0.1], [1, -0.1], [1.2, -0.18]] }
      ],
      strokeWidth: 0.08,
      model3d: { url: void 0, scale: 1.4, type: "gltf", mesh: void 0 }
    },
    frigate: {
      type: "polygon",
      points: [[1.1, 0], [0.6, 0.55], [-0.2, 0.8], [-1.2, 0.45], [-1.2, -0.45], [-0.2, -0.8], [0.6, -0.55]],
      strokeWidth: 0.1,
      model3d: { url: void 0, scale: 1.8, type: "gltf", mesh: void 0 }
    },
    destroyer: {
      type: "polygon",
      points: [[1.4, 0], [0.8, 0.5], [0.1, 0.7], [-0.6, 0.6], [-1.4, 0.4], [-1.4, -0.4], [-0.6, -0.6], [0.1, -0.7], [0.8, -0.5]],
      strokeWidth: 0.12,
      model3d: { url: void 0, scale: 2.2, type: "gltf", mesh: void 0 }
    },
    carrier: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.1, 0], [0.6, 0.7], [-0.5, 0.9], [-1.4, 0.7], [-1.6, 0], [-1.4, -0.7], [-0.5, -0.9], [0.6, -0.7]] },
        { type: "polygon", points: [[1.4, 0.25], [1.1, 0.15], [1.1, -0.15], [1.4, -0.25]] }
      ],
      strokeWidth: 0.12,
      model3d: { url: void 0, scale: 3, type: "gltf", mesh: void 0 }
    },
    bulletSmall: { type: "circle", r: 0.18 },
    bulletMedium: { type: "circle", r: 0.25 },
    bulletLarge: { type: "circle", r: 0.36 },
    turretBasic: {
      type: "compound",
      parts: [
        { type: "circle", r: 0.5 },
        { type: "polygon", points: [[-0.2, 0.2], [0.7, 0.2], [0.7, -0.2], [-0.2, -0.2]] }
      ],
      strokeWidth: 0.08
    }
  }
};
AssetsConfig.animations = {
  engineFlare: {
    type: "polygon",
    points: [[0, 0], [-0.3, 0.15], [-0.5, 0], [-0.3, -0.15]],
    pulseRate: 8,
    // configurable alpha multiplier for engine overlay
    alpha: 0.4,
    // local-space X offset (negative = behind ship)
    offset: -0.9
  },
  shieldEffect: {
    type: "circle",
    r: 1.2,
    strokeWidth: 0.1,
    color: "#88ccff",
    pulseRate: 2,
    // map shieldPct -> alpha = base + scale * shieldPct
    alphaBase: 0.25,
    alphaScale: 0.75
  },
  damageParticles: {
    type: "particles",
    color: "#ff6b6b",
    count: 6,
    lifetime: 0.8,
    spread: 0.6
  }
};
AssetsConfig.damageStates = {
  light: { opacity: 0.9, accentColor: "#b0b7c3" },
  moderate: { opacity: 0.75, accentColor: "#d4a06a" },
  heavy: { opacity: 0.5, accentColor: "#ff6b6b" }
};
AssetsConfig.visualStateDefaults = {
  fighter: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles" },
  corvette: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles" },
  frigate: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles" },
  destroyer: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles" },
  carrier: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles" }
};
AssetsConfig.damageThresholds = { moderate: 0.66, heavy: 0.33 };
function getVisualConfig(type) {
  const shape = getShipAsset(type);
  const visuals = AssetsConfig.visualStateDefaults[type] || AssetsConfig.visualStateDefaults.fighter;
  return { shape, visuals, palette: AssetsConfig.palette, animations: AssetsConfig.animations, damageStates: AssetsConfig.damageStates };
}
function getShipAsset(type) {
  return AssetsConfig.shapes2d[type] || AssetsConfig.shapes2d.fighter;
}
function getBulletAsset(kind = "small") {
  if (kind === "large") return AssetsConfig.shapes2d.bulletLarge;
  if (kind === "medium") return AssetsConfig.shapes2d.bulletMedium;
  return AssetsConfig.shapes2d.bulletSmall;
}
function getTurretAsset(_kind = "basic") {
  return AssetsConfig.shapes2d.turretBasic;
}

// src/config/entitiesConfig.ts
var ShipConfig = {
  fighter: {
    maxHp: 15,
    armor: 0,
    maxShield: 8,
    shieldRegen: 1,
    dmg: 3,
    damage: 3,
    radius: 4,
    cannons: [{ damage: 3, rate: 3, spread: 0.1, muzzleSpeed: 300, bulletRadius: 1.5, bulletTTL: 1.2 }],
    accel: 600,
    turnRate: 6
  },
  corvette: {
    maxHp: 50,
    armor: 0,
    maxShield: Math.round(50 * 0.6),
    shieldRegen: 0.5,
    dmg: 5,
    damage: 5,
    radius: 8,
    accel: 200,
    turnRate: 3,
    cannons: [{ damage: 6, rate: 1.2, spread: 0.05, muzzleSpeed: 220, bulletRadius: 2, bulletTTL: 2 }]
  },
  frigate: {
    maxHp: 80,
    armor: 1,
    maxShield: Math.round(80 * 0.6),
    shieldRegen: 0.4,
    dmg: 8,
    damage: 8,
    radius: 12,
    cannons: [{ damage: 8, rate: 1, spread: 0.06, muzzleSpeed: 200, bulletRadius: 2.5, bulletTTL: 2.2 }],
    accel: 120,
    turnRate: 2.2
  },
  destroyer: {
    maxHp: 120,
    armor: 2,
    maxShield: Math.round(120 * 0.6),
    shieldRegen: 0.3,
    dmg: 12,
    damage: 12,
    radius: 16,
    cannons: new Array(6).fill(0).map(() => ({ damage: 6, rate: 0.8, spread: 0.08, muzzleSpeed: 240, bulletRadius: 2.5, bulletTTL: 2.4 })),
    accel: 80,
    turnRate: 1.6
  },
  carrier: {
    maxHp: 200,
    armor: 3,
    maxShield: Math.round(200 * 0.6),
    shieldRegen: 0.2,
    dmg: 2,
    damage: 2,
    radius: 24,
    cannons: new Array(4).fill(0).map(() => ({ damage: 4, rate: 0.6, spread: 0.12, muzzleSpeed: 180, bulletRadius: 3, bulletTTL: 2.8 })),
    accel: 40,
    turnRate: 0.8,
    carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 }
  }
};
function getShipConfig2() {
  return JSON.parse(JSON.stringify(ShipConfig));
}
var VisualMappingConfig = {
  bulletRadiusThresholds: [
    { threshold: 0.22, kind: "small" },
    { threshold: 0.32, kind: "medium" },
    { threshold: Infinity, kind: "large" }
  ],
  defaultTurretKind: "basic",
  shipAssetKey: {
    fighter: "fighter",
    corvette: "corvette",
    frigate: "frigate",
    destroyer: "destroyer",
    carrier: "carrier"
  }
};
function bulletKindForRadius(r = 0.2) {
  for (const t of VisualMappingConfig.bulletRadiusThresholds) {
    if (r <= t.threshold) return t.kind;
  }
  return "small";
}
function getDefaultShipType() {
  const keys = Object.keys(ShipConfig || {});
  return keys.length ? keys[0] : "fighter";
}

// src/config/teamsConfig.ts
var TeamsConfig = {
  teams: {
    red: { id: "red", color: "#ff4d4d", label: "Red" },
    blue: { id: "blue", color: "#4da6ff", label: "Blue" }
  },
  defaultFleet: { counts: (() => {
    const shipCfg = getShipConfig2();
    const types = Object.keys(shipCfg || {});
    const defaultCounts = {};
    for (const t of types) {
      if (t === "fighter") defaultCounts[t] = 8;
      else if (t === "corvette") defaultCounts[t] = 3;
      else if (t === "frigate") defaultCounts[t] = 2;
      else if (t === "destroyer") defaultCounts[t] = 1;
      else if (t === "carrier") defaultCounts[t] = 1;
      else defaultCounts[t] = 1;
    }
    return defaultCounts;
  })(), spacing: 28, jitter: { x: 80, y: 120 } },
  // continuousReinforcement controls: enable/disable, scoreMargin is the
  // imbalance fraction (e.g. 0.12 means reinforce when weakest ratio < 0.38),
  // perTick is the maximum ships considered per reinforcement tick, and
  // shipTypes is an optional array of types to choose from randomly. If
  // omitted, keys from defaultFleet.counts are used.
  continuousReinforcement: { enabled: false, scoreMargin: 0.12, perTick: 1, shipTypes: void 0 }
};

// src/config/rendererConfig.ts
var RendererConfig = {
  preferred: "canvas",
  allowUrlOverride: true,
  allowWebGL: true,
  // UI overlays configuration
  hpBar: { bg: "#222", fill: "#4caf50", w: 20, h: 4, dx: -10, dy: -12 }
};
function getPreferredRenderer() {
  try {
    if (RendererConfig.allowUrlOverride && typeof window !== "undefined" && window.location && window.location.search) {
      const p = new URLSearchParams(window.location.search);
      const r = p.get("renderer");
      if (r === "canvas" || r === "webgl") return r;
    }
  } catch (e) {
  }
  return RendererConfig.preferred;
}

// src/canvasrenderer.ts
var CanvasRenderer = class {
  canvas;
  ctx = null;
  providesOwnLoop = false;
  type = "canvas";
  // ratio between backing store pixels and CSS (logical) pixels
  pixelRatio = 1;
  constructor(canvas) {
    this.canvas = canvas;
  }
  init() {
    this.ctx = this.canvas.getContext("2d");
    if (!this.ctx) return false;
    try {
      const cssW = this.canvas.clientWidth || this.canvas.width || 1;
      this.pixelRatio = (this.canvas.width || cssW) / cssW;
      this.ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      this.ctx.imageSmoothingEnabled = true;
    } catch (e) {
      this.pixelRatio = 1;
    }
    return true;
  }
  isRunning() {
    return false;
  }
  renderState(state, interpolation = 0) {
    const ctx = this.ctx;
    if (!ctx) return;
    const w = this.canvas.clientWidth || Math.round(this.canvas.width / this.pixelRatio);
    const h = this.canvas.clientHeight || Math.round(this.canvas.height / this.pixelRatio);
    ctx.clearRect(0, 0, w, h);
    ctx.save();
    ctx.fillStyle = AssetsConfig.palette.background || "#0b1220";
    ctx.fillRect(0, 0, w, h);
    function drawPolygon(points) {
      if (!points || points.length === 0) return;
      ctx.beginPath();
      ctx.moveTo(points[0][0], points[0][1]);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
      ctx.closePath();
      ctx.fill();
    }
    if (state && state.starCanvas) {
      try {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        ctx.drawImage(state.starCanvas, 0, 0, w, h);
        ctx.restore();
      } catch (e) {
      }
    }
    const now = state && state.t || 0;
    try {
      const dmgAnim = AssetsConfig.animations && AssetsConfig.animations.damageParticles;
      if (Array.isArray(state.damageEvents) && dmgAnim) {
        state.particles = state.particles || [];
        for (const ev of state.damageEvents) {
          const count = dmgAnim.count || 6;
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (dmgAnim.spread || 0.6);
            state.particles.push({
              x: ev.x || 0,
              y: ev.y || 0,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              r: 0.6 + Math.random() * 0.8,
              color: dmgAnim.color || "#ff6b6b",
              lifetime: dmgAnim.lifetime || 0.8,
              age: 0,
              shape: "circle"
            });
          }
        }
        state.damageEvents = [];
      }
    } catch (e) {
    }
    for (const s of state.ships || []) {
      try {
        const teamObj = s.team === "blue" ? TeamsConfig.teams.blue : TeamsConfig.teams.red;
        const color = teamObj && teamObj.color || AssetsConfig.palette.shipHull;
        const radius = s.radius || 6;
        const angle = s.angle || 0;
        const fallback = getDefaultShipType();
        const shape = getShipAsset(s.type || fallback);
        const vconf = getVisualConfig(s.type || fallback);
        ctx.save();
        ctx.translate(s.x || 0, s.y || 0);
        ctx.rotate(angle);
        ctx.scale(radius, radius);
        ctx.fillStyle = color;
        if (shape.type === "polygon") drawPolygon(shape.points);
        else if (shape.type === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, shape.r || 1, 0, Math.PI * 2);
          ctx.fill();
        } else if (shape.type === "compound" && Array.isArray(shape.parts)) {
          for (const part of shape.parts) {
            if (part.type === "polygon") drawPolygon(part.points);
            else if (part.type === "circle") {
              ctx.beginPath();
              ctx.arc(0, 0, part.r || 1, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
        try {
          const hpPct = typeof s.hpPercent === "number" ? s.hpPercent : Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));
          const thresholds = AssetsConfig.damageThresholds || { moderate: 0.66, heavy: 0.33 };
          let ds = "light";
          if (hpPct < thresholds.heavy) ds = "heavy";
          else if (hpPct < thresholds.moderate) ds = "moderate";
          const dcfg = vconf.damageStates?.[ds] || AssetsConfig.damageStates?.[ds];
          if (dcfg) {
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = dcfg.accentColor || "#ff6b6b";
            ctx.globalAlpha = (1 - (hpPct || 0)) * (dcfg.opacity || 0.5);
            if (shape.type === "polygon") drawPolygon(shape.points);
            else if (shape.type === "circle") {
              ctx.beginPath();
              ctx.arc(0, 0, shape.r || 1, 0, Math.PI * 2);
              ctx.fill();
            } else if (shape.type === "compound" && Array.isArray(shape.parts)) {
              for (const part of shape.parts) {
                if (part.type === "polygon") drawPolygon(part.points);
                else if (part.type === "circle") {
                  ctx.beginPath();
                  ctx.arc(0, 0, part.r || 1, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            }
            ctx.globalAlpha = 1;
          }
        } catch (e) {
        }
        ctx.restore();
        try {
          const engineName = vconf.visuals && vconf.visuals.engine || "engineFlare";
          const engine = vconf.animations[engineName];
          if (engine && engine.type === "polygon") {
            const pulse = 0.5 + 0.5 * Math.sin((now || 0) * (engine.pulseRate || 6) * Math.PI * 2);
            ctx.save();
            ctx.translate(s.x || 0, s.y || 0);
            ctx.rotate(angle);
            const engOffset = engine.offset != null ? engine.offset : -0.9;
            ctx.translate(engOffset * radius, 0);
            ctx.scale(radius, radius);
            ctx.fillStyle = vconf.palette.shipAccent || AssetsConfig.palette.shipAccent;
            const engAlpha = engine.alpha != null ? engine.alpha : 0.4;
            ctx.globalAlpha = engAlpha * pulse;
            drawPolygon(engine.points);
            ctx.globalAlpha = 1;
            ctx.restore();
          }
        } catch (e) {
        }
        try {
          const shieldName = vconf.visuals && vconf.visuals.shield || "shieldEffect";
          const sh = vconf.animations[shieldName];
          const shieldPct = typeof s.shieldPercent === "number" ? s.shieldPercent : s.maxShield && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;
          if (sh && shieldPct > 0) {
            const pulse = 0.6 + 0.4 * Math.sin((now || 0) * (sh.pulseRate || 2) * Math.PI * 2);
            ctx.save();
            ctx.translate(s.x || 0, s.y || 0);
            ctx.rotate(angle);
            ctx.scale(radius * (sh.r || 1), radius * (sh.r || 1));
            ctx.lineWidth = (sh.strokeWidth != null ? sh.strokeWidth : 0.08) * radius;
            ctx.strokeStyle = sh.color || "#88ccff";
            const aBase = sh.alphaBase != null ? sh.alphaBase : 0.25;
            const aScale = sh.alphaScale != null ? sh.alphaScale : 0.75;
            ctx.globalAlpha = Math.min(1, aBase + aScale * shieldPct) * pulse;
            try {
              let flash = null;
              try {
                const nowT = state && state.t || 0;
                const arr = shieldFlashIndex2.get(s.id) || [];
                let bestTs = -Infinity;
                for (const f of arr) {
                  if (!f) continue;
                  const fTs = typeof f._ts === "number" ? f._ts : 0;
                  const fTtl = typeof f.ttl === "number" ? f.ttl : AssetsConfig && AssetsConfig.shield && AssetsConfig.shield.ttl || 0.4;
                  if (fTs + fTtl >= nowT - 1e-6 && fTs > bestTs) {
                    bestTs = fTs;
                    flash = f;
                  }
                }
              } catch (e) {
                flash = null;
              }
              if (flash && typeof flash.hitAngle === "number") {
                const arc = typeof flash.arcWidth === "number" ? flash.arcWidth : vconf && vconf.arcWidth || AssetsConfig && AssetsConfig.shieldArcWidth || Math.PI / 6;
                const start = flash.hitAngle - arc * 0.5 - angle;
                const end = flash.hitAngle + arc * 0.5 - angle;
                ctx.beginPath();
                ctx.arc(0, 0, 1, start, end);
                ctx.stroke();
              } else {
                ctx.beginPath();
                ctx.arc(0, 0, 1, 0, Math.PI * 2);
                ctx.stroke();
              }
            } catch (e) {
              ctx.beginPath();
              ctx.arc(0, 0, 1, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
          }
        } catch (e) {
        }
        try {
          const hpBar = RendererConfig.hpBar || { bg: "#222", fill: "#4caf50", w: 20, h: 4, dx: -10, dy: -12 };
          const pct = Math.max(0, (s.hp || 0) / (s.maxHp || 1));
          ctx.fillStyle = hpBar.bg;
          ctx.fillRect((s.x || 0) + (hpBar.dx || -10), (s.y || 0) + (hpBar.dy || -12), hpBar.w || 20, hpBar.h || 4);
          ctx.fillStyle = hpBar.fill;
          ctx.fillRect((s.x || 0) + (hpBar.dx || -10), (s.y || 0) + (hpBar.dy || -12), (hpBar.w || 20) * pct, hpBar.h || 4);
        } catch (e) {
          ctx.fillStyle = "#222";
          ctx.fillRect((s.x || 0) - 10, (s.y || 0) - 12, 20, 4);
          ctx.fillStyle = "#4caf50";
          ctx.fillRect((s.x || 0) - 10, (s.y || 0) - 12, 20 * Math.max(0, (s.hp || 0) / (s.maxHp || 1)), 4);
        }
      } catch (e) {
      }
    }
    for (const s of state.ships || []) {
      try {
        const radius = (s.radius || 6) * 0.6;
        const angle = s.angle || 0;
        const tShape = getTurretAsset("basic");
        ctx.save();
        ctx.translate(s.x || 0, s.y || 0);
        ctx.rotate(angle);
        ctx.scale(radius, radius);
        ctx.fillStyle = AssetsConfig.palette.turret;
        if (tShape.type === "compound") {
          for (const part of tShape.parts) {
            if (part.type === "polygon") drawPolygon(part.points);
            else if (part.type === "circle") {
              ctx.beginPath();
              ctx.arc(0, 0, part.r || 1, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (tShape.type === "polygon") drawPolygon(tShape.points || []);
        else if (tShape.type === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, tShape.r || 1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      } catch (e) {
      }
    }
    if (Array.isArray(state.particles)) {
      for (const p of state.particles) {
        try {
          ctx.save();
          ctx.translate(p.x || 0, p.y || 0);
          ctx.fillStyle = p.color || "#fff";
          if (p.shape === "circle" || p.r) {
            ctx.beginPath();
            ctx.arc(0, 0, p.r || p.size || 1, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillRect(-1, -1, 2, 2);
          }
          ctx.restore();
        } catch (e) {
        }
      }
    }
    function drawRing(x, y, R, color, alpha = 1, thickness = 2) {
      try {
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.arc(x, y, Math.max(1, R), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      } catch (e) {
      }
    }
    try {
      const nowT = state && state.t || 0;
      for (const s of state.ships || []) {
        try {
          let flash = null;
          const arr = healthFlashIndex2.get(s.id) || [];
          let bestTs = -Infinity;
          for (const f of arr) {
            if (!f) continue;
            const fTs = typeof f._ts === "number" ? f._ts : 0;
            const fTtl = typeof f.ttl === "number" ? f.ttl : FLASH_TTL_DEFAULT2;
            if (fTs + fTtl >= nowT - 1e-6 && fTs > bestTs) {
              bestTs = fTs;
              flash = f;
            }
          }
          if (flash) {
            const ttl = flash.ttl || FLASH_TTL_DEFAULT2;
            const life = flash.life != null ? flash.life : ttl;
            const t = Math.max(0, Math.min(1, life / ttl));
            const R = 6 + (1 - t) * 18;
            const alpha = 0.9 * t;
            drawRing(flash.x || (s.x || 0), flash.y || (s.y || 0), R, "#ff7766", alpha, 2);
          }
        } catch (e) {
        }
      }
    } catch (e) {
    }
    for (const b of state.bullets || []) {
      try {
        const r = b.radius || b.bulletRadius || 1.5;
        const kind = bulletKindForRadius(r / 6);
        const shape = getBulletAsset(kind);
        ctx.save();
        ctx.translate(b.x || 0, b.y || 0);
        const px = Math.max(1, r);
        if (shape.type === "circle") {
          ctx.beginPath();
          ctx.fillStyle = AssetsConfig.palette.bullet;
          ctx.arc(0, 0, px, 0, Math.PI * 2);
          ctx.fill();
        } else if (shape.type === "polygon") {
          ctx.fillStyle = AssetsConfig.palette.bullet;
          ctx.scale(px, px);
          drawPolygon(shape.points);
        }
        ctx.restore();
      } catch (e) {
      }
    }
    ctx.restore();
  }
};

// src/webglrenderer.ts
var WebGLRenderer = class {
  canvas;
  gl = null;
  // simple GL program state for point rendering
  prog = null;
  attribLoc_pos = -1;
  attribLoc_size = -1;
  attribLoc_color = -1;
  vertexBuffer = null;
  providesOwnLoop = false;
  type = "webgl";
  pixelRatio = 1;
  constructor(canvas) {
    this.canvas = canvas;
  }
  init() {
    try {
      this.gl = this.canvas.getContext("webgl2");
      if (!this.gl) {
        this.gl = this.canvas.getContext("webgl") || this.canvas.getContext("experimental-webgl");
        if (!this.gl) return false;
      }
      const gl = this.gl;
      try {
        const bg = (AssetsConfig.palette.background || "#0b1220").replace("#", "");
        const bigint = parseInt(bg.length === 3 ? bg.split("").map((c) => c + c).join("") : bg, 16);
        const r = (bigint >> 16 & 255) / 255;
        const g = (bigint >> 8 & 255) / 255;
        const b = (bigint & 255) / 255;
        gl.clearColor(r, g, b, 1);
      } catch {
        gl.clearColor(0.02, 0.03, 0.06, 1);
      }
      try {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } catch (e) {
      }
      try {
        const cssW = this.canvas.clientWidth || this.canvas.width || 1;
        this.pixelRatio = (this.canvas.width || cssW) / cssW;
      } catch (e) {
        this.pixelRatio = 1;
      }
      try {
        const vs = `attribute vec2 a_pos; attribute float a_size; attribute vec4 a_color; varying vec4 v_color; void main(){ v_color=a_color; gl_Position = vec4(a_pos, 0.0, 1.0); gl_PointSize = a_size; }`;
        const fs = `precision mediump float; varying vec4 v_color; void main(){ vec2 c = gl_PointCoord - vec2(0.5); if(length(c) > 0.5) discard; gl_FragColor = v_color; }`;
        const compile = (src, type) => {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(s);
            gl.deleteShader(s);
            throw new Error("Shader compile error: " + info);
          }
          return s;
        };
        const vsObj = compile(vs, gl.VERTEX_SHADER);
        const fsObj = compile(fs, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vsObj);
        gl.attachShader(prog, fsObj);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw new Error("Program link error: " + gl.getProgramInfoLog(prog));
        }
        this.prog = prog;
        this.attribLoc_pos = gl.getAttribLocation(prog, "a_pos");
        this.attribLoc_size = gl.getAttribLocation(prog, "a_size");
        this.attribLoc_color = gl.getAttribLocation(prog, "a_color");
        this.vertexBuffer = gl.createBuffer();
      } catch (e) {
        this.prog = null;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  // Called when backing-store size (canvas.width/height) changes so
  // the renderer can update internal scaling/viewport without a full re-init.
  updateScale() {
    if (!this.gl) return;
    try {
      const cssW = this.canvas.clientWidth || Math.round((this.canvas.width || 1) / (this.pixelRatio || 1));
      this.pixelRatio = (this.canvas.width || cssW) / Math.max(1, cssW);
    } catch (e) {
    }
  }
  isRunning() {
    return false;
  }
  renderState(state, interpolation = 0) {
    if (!this.gl) return;
    const gl = this.gl;
    try {
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT);
      if (this.prog && this.vertexBuffer) {
        try {
          const w = this.canvas.clientWidth || Math.round(this.canvas.width / this.pixelRatio);
          const h = this.canvas.clientHeight || Math.round(this.canvas.height / this.pixelRatio);
          const ships2 = state.ships || [];
          const verts = [];
          const now = state && state.t || 0;
          for (const s of ships2) {
            const x = s.x || 0;
            const y = s.y || 0;
            const clipX = x / Math.max(1, w) * 2 - 1;
            const clipY = 1 - y / Math.max(1, h) * 2;
            const radius = s.radius || 6;
            const ps = Math.max(2, radius * 2);
            const teamObj = s.team === "blue" ? TeamsConfig.teams.blue : TeamsConfig.teams.red;
            const colorHex = teamObj && teamObj.color || AssetsConfig.palette.shipHull || "#888";
            const hexToRgba = (hex) => {
              const h2 = hex.replace("#", "");
              const bigint = parseInt(h2.length === 3 ? h2.split("").map((c) => c + c).join("") : h2, 16);
              const r = (bigint >> 16 & 255) / 255;
              const g = (bigint >> 8 & 255) / 255;
              const b = (bigint & 255) / 255;
              return [r, g, b, 1];
            };
            const baseColor = hexToRgba(colorHex);
            verts.push(clipX, clipY, ps, baseColor[0], baseColor[1], baseColor[2], baseColor[3]);
            try {
              const fallback = getDefaultShipType();
              const vconf = getVisualConfig(s.type || fallback);
              const engineName = vconf.visuals && vconf.visuals.engine || "engineFlare";
              const engine = vconf.animations && vconf.animations[engineName];
              if (engine && engine.type === "polygon") {
                const pulse = 0.5 + 0.5 * Math.sin((now || 0) * (engine.pulseRate || 6) * Math.PI * 2);
                const offset = (engine.offset != null ? engine.offset : -0.9) * (s.radius || 6);
                const ang = s.angle || 0;
                const ex = x + Math.cos(ang) * offset;
                const ey = y + Math.sin(ang) * offset;
                const cex = ex / Math.max(1, w) * 2 - 1;
                const cey = 1 - ey / Math.max(1, h) * 2;
                const accent = vconf.palette && vconf.palette.shipAccent || AssetsConfig.palette.shipAccent || "#ffd27f";
                const ac = hexToRgba(accent);
                const engAlpha = engine.alpha != null ? engine.alpha : 0.4;
                verts.push(cex, cey, Math.max(2, ps * 0.9), ac[0], ac[1], ac[2], engAlpha * pulse);
              }
            } catch (e) {
            }
            try {
              const fallback = getDefaultShipType();
              const vconf = getVisualConfig(s.type || fallback);
              const shieldName = vconf.visuals && vconf.visuals.shield || "shieldEffect";
              const sh = vconf.animations && vconf.animations[shieldName];
              const shieldPct = typeof s.shieldPercent === "number" ? s.shieldPercent : s.maxShield && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;
              if (sh && shieldPct > 0) {
                const pulse = 0.6 + 0.4 * Math.sin((now || 0) * (sh.pulseRate || 2) * Math.PI * 2);
                const accent = sh.color || "#88ccff";
                const ac = hexToRgba(accent);
                const aBase = sh.alphaBase != null ? sh.alphaBase : 0.25;
                const aScale = sh.alphaScale != null ? sh.alphaScale : 0.75;
                verts.push(clipX, clipY, Math.max(4, ps * (sh.r || 1.6)), ac[0], ac[1], ac[2], Math.min(1, aBase + aScale * shieldPct) * pulse);
                try {
                  let flash = null;
                  try {
                    const nowT = state && state.t || 0;
                    const arr = shieldFlashIndex2.get(s.id) || [];
                    let bestTs = -Infinity;
                    for (const f of arr) {
                      if (!f) continue;
                      const fTs = typeof f._ts === "number" ? f._ts : 0;
                      const fTtl = typeof f.ttl === "number" ? f.ttl : AssetsConfig && AssetsConfig.shield && AssetsConfig.shield.ttl || 0.4;
                      if (fTs + fTtl >= nowT - 1e-6 && fTs > bestTs) {
                        bestTs = fTs;
                        flash = f;
                      }
                    }
                  } catch (e) {
                    flash = null;
                  }
                  if (flash && typeof flash.hitAngle === "number") {
                    const arc = typeof flash.arcWidth === "number" ? flash.arcWidth : vconf && vconf.arcWidth || AssetsConfig && AssetsConfig.shieldArcWidth || Math.PI / 6;
                    const segs = 6;
                    const radiusMul = (sh.r || 1.6) * (s.radius || 6);
                    for (let si = 0; si < segs; si++) {
                      const t = segs === 1 ? 0.5 : si / (segs - 1);
                      const a = flash.hitAngle - arc * 0.5 + t * arc;
                      const px = x + Math.cos(a) * radiusMul;
                      const py = y + Math.sin(a) * radiusMul;
                      const cpx = px / Math.max(1, w) * 2 - 1;
                      const cpy = 1 - py / Math.max(1, h) * 2;
                      const pointSize = Math.max(2, ps * 0.45);
                      const alpha = Math.min(1, aBase + aScale * shieldPct) * pulse * 0.9;
                      verts.push(cpx, cpy, pointSize, ac[0], ac[1], ac[2], alpha);
                    }
                  }
                } catch (e) {
                }
              }
            } catch (e) {
            }
            try {
              const fallback = getDefaultShipType();
              const vconf = getVisualConfig(s.type || fallback);
              const hpPct = typeof s.hpPercent === "number" ? s.hpPercent : Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));
              const thresholds = AssetsConfig.damageThresholds || { moderate: 0.66, heavy: 0.33 };
              let ds = "light";
              if (hpPct < thresholds.heavy) ds = "heavy";
              else if (hpPct < thresholds.moderate) ds = "moderate";
              const dcfg = vconf.damageStates && vconf.damageStates[ds] || AssetsConfig.damageStates && AssetsConfig.damageStates[ds];
              if (dcfg) {
                const accent = dcfg.accentColor || "#ff6b6b";
                const alpha = (1 - (hpPct || 0)) * (dcfg.opacity || 0.5);
                const ac = hexToRgba(accent);
                verts.push(clipX, clipY, Math.max(2, ps * 1), ac[0], ac[1], ac[2], alpha);
              }
            } catch (e) {
            }
            try {
              const nowT = state && state.t || 0;
              let hflash = null;
              const harr = healthFlashIndex2.get(s.id) || [];
              let bestTsH = -Infinity;
              for (const hf of harr) {
                if (!hf) continue;
                const fTs = typeof hf._ts === "number" ? hf._ts : 0;
                const fTtl = typeof hf.ttl === "number" ? hf.ttl : FLASH_TTL_DEFAULT2;
                if (fTs + fTtl >= nowT - 1e-6 && fTs > bestTsH) {
                  bestTsH = fTs;
                  hflash = hf;
                }
              }
              if (hflash) {
                const hx = hflash.x != null ? hflash.x : x;
                const hy = hflash.y != null ? hflash.y : y;
                const cpx = hx / Math.max(1, w) * 2 - 1;
                const cpy = 1 - hy / Math.max(1, h) * 2;
                const pointSize = Math.max(2, ps * 0.6);
                const col = [1, 0.47, 0.4, 0.95];
                verts.push(cpx, cpy, pointSize, col[0], col[1], col[2], col[3]);
              }
            } catch (e) {
            }
          }
          const floatArr = new Float32Array(verts);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, floatArr, gl.DYNAMIC_DRAW);
          gl.useProgram(this.prog);
          const stride = 7 * 4;
          gl.enableVertexAttribArray(this.attribLoc_pos);
          gl.vertexAttribPointer(this.attribLoc_pos, 2, gl.FLOAT, false, stride, 0);
          gl.enableVertexAttribArray(this.attribLoc_size);
          gl.vertexAttribPointer(this.attribLoc_size, 1, gl.FLOAT, false, stride, 2 * 4);
          gl.enableVertexAttribArray(this.attribLoc_color);
          gl.vertexAttribPointer(this.attribLoc_color, 4, gl.FLOAT, false, stride, 3 * 4);
          const count = Math.floor(floatArr.length / 7);
          gl.drawArrays(gl.POINTS, 0, count);
        } catch (e) {
        }
      }
    } catch (e) {
    }
  }
};

// src/config/displayConfig.ts
function getDefaultBounds() {
  const W = typeof window !== "undefined" && window.innerWidth ? window.innerWidth : 800;
  const H = typeof window !== "undefined" && window.innerHeight ? window.innerHeight : 600;
  return { W: Math.max(800, W), H: Math.max(600, H) };
}

// src/main.ts
async function startApp(rootDocument = document) {
  const canvas = rootDocument.getElementById("world");
  const ui = {
    startPause: rootDocument.getElementById("startPause"),
    reset: rootDocument.getElementById("reset"),
    addRed: rootDocument.getElementById("addRed"),
    addBlue: rootDocument.getElementById("addBlue"),
    toggleTrails: rootDocument.getElementById("toggleTrails"),
    speed: rootDocument.getElementById("speed"),
    redScore: rootDocument.getElementById("redScore"),
    blueScore: rootDocument.getElementById("blueScore"),
    stats: rootDocument.getElementById("stats"),
    continuousCheckbox: rootDocument.getElementById("continuousCheckbox"),
    seedBtn: rootDocument.getElementById("seedBtn"),
    formationBtn: rootDocument.getElementById("formationBtn")
  };
  try {
    if (ui.stats) ui.stats.textContent = "Ships: 0 (R:0 B:0) Bullets: 0";
  } catch (e) {
  }
  function fitCanvasToWindow() {
    const baseDpr = window.devicePixelRatio || 1;
    const cfgScale = RendererConfig && typeof RendererConfig.rendererScale === "number" ? RendererConfig.rendererScale : 1;
    const bounds = getDefaultBounds();
    const cssW = Math.round(bounds.W * cfgScale);
    const cssH = Math.round(bounds.H * cfgScale);
    if (canvas) {
      canvas.style.width = `${cssW}px`;
      canvas.style.height = `${cssH}px`;
      canvas.width = Math.round(cssW * baseDpr);
      canvas.height = Math.round(cssH * baseDpr);
    }
  }
  fitCanvasToWindow();
  window.addEventListener("resize", fitCanvasToWindow);
  let renderer;
  const pref = getPreferredRenderer();
  if (pref === "webgl") {
    try {
      const w = new WebGLRenderer(canvas);
      if (w && w.init && w.init()) renderer = w;
    } catch (e) {
    }
  }
  if (!renderer) {
    renderer = new CanvasRenderer(canvas);
    renderer.init && renderer.init();
  }
  try {
    window.gm = window.gm || {};
  } catch (e) {
  }
  const gm = createGameManager2({ renderer, canvas, useWorker: false });
  try {
    if (typeof window !== "undefined" && window.gm) Object.assign(window.gm, gm);
  } catch (e) {
  }
  try {
    const host = location && location.hostname || "";
    const urlParams = typeof URLSearchParams !== "undefined" ? new URLSearchParams(location.search) : null;
    const autotest = urlParams && urlParams.get("autotest") === "1" || !!window.__AUTO_REINFORCE_DEV__;
    if ((host === "127.0.0.1" || host === "localhost") && autotest) {
      try {
        if (gm && typeof gm.setContinuousEnabled === "function") gm.setContinuousEnabled(true);
      } catch (e) {
      }
      try {
        if (gm && typeof gm.setReinforcementInterval === "function") gm.setReinforcementInterval(0.01);
      } catch (e) {
      }
      try {
        if (gm && typeof gm.stepOnce === "function") gm.stepOnce(0.02);
      } catch (e) {
      }
    }
  } catch (e) {
  }
  let lastReinforcementSummary = "";
  try {
    if (gm && typeof gm.on === "function") {
      gm.on("reinforcements", (msg) => {
        const list = msg && msg.spawned || [];
        const types = list.map((s) => s.type).filter(Boolean);
        const summary = `Reinforcements: spawned ${list.length} ships (${types.join(", ")})`;
        lastReinforcementSummary = summary;
        try {
          setTimeout(() => {
            lastReinforcementSummary = "";
          }, 3e3);
        } catch (e) {
        }
        try {
          if (ui && ui.stats) ui.stats.textContent = `${ui.stats.textContent} | ${summary}`;
        } catch (e) {
        }
      });
    }
  } catch (e) {
  }
  const workerIndicator = rootDocument.getElementById("workerIndicator");
  let toastContainer = rootDocument.getElementById("toastContainer");
  if (!toastContainer) {
    try {
      toastContainer = rootDocument.createElement("div");
      toastContainer.id = "toastContainer";
      toastContainer.style.position = "fixed";
      toastContainer.style.right = "16px";
      toastContainer.style.top = "16px";
      toastContainer.style.zIndex = "9999";
      toastContainer.style.pointerEvents = "none";
      rootDocument.body.appendChild(toastContainer);
    } catch (e) {
      toastContainer = null;
    }
  }
  function showToast(msg, opts = {}) {
    try {
      if (!toastContainer) return;
      const ttl = typeof opts.ttl === "number" ? opts.ttl : 2e3;
      const el = rootDocument.createElement("div");
      el.style.background = "rgba(20,20,30,0.9)";
      el.style.color = "#fff";
      el.style.padding = "8px 12px";
      el.style.marginTop = "6px";
      el.style.borderRadius = "6px";
      el.style.boxShadow = "0 2px 8px rgba(0,0,0,0.5)";
      el.style.fontFamily = "sans-serif";
      el.style.fontSize = "13px";
      el.style.pointerEvents = "auto";
      el.textContent = msg;
      toastContainer.appendChild(el);
      setTimeout(() => {
        try {
          el.style.transition = "opacity 300ms ease";
          el.style.opacity = "0";
        } catch (e) {
        }
        ;
        setTimeout(() => {
          try {
            if (el && el.parentNode) el.parentNode.removeChild(el);
          } catch (err) {
          }
        }, 350);
      }, ttl);
    } catch (e) {
    }
  }
  try {
    if (gm && typeof gm.on === "function") {
      gm.on("levelup", (m) => {
        try {
          const ship = m && m.ship || null;
          const lvl = m && m.newLevel || (m && m.newLevel === 0 ? 0 : void 0);
          const who = ship && ship.team ? `${ship.team} ship` : "Ship";
          const msg = `${who} leveled up to ${lvl}`;
          showToast(msg, { ttl: 2200 });
        } catch (e) {
        }
      });
    }
  } catch (e) {
  }
  if (workerIndicator) {
    try {
      workerIndicator.textContent = gm.isWorker && gm.isWorker() ? "Worker" : "Main";
      (function refresh() {
        try {
          workerIndicator.textContent = gm.isWorker && gm.isWorker() ? "Worker" : "Main";
          requestAnimationFrame(refresh);
        } catch (e) {
        }
      })();
    } catch (e) {
      workerIndicator.textContent = "Unknown";
    }
  }
  try {
    ui.startPause.addEventListener("click", () => {
      if (gm.isRunning()) {
        gm.pause();
        ui.startPause.textContent = "\u25B6 Start";
      } else {
        gm.start();
        ui.startPause.textContent = "\u23F8 Pause";
      }
    });
  } catch (e) {
  }
  try {
    ui.reset.addEventListener("click", () => gm.reset());
  } catch (e) {
  }
  try {
    ui.addRed.addEventListener("click", () => gm.spawnShip("red"));
  } catch (e) {
  }
  try {
    ui.addBlue.addEventListener("click", () => gm.spawnShip("blue"));
  } catch (e) {
  }
  function onSeedBtnClick() {
    try {
      const raw = typeof window !== "undefined" && typeof window.prompt === "function" ? window.prompt("Enter new seed (leave blank for random):", "") : null;
      if (raw == null) return;
      const trimmed = String(raw).trim();
      if (trimmed === "") {
        try {
          gm.reseed();
          showToast("Reseeded with random seed");
        } catch (e) {
        }
        return;
      }
      const asNum = Number(trimmed);
      if (!Number.isFinite(asNum) || Math.floor(asNum) !== asNum) {
        try {
          showToast("Invalid seed. Please enter an integer.");
        } catch (e) {
        }
        return;
      }
      try {
        gm.reseed(asNum >>> 0);
        showToast(`Reseeded with ${asNum >>> 0}`);
      } catch (e) {
      }
    } catch (e) {
    }
  }
  try {
    ui.seedBtn.addEventListener("click", onSeedBtnClick);
  } catch (e) {
  }
  try {
    ui.formationBtn.addEventListener("click", () => gm.formFleets());
  } catch (e) {
  }
  try {
    if (ui.continuousCheckbox) {
      ui.continuousCheckbox.addEventListener("change", (ev) => {
        const v = !!ev.target.checked;
        if (gm && typeof gm.setContinuousEnabled === "function") gm.setContinuousEnabled(v);
      });
    }
  } catch (e) {
  }
  function uiTick() {
    try {
      const s = gm.snapshot();
      ui.redScore.textContent = `Red ${gm.score.red}`;
      ui.blueScore.textContent = `Blue ${gm.score.blue}`;
      const redCount = s.ships.filter((sh) => sh.team === "red").length;
      const blueCount = s.ships.filter((sh) => sh.team === "blue").length;
      ui.stats.textContent = `Ships: ${s.ships.length} (R:${redCount} B:${blueCount}) Bullets: ${s.bullets.length}` + (lastReinforcementSummary ? ` | ${lastReinforcementSummary}` : "");
    } catch (e) {
    }
    requestAnimationFrame(uiTick);
  }
  requestAnimationFrame(uiTick);
  return { gm, renderer };
}
if (typeof window !== "undefined") {
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", () => startApp(document));
  else startApp(document);
}
var main_default = startApp;
export {
  main_default as default,
  startApp
};
//# sourceMappingURL=bundled.js.map

</script>
</body>
</html>