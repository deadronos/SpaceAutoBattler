<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Space AutoBattler UI</title>
  <style>
/* src/styles/ui.css */
#topRightRenderer {
  position: fixed;
  top: 18px;
  right: 24px;
  z-index: 30;
  background: rgba(10, 12, 20, 0.6);
  border-radius: 12px;
  padding: 10px 18px;
  border: 1px solid rgba(255, 255, 255, 0.10);
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
  font-size: 18px;
  font-weight: 600;
  color: #eaeff8;
  letter-spacing: 0.5px;
}
.renderer-type {
  color: #aee1ff;
  font-weight: 700;
  font-size: 18px;
}
.renderer-dims {
  margin-left: 14px;
  color: #b8e2ff;
  font-size: 15px;
  font-weight: 500;
  opacity: 0.85;
}
html,
body {
  height: 100%;
  margin: 0;
  background:
    radial-gradient(
      1200px 800px at 50% 40%,
      #0b1220,
      #05070c);
  color: #eaeff8;
  font-family:
    Inter,
    system-ui,
    -apple-system,
    Segoe UI,
    Roboto,
    Ubuntu,
    Cantarell,
    "Helvetica Neue",
    Arial,
    "Noto Sans",
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
}
#flexRoot {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  width: 100vw;
  height: 100vh;
  position: relative;
}
#ui {
  position: fixed;
  top: 12px;
  left: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  z-index: 20;
  background: rgba(10, 12, 20, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 10px;
  border-radius: 14px;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
}
.btn {
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  background: linear-gradient(#1b2335, #141b2a);
  color: #eaeff8;
  font-weight: 600;
  letter-spacing: .2px;
}
.btn:hover {
  filter: brightness(1.15);
}
.badge {
  font-weight: 700;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}
.red {
  color: #ffd1d1;
  background:
    linear-gradient(
      180deg,
      rgba(255, 79, 79, 0.2),
      rgba(255, 79, 79, 0.05));
  border-color: rgba(255, 79, 79, 0.35);
}
.blue {
  color: #cfe0ff;
  background:
    linear-gradient(
      180deg,
      rgba(64, 160, 255, 0.2),
      rgba(64, 160, 255, 0.05));
  border-color: rgba(64, 160, 255, 0.35);
}
#stats {
  margin-left: 8px;
  font-variant-numeric: tabular-nums;
  opacity: .95;
}
#bottomRight {
  position: fixed;
  right: 12px;
  bottom: 12px;
  z-index: 10;
  display: flex;
  gap: 8px;
  align-items: center;
  background: rgba(10, 12, 20, 0.5);
  border-radius: 14px;
  padding: 8px 10px;
  border: 1px solid rgba(255, 255, 255, 0.08);
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}
#bottomRight .continuous-label {
  color: var(--ui-color,#eaeff8);
  margin-right: 6px;
}
#bottomRight .muted {
  opacity: .7;
}
#world {
  display: block;
  width: 100%;
  height: 100%;
  box-shadow: 0 2px 24px rgba(0, 0, 0, 0.45);
}
#devControls {
  position: fixed;
  left: 12px;
  bottom: 80px;
  background: rgba(0, 0, 0, 0.5);
  padding: 8px;
  border-radius: 6px;
  color: #fff;
  font-size: 13px;
  z-index: 11;
}
#devControls input[type=range] {
  width: 180px;
  display: block;
  margin-top: 6px;
}

/* src/styles/bundle.css */
/*# sourceMappingURL=bundled.css.map */

</style>
</head>
<body>
  <div id="topRightRenderer">
    <span id="rendererType" class="renderer-type">Renderer: Canvas</span>
    <span id="rendererDims" class="renderer-dims">1280 x 720 px</span>
  </div>
  <canvas id="world"></canvas>
  <div id="ui">
    <button id="startPause" class="btn">‚ñ∂ Start</button>
    <button id="reset" class="btn">‚Ü∫ Reset</button>
    <button id="addRed" class="btn" title="Add Red ship">+ Red</button>
    <button id="addBlue" class="btn" title="Add Blue ship">+ Blue</button>
    <button id="toggleTrails" class="btn">‚òÑ Trails: On</button>
    <div class="btn" id="speed">Speed: 1√ó</div>
    <div class="badge red" id="redScore">Red 0</div>
    <div class="badge blue" id="blueScore">Blue 0</div>
  <div id="stats">Ships: 0 (R:0 B:0) Bullets: 0</div>
  </div>
  <!-- Developer control: renderer scale slider (dev-only) -->
  <div id="devControls">
    <label for="rendererScaleRange">Renderer scale: <span id="rendererScaleValue">1.00</span></label>
    <input id="rendererScaleRange" type="range" min="0.25" max="2.0" step="0.01" value="1.0" />
    <input id="dynamicScaleCheckbox" type="checkbox" />
    <label for="dynamicScaleCheckbox" class="dynamic-label">Dynamic</label>
  </div>
  <div id="bottomRight">
    <input id="continuousCheckbox" type="checkbox" />
    <label for="continuousCheckbox" class="continuous-label">Continuous</label>
    <button id="seedBtn" class="btn" title="Re-seed RNG for reproducible battles">üé≤ Seed</button>
    <button id="formationBtn" class="btn" title="Re-form fleets">üõ∞Ô∏è Form</button>
    <span class="muted">Space Autobattler</span>
  </div>
  <div id="toast"></div>
  <script type="module">

			const __workerCode = "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/config/entitiesConfig.ts\nvar entitiesConfig_exports = {};\n__export(entitiesConfig_exports, {\n  BULLET_DEFAULTS: () => BULLET_DEFAULTS,\n  PARTICLE_DEFAULTS: () => PARTICLE_DEFAULTS,\n  ShipConfig: () => ShipConfig,\n  bulletKindForRadius: () => bulletKindForRadius,\n  default: () => entitiesConfig_default,\n  getDefaultShipType: () => getDefaultShipType,\n  getShipConfig: () => getShipConfig\n});\nfunction getShipConfig() {\n  return ShipConfig;\n}\nfunction bulletKindForRadius(r) {\n  if (r < 2) return \"small\";\n  if (r < 2.5) return \"medium\";\n  if (r < 3.5) return \"large\";\n  return \"heavy\";\n}\nfunction getDefaultShipType() {\n  return Object.keys(ShipConfig)[0] || \"fighter\";\n}\nvar ShipConfig, BULLET_DEFAULTS, PARTICLE_DEFAULTS, entitiesConfig_default;\nvar init_entitiesConfig = __esm({\n  \"src/config/entitiesConfig.ts\"() {\n    \"use strict\";\n    ShipConfig = {\n      fighter: {\n        maxHp: 15,\n        armor: 0,\n        maxShield: 8,\n        shieldRegen: 1,\n        dmg: 3,\n        damage: 3,\n        radius: 12,\n        cannons: [\n          {\n            damage: 3,\n            rate: 3,\n            spread: 0.1,\n            muzzleSpeed: 260,\n            // was 300\n            bulletRadius: 1.5,\n            bulletTTL: 1.1\n            // was 1.2\n          }\n        ],\n        accel: 5,\n        turnRate: 6,\n        maxSpeed: 160\n      },\n      corvette: {\n        maxHp: 50,\n        armor: 0,\n        maxShield: Math.round(50 * 0.6),\n        shieldRegen: 0.5,\n        dmg: 5,\n        damage: 5,\n        radius: 20,\n        accel: 5,\n        turnRate: 3.5,\n        // was 3\n        maxSpeed: 145,\n        // was 140\n        cannons: [\n          {\n            damage: 6,\n            rate: 1.2,\n            spread: 0.05,\n            muzzleSpeed: 180,\n            // was 220\n            bulletRadius: 2,\n            bulletTTL: 1.8\n            // was 2.0\n          }\n        ]\n      },\n      frigate: {\n        maxHp: 80,\n        armor: 1,\n        maxShield: Math.round(80 * 0.6),\n        shieldRegen: 0.4,\n        dmg: 8,\n        damage: 8,\n        radius: 24,\n        cannons: [\n          {\n            damage: 8,\n            rate: 1,\n            spread: 0.06,\n            muzzleSpeed: 180,\n            // was 200\n            bulletRadius: 2.5,\n            bulletTTL: 2\n            // was 2.2\n          }\n        ],\n        accel: 5,\n        turnRate: 2.5,\n        // was 2.2\n        maxSpeed: 125\n        // was 120\n      },\n      destroyer: {\n        maxHp: 120,\n        armor: 2,\n        maxShield: Math.round(120 * 0.6),\n        shieldRegen: 0.3,\n        dmg: 12,\n        damage: 12,\n        radius: 40,\n        cannons: new Array(6).fill(0).map(() => ({\n          damage: 6,\n          rate: 0.8,\n          spread: 0.08,\n          muzzleSpeed: 160,\n          // was 240\n          bulletRadius: 2.5,\n          bulletTTL: 1.8\n          // was 2.4\n        })),\n        accel: 5,\n        turnRate: 2,\n        // was 1.6\n        maxSpeed: 110,\n        // was 100\n        turrets: [\n          {\n            position: [1.2, 0.8],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          },\n          {\n            position: [-1.2, 0.8],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          },\n          {\n            position: [1.2, -0.8],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          },\n          {\n            position: [-1.2, -0.8],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          },\n          {\n            position: [0, 1.5],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          },\n          {\n            position: [0, -1.5],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 0.8\n          }\n        ]\n      },\n      carrier: {\n        maxHp: 200,\n        armor: 3,\n        maxShield: Math.round(200 * 0.6),\n        shieldRegen: 0.2,\n        dmg: 2,\n        damage: 2,\n        radius: 40,\n        cannons: new Array(4).fill(0).map(() => ({\n          damage: 4,\n          rate: 0.6,\n          spread: 0.12,\n          muzzleSpeed: 140,\n          // was 180\n          bulletRadius: 3,\n          bulletTTL: 2.2\n          // was 2.8\n        })),\n        accel: 5,\n        turnRate: 1.2,\n        // was 0.8\n        maxSpeed: 95,\n        // was 80\n        carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 },\n        turrets: [\n          {\n            position: [2, 1.2],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 1\n          },\n          {\n            position: [-2, 1.2],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 1\n          },\n          {\n            position: [2, -1.2],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 1\n          },\n          {\n            position: [-2, -1.2],\n            kind: \"basic\",\n            targeting: \"nearest\",\n            cooldown: 1\n          }\n        ]\n      }\n    };\n    BULLET_DEFAULTS = {\n      damage: 1,\n      ttl: 2,\n      radius: 1.5,\n      muzzleSpeed: 240\n    };\n    PARTICLE_DEFAULTS = {\n      ttl: 1,\n      color: \"#fff\",\n      size: 2\n    };\n    entitiesConfig_default = ShipConfig;\n  }\n});\n\n// src/config/progressionConfig.ts\nvar progression = {\n  xpPerDamage: 1,\n  xpPerKill: 50,\n  xpToLevel: (level) => 100 * Math.pow(1.25, level - 1),\n  hpPercentPerLevel: (level) => Math.min(0.1, 0.05 + 0.05 / Math.sqrt(level)),\n  dmgPercentPerLevel: 0.08,\n  shieldPercentPerLevel: 0.06,\n  speedPercentPerLevel: 0.03,\n  regenPercentPerLevel: 0.04\n};\n\n// src/config/simConfig.ts\nvar boundaryBehavior = {\n  ships: \"wrap\",\n  bullets: \"remove\"\n};\n\n// src/rng.ts\nvar _seed = 1;\nfunction srand(seed = 1) {\n  _seed = seed >>> 0;\n}\nfunction mulberry32(a) {\n  return function() {\n    let t = (a += 1831565813) >>> 0;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nfunction srandom() {\n  const f = mulberry32(_seed);\n  _seed = _seed + 2654435761 >>> 0;\n  return f();\n}\nfunction srange(min, max) {\n  return min + (max - min) * srandom();\n}\n\n// src/entities.ts\ninit_entitiesConfig();\n\n// src/config/teamsConfig.ts\ninit_entitiesConfig();\nvar TeamsConfig = {\n  teams: {\n    red: { id: \"red\", color: \"#ff4d4d\", label: \"Red\" },\n    blue: { id: \"blue\", color: \"#4da6ff\", label: \"Blue\" }\n  },\n  defaultFleet: {\n    counts: (() => {\n      const shipCfg = getShipConfig();\n      const types = Object.keys(shipCfg || {});\n      const defaultCounts = {};\n      for (const t of types) {\n        if (t === \"fighter\") defaultCounts[t] = 8;\n        else if (t === \"corvette\") defaultCounts[t] = 3;\n        else if (t === \"frigate\") defaultCounts[t] = 2;\n        else if (t === \"destroyer\") defaultCounts[t] = 1;\n        else if (t === \"carrier\") defaultCounts[t] = 1;\n        else defaultCounts[t] = 1;\n      }\n      return defaultCounts;\n    })(),\n    spacing: 28,\n    jitter: { x: 80, y: 120 }\n  },\n  // continuousReinforcement controls: enable/disable, scoreMargin is the\n  // imbalance fraction (e.g. 0.12 means reinforce when weakest ratio < 0.38),\n  // perTick is the maximum ships considered per reinforcement tick, and\n  // shipTypes is an optional array of types to choose from randomly. If\n  // omitted, keys from defaultFleet.counts are used.\n  continuousReinforcement: {\n    enabled: false,\n    scoreMargin: 0.12,\n    perTick: 1,\n    interval: 5,\n    shipTypes: void 0\n  }\n};\nvar TEAM_DEFAULT = \"red\";\n\n// src/entities.ts\nvar nextId = 1;\nfunction genId() {\n  return nextId++;\n}\nfunction createBullet(x, y, vx, vy, team = TEAM_DEFAULT, ownerId = null, damage = 1, ttl = 2) {\n  return {\n    id: genId(),\n    x,\n    y,\n    vx,\n    vy,\n    team,\n    ownerId,\n    damage,\n    ttl\n  };\n}\n\n// src/config/behaviorConfig.ts\nvar AI_THRESHOLDS = {\n  decisionTimerMin: 0.5,\n  decisionTimerMax: 2,\n  hpEvadeThreshold: 0.35,\n  randomLow: 0.15,\n  randomHigh: 0.85\n};\n\n// src/behavior.ts\ninit_entitiesConfig();\nfunction len2(vx, vy) {\n  return vx * vx + vy * vy;\n}\nfunction clampSpeed(s, max) {\n  const v2 = len2(s.vx || 0, s.vy || 0);\n  const max2 = max * max;\n  if (v2 > max2 && v2 > 0) {\n    const inv = max / Math.sqrt(v2);\n    s.vx = (s.vx || 0) * inv;\n    s.vy = (s.vy || 0) * inv;\n  }\n}\nfunction aimWithSpread(from, to, spread = 0) {\n  let dx = (to.x || 0) - (from.x || 0);\n  let dy = (to.y || 0) - (from.y || 0);\n  const d = Math.hypot(dx, dy) || 1;\n  dx /= d;\n  dy /= d;\n  if (spread > 0) {\n    const ang = Math.atan2(dy, dx);\n    const jitter = srange(-spread, spread);\n    const na = ang + jitter;\n    return { x: Math.cos(na), y: Math.sin(na) };\n  }\n  return { x: dx, y: dy };\n}\nfunction tryFire(state2, ship, target, dt) {\n  if (Array.isArray(ship.cannons) && ship.cannons.length > 0) {\n    for (const c of ship.cannons) {\n      if (typeof c.__cd !== \"number\") c.__cd = 0;\n      c.__cd -= dt;\n      if (c.__cd > 0) continue;\n      const spread = typeof c.spread === \"number\" ? c.spread : 0;\n      const dir = aimWithSpread(ship, target, spread);\n      const speed = typeof c.muzzleSpeed === \"number\" ? c.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;\n      const dmg = typeof c.damage === \"number\" ? c.damage : typeof ship.damage === \"number\" ? ship.damage : typeof ship.dmg === \"number\" ? ship.dmg : BULLET_DEFAULTS.damage;\n      const ttl = typeof c.bulletTTL === \"number\" ? c.bulletTTL : BULLET_DEFAULTS.ttl;\n      const radius = typeof c.bulletRadius === \"number\" ? c.bulletRadius : BULLET_DEFAULTS.radius;\n      const vx = dir.x * speed;\n      const vy = dir.y * speed;\n      const b = Object.assign(\n        createBullet(\n          ship.x || 0,\n          ship.y || 0,\n          vx,\n          vy,\n          ship.team || TEAM_DEFAULT,\n          ship.id || null,\n          dmg,\n          ttl\n        ),\n        { radius }\n      );\n      state2.bullets.push(b);\n      const rate = typeof c.rate === \"number\" && c.rate > 0 ? c.rate : 1;\n      c.__cd = 1 / rate;\n    }\n  }\n  if (Array.isArray(ship.turrets) && ship.turrets.length > 0) {\n    for (const [i, turret] of ship.turrets.entries()) {\n      if (!turret) continue;\n      if (typeof turret.__cd !== \"number\") turret.__cd = 0;\n      turret.__cd -= dt;\n      if (turret.__cd > 0) continue;\n      let turretTarget = null;\n      if (turret.targeting === \"nearest\") {\n        const enemies = (state2.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team\n        );\n        let minDist = Infinity;\n        for (const enemy of enemies) {\n          const dx = (enemy.x || 0) - (ship.x || 0);\n          const dy = (enemy.y || 0) - (ship.y || 0);\n          const d2 = dx * dx + dy * dy;\n          if (d2 < minDist) {\n            minDist = d2;\n            turretTarget = enemy;\n          }\n        }\n      } else if (turret.targeting === \"random\") {\n        const enemies = (state2.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team\n        );\n        if (enemies.length)\n          turretTarget = enemies[Math.floor(srandom() * enemies.length)];\n      } else if (turret.targeting === \"focus\") {\n        if (ship.__ai && ship.__ai.targetId != null) {\n          turretTarget = (state2.ships || []).find(\n            (sh) => sh && sh.id === ship.__ai.targetId\n          ) || null;\n        }\n      } else {\n        const enemies = (state2.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team\n        );\n        let minDist = Infinity;\n        for (const enemy of enemies) {\n          const dx = (enemy.x || 0) - (ship.x || 0);\n          const dy = (enemy.y || 0) - (ship.y || 0);\n          const d2 = dx * dx + dy * dy;\n          if (d2 < minDist) {\n            minDist = d2;\n            turretTarget = enemy;\n          }\n        }\n      }\n      if (!turretTarget) continue;\n      const spread = typeof turret.spread === \"number\" ? turret.spread : 0.05;\n      const dir = aimWithSpread(ship, turretTarget, spread);\n      const speed = typeof turret.muzzleSpeed === \"number\" ? turret.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;\n      const dmg = typeof turret.damage === \"number\" ? turret.damage : typeof ship.damage === \"number\" ? ship.damage : BULLET_DEFAULTS.damage;\n      const ttl = typeof turret.bulletTTL === \"number\" ? turret.bulletTTL : BULLET_DEFAULTS.ttl;\n      const radius = typeof turret.bulletRadius === \"number\" ? turret.bulletRadius : BULLET_DEFAULTS.radius;\n      const angle = ship.angle || 0;\n      const shipType = ship.type || \"fighter\";\n      const shipCfg = (init_entitiesConfig(), __toCommonJS(entitiesConfig_exports)).getShipConfig()[shipType];\n      const configRadius = shipCfg && typeof shipCfg.radius === \"number\" ? shipCfg.radius : ship.radius || 12;\n      const [tx, ty] = turret.position || [0, 0];\n      const turretX = (ship.x || 0) + Math.cos(angle) * tx * configRadius - Math.sin(angle) * ty * configRadius;\n      const turretY = (ship.y || 0) + Math.sin(angle) * tx * configRadius + Math.cos(angle) * ty * configRadius;\n      const vx = dir.x * speed;\n      const vy = dir.y * speed;\n      const b = Object.assign(\n        createBullet(\n          turretX,\n          turretY,\n          vx,\n          vy,\n          ship.team || TEAM_DEFAULT,\n          ship.id || null,\n          dmg,\n          ttl\n        ),\n        { radius }\n      );\n      state2.bullets.push(b);\n      turret.__cd = typeof turret.cooldown === \"number\" && turret.cooldown > 0 ? turret.cooldown : 1;\n    }\n  }\n}\nfunction ensureShipAiState(s) {\n  if (!s.__ai) {\n    s.__ai = { state: \"idle\", decisionTimer: 0, targetId: null };\n  }\n  return s.__ai;\n}\nfunction chooseNewTarget(state2, ship) {\n  const enemies = (state2.ships || []).filter(\n    (sh) => sh && sh.team !== ship.team\n  );\n  if (!enemies.length) return null;\n  const idx = Math.floor(srandom() * enemies.length);\n  return enemies[idx];\n}\nfunction applySimpleAI(state2, dt, bounds2 = { W: 800, H: 600 }) {\n  if (!state2 || !Array.isArray(state2.ships)) return;\n  for (const s of state2.ships) {\n    const ai = ensureShipAiState(s);\n    ai.decisionTimer = Math.max(0, (ai.decisionTimer || 0) - dt);\n    let target = null;\n    if (ai.targetId != null)\n      target = (state2.ships || []).find((sh) => sh && sh.id === ai.targetId) || null;\n    if (!target) target = chooseNewTarget(state2, s);\n    if (target) ai.targetId = target.id;\n    const maxAccel = typeof s.accel === \"number\" ? s.accel : 100;\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\n    s.steering = typeof s.steering === \"number\" ? s.steering : 0;\n    s.throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\n    if (!target) {\n      s.throttle = 0;\n      s.steering = 0;\n      ai.state = \"idle\";\n    } else {\n      if (ai.decisionTimer <= 0) {\n        const hpFrac = (s.hp || 0) / Math.max(1, s.maxHp || 1);\n        const rnd = srandom();\n        if (hpFrac < AI_THRESHOLDS.hpEvadeThreshold || rnd < AI_THRESHOLDS.randomLow) ai.state = \"evade\";\n        else if (rnd < AI_THRESHOLDS.randomHigh) ai.state = \"engage\";\n        else ai.state = \"idle\";\n        ai.decisionTimer = AI_THRESHOLDS.decisionTimerMin + srandom() * (AI_THRESHOLDS.decisionTimerMax - AI_THRESHOLDS.decisionTimerMin);\n      }\n      const dx = (target.x || 0) - (s.x || 0);\n      const dy = (target.y || 0) - (s.y || 0);\n      const desiredAngle = Math.atan2(dy, dx);\n      const currentAngle = typeof s.angle === \"number\" ? s.angle : 0;\n      let da = desiredAngle - currentAngle;\n      while (da < -Math.PI) da += Math.PI * 2;\n      while (da > Math.PI) da -= Math.PI * 2;\n      const steeringNorm = Math.PI / 2;\n      const steering = Math.max(-1, Math.min(1, da / steeringNorm));\n      if (ai.state === \"engage\") {\n        s.throttle = 1;\n        s.steering = steering;\n        tryFire(state2, s, target, dt);\n      } else if (ai.state === \"evade\") {\n        s.throttle = 0.8;\n        const awayAngle = Math.atan2(\n          (s.y || 0) - (target.y || 0),\n          (s.x || 0) - (target.x || 0)\n        );\n        let daAway = awayAngle - currentAngle;\n        while (daAway < -Math.PI) daAway += Math.PI * 2;\n        while (daAway > Math.PI) daAway -= Math.PI * 2;\n        s.steering = Math.max(-1, Math.min(1, daAway / steeringNorm));\n      } else {\n        s.throttle = 0;\n        s.steering = 0;\n      }\n    }\n    clampSpeed(s, maxSpeed);\n  }\n}\n\n// src/gamemanager.ts\ninit_entitiesConfig();\n\n// src/config/gamemanagerConfig.ts\nvar SHIELD = {\n  ttl: 0.4,\n  particleCount: 6,\n  particleTTL: 0.5,\n  particleColor: \"#88ccff\",\n  particleSize: 2,\n  // arcWidth (radians) for shield hit visual/particle spread centered on hitAngle\n  // NOTE: Used in assetsConfig.ts visualStateDefaults and renderer logic. If not consumed, consider removing.\n  arcWidth: Math.PI / 6\n  // TODO: Ensure renderer/particle logic uses this or remove if redundant\n};\nvar HEALTH = {\n  ttl: 0.6,\n  particleCount: 8,\n  particleTTL: 0.6,\n  particleColor: \"#ffb3b3\",\n  particleSize: 2.5\n};\nvar EXPLOSION = {\n  particleCount: 30,\n  particleTTL: 1.2,\n  particleColor: \"#ffaa33\",\n  particleSize: 3,\n  minSpeed: 20,\n  maxSpeed: 140\n  // TODO: Unify particle effect configs with assetsConfig.ts animations for maintainability\n};\nvar STARS = { twinkle: true, redrawInterval: 500, count: 140 };\n\n// src/gamemanager.ts\ninit_entitiesConfig();\nvar particles = [];\nvar flashes = [];\nvar shieldFlashes = [];\nvar healthFlashes = [];\nvar particlePool = [];\nvar bulletPool = [];\nvar explosionPool = [];\nvar shieldHitPool = [];\nvar healthHitPool = [];\nfunction releaseBullet(b) {\n  if (!b.alive) return;\n  b.alive = false;\n  bulletPool.push(b);\n}\nfunction acquireExplosion(opts = {}) {\n  let e;\n  if (explosionPool.length) {\n    e = explosionPool.pop();\n    Object.assign(e, opts);\n    e.alive = true;\n    e._pooled = false;\n  } else {\n    e = { ...opts, alive: true, _pooled: false };\n  }\n  flashes.push(e);\n  return e;\n}\nfunction releaseExplosion(e) {\n  if (e._pooled) return;\n  if (!e.alive) return;\n  e.alive = false;\n  e._pooled = true;\n  explosionPool.push(e);\n}\nfunction acquireShieldHit(opts = {}) {\n  let sh = null;\n  if (shieldHitPool.length) {\n    sh = shieldHitPool.pop();\n    Object.assign(sh, opts);\n    sh.alive = true;\n    sh._pooled = false;\n  } else {\n    sh = { ...opts, alive: true, _pooled: false };\n  }\n  shieldFlashes.push(sh);\n  return sh;\n}\nfunction releaseShieldHit(sh) {\n  if (sh._pooled) return;\n  const i = shieldFlashes.indexOf(sh);\n  if (i !== -1) shieldFlashes.splice(i, 1);\n  sh.alive = false;\n  sh._pooled = true;\n  shieldHitPool.push(sh);\n}\nfunction acquireHealthHit(opts = {}) {\n  let hh = null;\n  if (healthHitPool.length) {\n    hh = healthHitPool.pop();\n    Object.assign(hh, opts);\n    hh.alive = true;\n    hh._pooled = false;\n  } else {\n    hh = { ...opts, alive: true, _pooled: false };\n  }\n  healthFlashes.push(hh);\n  return hh;\n}\nfunction releaseHealthHit(hh) {\n  if (hh._pooled) return;\n  const i = healthFlashes.indexOf(hh);\n  if (i !== -1) healthFlashes.splice(i, 1);\n  hh.alive = false;\n  hh._pooled = true;\n  healthHitPool.push(hh);\n}\nvar config = {\n  shield: { ...SHIELD },\n  health: { ...HEALTH },\n  explosion: { ...EXPLOSION },\n  stars: { ...STARS }\n};\nvar _reinforcementInterval = TeamsConfig.continuousReinforcement?.interval ?? 5;\nfunction releaseParticle(p) {\n  if (!p._pooled) {\n    p._pooled = true;\n    p.alive = false;\n    const idx = particles.indexOf(p);\n    if (idx !== -1) {\n      particles.splice(idx, 1);\n    }\n    particlePool.push(p);\n  }\n}\n\n// src/simulate.ts\nfunction dist2(a, b) {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\nfunction simulateStep(state2, dtSeconds, bounds2) {\n  pruneAll(state2, dtSeconds, bounds2);\n  state2.t = (state2.t || 0) + dtSeconds;\n  for (let i = (state2.bullets || []).length - 1; i >= 0; i--) {\n    const b = state2.bullets[i];\n    b.x += (b.vx || 0) * dtSeconds;\n    b.y += (b.vy || 0) * dtSeconds;\n    b.ttl = (b.ttl || 0) - dtSeconds;\n    let outX = b.x < 0 || b.x >= bounds2.W;\n    let outY = b.y < 0 || b.y >= bounds2.H;\n    let outOfBounds = outX || outY;\n    let remove = false;\n    if (b.ttl <= 0) remove = true;\n    else if (outOfBounds) {\n      switch (boundaryBehavior.bullets) {\n        case \"remove\":\n          remove = true;\n          break;\n        case \"wrap\":\n          if (b.x < 0) b.x += bounds2.W;\n          if (b.x >= bounds2.W) b.x -= bounds2.W;\n          if (b.y < 0) b.y += bounds2.H;\n          if (b.y >= bounds2.H) b.y -= bounds2.H;\n          break;\n        case \"bounce\":\n          if (outX) {\n            b.vx = -(b.vx || 0);\n            b.x = Math.max(0, Math.min(bounds2.W, b.x));\n          }\n          if (outY) {\n            b.vy = -(b.vy || 0);\n            b.y = Math.max(0, Math.min(bounds2.H, b.y));\n          }\n          break;\n      }\n    }\n    if (remove) releaseBullet(b);\n  }\n  function pruneAll(state3, dtSeconds2, bounds3) {\n    state3.particles = state3.particles || [];\n    state3.explosions = state3.explosions || [];\n    state3.shieldHits = state3.shieldHits || [];\n    state3.healthHits = state3.healthHits || [];\n    let writeBullet = 0;\n    for (let read = 0; read < state3.bullets.length; read++) {\n      const b = state3.bullets[read];\n      b.x += (b.vx || 0) * dtSeconds2;\n      b.y += (b.vy || 0) * dtSeconds2;\n      b.ttl = (b.ttl || 0) - dtSeconds2;\n      let outX = b.x < 0 || b.x >= bounds3.W;\n      let outY = b.y < 0 || b.y >= bounds3.H;\n      let outOfBounds = outX || outY;\n      let remove = false;\n      if (b.ttl <= 0) remove = true;\n      else if (outOfBounds) {\n        switch (boundaryBehavior.bullets) {\n          case \"remove\":\n            remove = true;\n            break;\n          case \"wrap\":\n            if (b.x < 0) b.x += bounds3.W;\n            if (b.x >= bounds3.W) b.x -= bounds3.W;\n            if (b.y < 0) b.y += bounds3.H;\n            if (b.y >= bounds3.H) b.y -= bounds3.H;\n            break;\n          case \"bounce\":\n            if (outX) {\n              b.vx = -(b.vx || 0);\n              b.x = Math.max(0, Math.min(bounds3.W, b.x));\n            }\n            if (outY) {\n              b.vy = -(b.vy || 0);\n              b.y = Math.max(0, Math.min(bounds3.H, b.y));\n            }\n            break;\n        }\n      }\n      if (!remove) {\n        state3.bullets[writeBullet++] = b;\n      } else {\n        releaseBullet(b);\n      }\n    }\n    state3.bullets.length = writeBullet;\n    let writeParticle = 0;\n    for (let read = 0; read < state3.particles.length; read++) {\n      const p = state3.particles[read];\n      p.life = (p.life || p.ttl || 0) - dtSeconds2;\n      if (p.life > 0) {\n        state3.particles[writeParticle++] = p;\n      } else {\n        releaseParticle(p);\n      }\n    }\n    state3.particles.length = writeParticle;\n    let writeExplosion = 0;\n    for (let read = 0; read < state3.explosions.length; read++) {\n      const e = state3.explosions[read];\n      e.life = (e.life || e.ttl || 0) - dtSeconds2;\n      if (e.life > 0) {\n        state3.explosions[writeExplosion++] = e;\n      } else {\n        releaseExplosion(e);\n      }\n    }\n    state3.explosions.length = writeExplosion;\n    let writeShield = 0;\n    for (let read = 0; read < state3.shieldHits.length; read++) {\n      const sh = state3.shieldHits[read];\n      if (typeof sh.x === \"number\" && typeof sh.y === \"number\" && sh.x >= 0 && sh.x < bounds3.W && sh.y >= 0 && sh.y < bounds3.H) {\n        state3.shieldHits[writeShield++] = sh;\n      } else {\n        releaseShieldHit(sh);\n      }\n    }\n    state3.shieldHits.length = writeShield;\n    let writeHealth = 0;\n    for (let read = 0; read < state3.healthHits.length; read++) {\n      const hh = state3.healthHits[read];\n      if (typeof hh.x === \"number\" && typeof hh.y === \"number\" && hh.x >= 0 && hh.x < bounds3.W && hh.y >= 0 && hh.y < bounds3.H) {\n        state3.healthHits[writeHealth++] = hh;\n      } else {\n        releaseHealthHit(hh);\n      }\n    }\n    state3.healthHits.length = writeHealth;\n  }\n  for (let si = (state2.ships || []).length - 1; si >= 0; si--) {\n    const s = state2.ships[si];\n    const throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\n    const steering = typeof s.steering === \"number\" ? s.steering : 0;\n    const accel = typeof s.accel === \"number\" ? s.accel : 0;\n    const turnRate = typeof s.turnRate === \"number\" ? s.turnRate : 3;\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\n    const angle = typeof s.angle === \"number\" ? s.angle : 0;\n    const maxTurn = turnRate * Math.abs(steering) * dtSeconds;\n    if (steering !== 0) {\n      let a = angle + Math.sign(steering) * maxTurn;\n      while (a < -Math.PI) a += Math.PI * 2;\n      while (a > Math.PI) a -= Math.PI * 2;\n      s.angle = a;\n    }\n    const actualAccel = accel * throttle;\n    if (actualAccel > 0) {\n      s.vx = (s.vx || 0) + Math.cos(s.angle || 0) * actualAccel * dtSeconds;\n      s.vy = (s.vy || 0) + Math.sin(s.angle || 0) * actualAccel * dtSeconds;\n    }\n    const friction = typeof s.friction === \"number\" ? s.friction : 0.98;\n    s.vx = (s.vx || 0) * friction;\n    s.vy = (s.vy || 0) * friction;\n    clampSpeed(s, maxSpeed);\n    s.x += (s.vx || 0) * dtSeconds;\n    s.y += (s.vy || 0) * dtSeconds;\n    const r = typeof s.radius === \"number\" ? s.radius : 12;\n    let outX = s.x < -r || s.x > bounds2.W + r;\n    let outY = s.y < -r || s.y > bounds2.H + r;\n    let outOfBounds = outX || outY;\n    let remove = false;\n    if (outOfBounds) {\n      switch (boundaryBehavior.ships) {\n        case \"remove\":\n          remove = true;\n          break;\n        case \"wrap\":\n          if (s.x < -r) s.x += bounds2.W + r * 2;\n          if (s.x > bounds2.W + r) s.x -= bounds2.W + r * 2;\n          if (s.y < -r) s.y += bounds2.H + r * 2;\n          if (s.y > bounds2.H + r) s.y -= bounds2.H + r * 2;\n          break;\n        case \"bounce\":\n          if (outX) {\n            s.vx = -(s.vx || 0);\n            s.x = Math.max(-r, Math.min(bounds2.W + r, s.x));\n          }\n          if (outY) {\n            s.vy = -(s.vy || 0);\n            s.y = Math.max(-r, Math.min(bounds2.H + r, s.y));\n          }\n          break;\n      }\n    }\n    if (remove) state2.ships.splice(si, 1);\n  }\n  for (let bi = (state2.bullets || []).length - 1; bi >= 0; bi--) {\n    const b = state2.bullets[bi];\n    for (let si = (state2.ships || []).length - 1; si >= 0; si--) {\n      const s = state2.ships[si];\n      if (s.team === b.team) continue;\n      const r = (s.radius || 6) + (b.radius || 1);\n      if (dist2(b, s) <= r * r) {\n        const attacker = typeof b.ownerId === \"number\" || typeof b.ownerId === \"string\" ? (state2.ships || []).find((sh) => sh.id === b.ownerId) : void 0;\n        let dealtToShield = 0;\n        let dealtToHealth = 0;\n        const shield = s.shield || 0;\n        if (shield > 0) {\n          const absorbed = Math.min(shield, b.damage || 0);\n          s.shield = shield - absorbed;\n          const hitAngle = Math.atan2(\n            (b.y || 0) - (s.y || 0),\n            (b.x || 0) - (s.x || 0)\n          );\n          (state2.shieldHits ||= []).push(acquireShieldHit({\n            id: s.id,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            amount: absorbed,\n            hitAngle\n          }));\n          (state2.damageEvents ||= []).push({\n            id: s.id,\n            type: \"shield\",\n            amount: absorbed,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            attackerId: attacker && attacker.id\n          });\n          const remaining = (b.damage || 0) - absorbed;\n          if (remaining > 0) {\n            s.hp -= remaining;\n            (state2.healthHits ||= []).push(acquireHealthHit({\n              id: s.id,\n              x: b.x,\n              y: b.y,\n              team: s.team,\n              amount: remaining\n            }));\n            (state2.damageEvents ||= []).push({\n              id: s.id,\n              type: \"hp\",\n              amount: remaining,\n              x: b.x,\n              y: b.y,\n              team: s.team,\n              attackerId: attacker && attacker.id\n            });\n          }\n          dealtToShield = absorbed;\n          dealtToHealth = Math.max(0, (b.damage || 0) - absorbed);\n        } else {\n          s.hp -= b.damage || 0;\n          (state2.healthHits ||= []).push(acquireHealthHit({\n            id: s.id,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            amount: b.damage || 0\n          }));\n          (state2.damageEvents ||= []).push({\n            id: s.id,\n            type: \"hp\",\n            amount: b.damage || 0,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            attackerId: attacker && attacker.id\n          });\n          dealtToHealth = b.damage || 0;\n        }\n        s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n        s.shieldPercent = typeof s.maxShield === \"number\" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;\n        if (attacker) {\n          attacker.xp = (attacker.xp || 0) + (dealtToShield + dealtToHealth) * (progression.xpPerDamage || 0);\n          while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {\n            attacker.xp -= progression.xpToLevel(attacker.level || 1);\n            attacker.level = (attacker.level || 1) + 1;\n            const resolveScalar = (s2, lvl2) => typeof s2 === \"function\" ? s2(lvl2) : s2 || 0;\n            const lvl = attacker.level || 1;\n            const hpScalar = resolveScalar(\n              progression.hpPercentPerLevel,\n              lvl\n            );\n            const shScalar = resolveScalar(\n              progression.shieldPercentPerLevel,\n              lvl\n            );\n            const dmgScalar = resolveScalar(\n              progression.dmgPercentPerLevel,\n              lvl\n            );\n            const speedScalar = resolveScalar(\n              progression.speedPercentPerLevel,\n              lvl\n            );\n            const regenScalar = resolveScalar(\n              progression.regenPercentPerLevel,\n              lvl\n            );\n            const hpMul = 1 + hpScalar;\n            const shMul = 1 + shScalar;\n            const dmgMul = 1 + dmgScalar;\n            attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n            attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);\n            if (typeof attacker.maxShield === \"number\") {\n              attacker.maxShield = (attacker.maxShield || 0) * shMul;\n              attacker.shield = Math.min(\n                attacker.maxShield,\n                (attacker.shield || 0) * shMul\n              );\n            }\n            if (Array.isArray(attacker.cannons)) {\n              for (const c of attacker.cannons) {\n                if (typeof c.damage === \"number\") c.damage *= dmgMul;\n              }\n            }\n            if (typeof speedScalar === \"number\" && typeof attacker.accel === \"number\")\n              attacker.accel = attacker.accel * (1 + speedScalar);\n            if (typeof regenScalar === \"number\" && typeof attacker.shieldRegen === \"number\")\n              attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n          }\n        }\n        state2.bullets.splice(bi, 1);\n        if (s.hp <= 0) {\n          console.log(\n            \"DEBUG: KILL BRANCH, attacker\",\n            attacker && attacker.id,\n            \"xp before\",\n            attacker && attacker.xp\n          );\n          if (attacker) {\n            attacker.xp = (attacker.xp || 0) + (progression.xpPerKill || 0);\n            console.log(\n              \"DEBUG: KILL XP AWARDED, attacker\",\n              attacker.id,\n              \"xp after\",\n              attacker.xp\n            );\n            while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {\n              attacker.xp -= progression.xpToLevel(attacker.level || 1);\n              attacker.level = (attacker.level || 1) + 1;\n              const resolveScalar = (s2, lvl2) => typeof s2 === \"function\" ? s2(lvl2) : s2 || 0;\n              const lvl = attacker.level || 1;\n              const hpScalar = resolveScalar(\n                progression.hpPercentPerLevel,\n                lvl\n              );\n              const shScalar = resolveScalar(\n                progression.shieldPercentPerLevel,\n                lvl\n              );\n              const dmgScalar = resolveScalar(\n                progression.dmgPercentPerLevel,\n                lvl\n              );\n              const speedScalar = resolveScalar(\n                progression.speedPercentPerLevel,\n                lvl\n              );\n              const regenScalar = resolveScalar(\n                progression.regenPercentPerLevel,\n                lvl\n              );\n              const hpMul = 1 + hpScalar;\n              const shMul = 1 + shScalar;\n              const dmgMul = 1 + dmgScalar;\n              attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n              attacker.hp = Math.min(\n                attacker.maxHp,\n                (attacker.hp || 0) * hpMul\n              );\n              if (typeof attacker.maxShield === \"number\") {\n                attacker.maxShield = (attacker.maxShield || 0) * shMul;\n                attacker.shield = Math.min(\n                  attacker.maxShield,\n                  (attacker.shield || 0) * shMul\n                );\n              }\n              if (Array.isArray(attacker.cannons)) {\n                for (const c of attacker.cannons) {\n                  if (typeof c.damage === \"number\") c.damage *= dmgMul;\n                }\n              }\n              if (typeof speedScalar === \"number\" && typeof attacker.accel === \"number\")\n                attacker.accel = attacker.accel * (1 + speedScalar);\n              if (typeof regenScalar === \"number\" && typeof attacker.shieldRegen === \"number\")\n                attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n            }\n          }\n          (state2.explosions ||= []).push(acquireExplosion({ x: s.x, y: s.y, team: s.team, life: 0.5, ttl: 0.5 }));\n          state2.ships.splice(si, 1);\n        }\n        break;\n      }\n    }\n  }\n  for (const s of state2.ships || []) {\n    if (s.maxShield)\n      s.shield = Math.min(\n        s.maxShield,\n        (s.shield || 0) + (s.shieldRegen || 0) * dtSeconds\n      );\n  }\n  for (const s of state2.ships || []) {\n    s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n    s.shieldPercent = typeof s.maxShield === \"number\" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;\n  }\n  return state2;\n}\n\n// src/simWorker.ts\nvar state = null;\nvar bounds = { W: 800, H: 600 };\nvar simDtMs = 16;\nvar running = false;\nvar acc = 0;\nvar last = 0;\nfunction postSnapshot() {\n  try {\n    postMessage({ type: \"snapshot\", state });\n    try {\n      clearTransientEvents(state);\n    } catch (e) {\n    }\n  } catch (e) {\n  }\n}\nfunction clearTransientEvents(s) {\n  if (!s || typeof s !== \"object\") return;\n  try {\n    if (Array.isArray(s.explosions)) s.explosions.length = 0;\n    if (Array.isArray(s.shieldHits)) s.shieldHits.length = 0;\n    if (Array.isArray(s.healthHits)) s.healthHits.length = 0;\n  } catch (e) {\n  }\n}\nfunction tick() {\n  if (!running) return;\n  const now = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  if (!last) last = now;\n  acc += now - last;\n  last = now;\n  if (acc > 250) acc = 250;\n  while (acc >= simDtMs) {\n    try {\n      applySimpleAI(state, simDtMs / 1e3, bounds);\n      simulateStep(state, simDtMs / 1e3, bounds);\n    } catch (e) {\n      const errAny = e;\n      const stack = errAny && errAny.stack ? errAny.stack : \"\";\n      postMessage({ type: \"error\", message: String(e), stack });\n    }\n    acc -= simDtMs;\n  }\n  postSnapshot();\n  setTimeout(tick, 0);\n}\nself.onmessage = (ev) => {\n  const msg = ev.data;\n  try {\n    switch (msg && msg.type) {\n      case \"init\":\n        if (typeof msg.seed === \"number\") srand(msg.seed);\n        if (msg.bounds) bounds = msg.bounds;\n        if (typeof msg.simDtMs === \"number\") simDtMs = msg.simDtMs;\n        if (msg.state) state = msg.state;\n        postMessage({ type: \"ready\" });\n        break;\n      case \"start\":\n        if (!state) {\n          postMessage({ type: \"error\", message: \"no state\" });\n          break;\n        }\n        running = true;\n        acc = 0;\n        last = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n        tick();\n        break;\n      case \"stop\":\n        running = false;\n        break;\n      case \"snapshotRequest\":\n        postSnapshot();\n        break;\n      case \"setSeed\":\n        if (typeof msg.seed === \"number\") {\n          srand(msg.seed);\n        }\n        break;\n      case \"command\":\n        if (msg.cmd === \"spawnShip\" && state) {\n          state.ships.push(msg.args.ship);\n        } else if (msg.cmd === \"spawnShipBullet\" && state) {\n          state.bullets.push(msg.args.bullet);\n        } else if (msg.cmd === \"setState\") {\n          state = msg.args.state;\n        }\n        break;\n      default:\n        break;\n    }\n  } catch (err) {\n    const stack = err && err.stack ? err.stack : \"\";\n    postMessage({ type: \"error\", message: String(err), stack });\n  }\n};\nvar simWorker_default = null;\nexport {\n  clearTransientEvents,\n  simWorker_default as default\n};\n//# sourceMappingURL=simWorker.js.map\n";
			const __workerBlob = new Blob([__workerCode], { type: 'text/javascript' });
			const __workerUrl = URL.createObjectURL(__workerBlob);
			const __OrigWorker = window.Worker;
			window.Worker = class extends __OrigWorker {
				constructor(url, opts) {
					try {
						const s = typeof url === 'string' ? url : String(url);
						if (s.endsWith('simWorker.js')) {
							super(__workerUrl, { type: 'module', ...(opts||{}) });
							return;
						}
					} catch {}
					super(url, opts);
				}
			};
		
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/config/entitiesConfig.ts
var entitiesConfig_exports = {};
__export(entitiesConfig_exports, {
  BULLET_DEFAULTS: () => BULLET_DEFAULTS,
  PARTICLE_DEFAULTS: () => PARTICLE_DEFAULTS,
  ShipConfig: () => ShipConfig,
  bulletKindForRadius: () => bulletKindForRadius,
  default: () => entitiesConfig_default,
  getDefaultShipType: () => getDefaultShipType,
  getShipConfig: () => getShipConfig
});
function getShipConfig() {
  return ShipConfig;
}
function bulletKindForRadius(r) {
  if (r < 2) return "small";
  if (r < 2.5) return "medium";
  if (r < 3.5) return "large";
  return "heavy";
}
function getDefaultShipType() {
  return Object.keys(ShipConfig)[0] || "fighter";
}
var ShipConfig, BULLET_DEFAULTS, PARTICLE_DEFAULTS, entitiesConfig_default;
var init_entitiesConfig = __esm({
  "src/config/entitiesConfig.ts"() {
    "use strict";
    ShipConfig = {
      fighter: {
        maxHp: 15,
        armor: 0,
        maxShield: 8,
        shieldRegen: 1,
        dmg: 3,
        damage: 3,
        radius: 12,
        cannons: [
          {
            damage: 3,
            rate: 3,
            spread: 0.1,
            muzzleSpeed: 260,
            // was 300
            bulletRadius: 1.5,
            bulletTTL: 1.1
            // was 1.2
          }
        ],
        accel: 5,
        turnRate: 6,
        maxSpeed: 160
      },
      corvette: {
        maxHp: 50,
        armor: 0,
        maxShield: Math.round(50 * 0.6),
        shieldRegen: 0.5,
        dmg: 5,
        damage: 5,
        radius: 20,
        accel: 5,
        turnRate: 3.5,
        // was 3
        maxSpeed: 145,
        // was 140
        cannons: [
          {
            damage: 6,
            rate: 1.2,
            spread: 0.05,
            muzzleSpeed: 180,
            // was 220
            bulletRadius: 2,
            bulletTTL: 1.8
            // was 2.0
          }
        ]
      },
      frigate: {
        maxHp: 80,
        armor: 1,
        maxShield: Math.round(80 * 0.6),
        shieldRegen: 0.4,
        dmg: 8,
        damage: 8,
        radius: 24,
        cannons: [
          {
            damage: 8,
            rate: 1,
            spread: 0.06,
            muzzleSpeed: 180,
            // was 200
            bulletRadius: 2.5,
            bulletTTL: 2
            // was 2.2
          }
        ],
        accel: 5,
        turnRate: 2.5,
        // was 2.2
        maxSpeed: 125
        // was 120
      },
      destroyer: {
        maxHp: 120,
        armor: 2,
        maxShield: Math.round(120 * 0.6),
        shieldRegen: 0.3,
        dmg: 12,
        damage: 12,
        radius: 40,
        cannons: new Array(6).fill(0).map(() => ({
          damage: 6,
          rate: 0.8,
          spread: 0.08,
          muzzleSpeed: 160,
          // was 240
          bulletRadius: 2.5,
          bulletTTL: 1.8
          // was 2.4
        })),
        accel: 5,
        turnRate: 2,
        // was 1.6
        maxSpeed: 110,
        // was 100
        turrets: [
          {
            position: [1.2, 0.8],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          },
          {
            position: [-1.2, 0.8],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          },
          {
            position: [1.2, -0.8],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          },
          {
            position: [-1.2, -0.8],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          },
          {
            position: [0, 1.5],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          },
          {
            position: [0, -1.5],
            kind: "basic",
            targeting: "nearest",
            cooldown: 0.8
          }
        ]
      },
      carrier: {
        maxHp: 200,
        armor: 3,
        maxShield: Math.round(200 * 0.6),
        shieldRegen: 0.2,
        dmg: 2,
        damage: 2,
        radius: 40,
        cannons: new Array(4).fill(0).map(() => ({
          damage: 4,
          rate: 0.6,
          spread: 0.12,
          muzzleSpeed: 140,
          // was 180
          bulletRadius: 3,
          bulletTTL: 2.2
          // was 2.8
        })),
        accel: 5,
        turnRate: 1.2,
        // was 0.8
        maxSpeed: 95,
        // was 80
        carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 },
        turrets: [
          {
            position: [2, 1.2],
            kind: "basic",
            targeting: "nearest",
            cooldown: 1
          },
          {
            position: [-2, 1.2],
            kind: "basic",
            targeting: "nearest",
            cooldown: 1
          },
          {
            position: [2, -1.2],
            kind: "basic",
            targeting: "nearest",
            cooldown: 1
          },
          {
            position: [-2, -1.2],
            kind: "basic",
            targeting: "nearest",
            cooldown: 1
          }
        ]
      }
    };
    BULLET_DEFAULTS = {
      damage: 1,
      ttl: 2,
      radius: 1.5,
      muzzleSpeed: 240
    };
    PARTICLE_DEFAULTS = {
      ttl: 1,
      color: "#fff",
      size: 2
    };
    entitiesConfig_default = ShipConfig;
  }
});

// src/entities.ts
init_entitiesConfig();

// src/config/teamsConfig.ts
init_entitiesConfig();

// src/rng.ts
var _seed = 1;
function srand(seed = 1) {
  _seed = seed >>> 0;
}
function mulberry32(a) {
  return function() {
    let t = (a += 1831565813) >>> 0;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function srandom() {
  const f = mulberry32(_seed);
  _seed = _seed + 2654435761 >>> 0;
  return f();
}
function srange(min, max) {
  return min + (max - min) * srandom();
}

// src/config/teamsConfig.ts
var TeamsConfig = {
  teams: {
    red: { id: "red", color: "#ff4d4d", label: "Red" },
    blue: { id: "blue", color: "#4da6ff", label: "Blue" }
  },
  defaultFleet: {
    counts: (() => {
      const shipCfg = getShipConfig();
      const types = Object.keys(shipCfg || {});
      const defaultCounts = {};
      for (const t of types) {
        if (t === "fighter") defaultCounts[t] = 8;
        else if (t === "corvette") defaultCounts[t] = 3;
        else if (t === "frigate") defaultCounts[t] = 2;
        else if (t === "destroyer") defaultCounts[t] = 1;
        else if (t === "carrier") defaultCounts[t] = 1;
        else defaultCounts[t] = 1;
      }
      return defaultCounts;
    })(),
    spacing: 28,
    jitter: { x: 80, y: 120 }
  },
  // continuousReinforcement controls: enable/disable, scoreMargin is the
  // imbalance fraction (e.g. 0.12 means reinforce when weakest ratio < 0.38),
  // perTick is the maximum ships considered per reinforcement tick, and
  // shipTypes is an optional array of types to choose from randomly. If
  // omitted, keys from defaultFleet.counts are used.
  continuousReinforcement: {
    enabled: false,
    scoreMargin: 0.12,
    perTick: 1,
    interval: 5,
    shipTypes: void 0
  }
};
function mulberry322(seed) {
  let t = seed >>> 0;
  return function() {
    t += 1831565813;
    let r = Math.imul(t ^ t >>> 15, 1 | t);
    r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
    return ((r ^ r >>> 14) >>> 0) / 4294967296;
  };
}
function hashStringToInt(s) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619) >>> 0;
  }
  return h >>> 0;
}
function generateFleetForTeam(seed = 0, teamId = "red", bounds = { W: 800, H: 600 }, shipFactory, options = {}) {
  const cfg = Object.assign({}, TeamsConfig.defaultFleet, options.fleet || {});
  const spacing = options.spacing ?? cfg.spacing;
  const jitter = Object.assign({}, cfg.jitter, options.jitter || {});
  const centerY = bounds.H / 2;
  const baseX = teamId === "red" ? bounds.W * 0.22 : bounds.W * 0.78;
  const rng = mulberry322((seed >>> 0) + hashStringToInt(teamId));
  const out = [];
  for (const [type, count] of Object.entries(cfg.counts)) {
    for (let i = 0; i < count; i++) {
      const r = spacing * Math.sqrt(rng());
      const angle = rng() * Math.PI * 2;
      const dx = Math.cos(angle) * r + (rng() - 0.5) * (jitter.x ?? 0);
      const dy = Math.sin(angle) * r + (rng() - 0.5) * (jitter.y ?? 0);
      const x = Math.max(0, Math.min(bounds.W - 1e-6, baseX + dx));
      const y = Math.max(0, Math.min(bounds.H - 1e-6, centerY + dy));
      if (typeof shipFactory === "function")
        out.push(shipFactory(type, x, y, teamId));
      else out.push({ type, x, y, team: teamId });
    }
  }
  return out;
}
function makeInitialFleets(seed = 0, bounds = { W: 800, H: 600 }, shipFactory, options = {}) {
  const red = generateFleetForTeam(seed, "red", bounds, shipFactory, options);
  const blue = generateFleetForTeam(
    seed + 1,
    "blue",
    bounds,
    shipFactory,
    options
  );
  return red.concat(blue);
}
function chooseReinforcements(seed = 0, state = {}, options = {}) {
  const cfg = Object.assign({}, TeamsConfig.continuousReinforcement, options);
  if (!cfg.enabled) return [];
  const teamStrength = {};
  if (Array.isArray(state.ships)) {
    for (const s of state.ships) {
      if (!s || !s.team) continue;
      const hp = typeof s.hp === "number" ? s.hp : 1;
      teamStrength[s.team] = (teamStrength[s.team] || 0) + hp;
    }
  }
  const teams = Object.keys(TeamsConfig.teams);
  if (teams.length === 0) return [];
  for (const t of teams) {
    if (!teamStrength[t]) {
      const cnt = (state.ships || []).filter(
        (s) => s && s.team === t
      ).length;
      teamStrength[t] = cnt > 0 ? cnt : 0;
    }
  }
  let weakest = teams[0];
  let strongest = teams[0];
  for (const t of teams) {
    if (teamStrength[t] < teamStrength[weakest]) weakest = t;
    if (teamStrength[t] > teamStrength[strongest]) strongest = t;
  }
  const total = teams.reduce((s, t) => s + (teamStrength[t] || 0), 0) || 1;
  const weakestRatio = (teamStrength[weakest] || 0) / total;
  if (weakestRatio < 0.5 - cfg.scoreMargin) {
    const orders = [];
    const rng = mulberry322((seed >>> 0) + hashStringToInt(weakest));
    const candidateTypes = Array.isArray(cfg.shipTypes) && cfg.shipTypes.length ? cfg.shipTypes : Object.keys(TeamsConfig.defaultFleet.counts || { fighter: 1 });
    const countsMap = TeamsConfig && TeamsConfig.defaultFleet && TeamsConfig.defaultFleet.counts ? TeamsConfig.defaultFleet.counts : {};
    const weights = candidateTypes.map(
      (t) => Math.max(0, Number(countsMap[t]) || 1)
    );
    const totalWeight = weights.reduce((s, w) => s + w, 0) || candidateTypes.length || 1;
    const weightedPick = () => {
      const r = rng() * totalWeight;
      let acc = 0;
      for (let i = 0; i < candidateTypes.length; i++) {
        acc += weights[i];
        if (r < acc) return candidateTypes[i];
      }
      return candidateTypes[candidateTypes.length - 1];
    };
    const maxPerTick = Math.max(1, Math.floor(Number(cfg.perTick) || 1));
    const spawnCount = Math.max(1, Math.floor(rng() * maxPerTick) + 1);
    const b = options.bounds || { W: 800, H: 600 };
    const centerY = b.H / 2;
    const baseX = weakest === "red" ? b.W * 0.18 : b.W * 0.82;
    for (let i = 0; i < spawnCount; i++) {
      const x = Math.max(0, Math.min(b.W - 1e-6, baseX + (rng() - 0.5) * 120));
      const y = Math.max(
        0,
        Math.min(b.H - 1e-6, centerY + (rng() - 0.5) * 160)
      );
      const type = Array.isArray(cfg.shipTypes) && cfg.shipTypes.length ? candidateTypes[Math.floor(rng() * candidateTypes.length)] || getDefaultShipType() : weightedPick();
      orders.push({ type, team: weakest, x, y });
    }
    return orders;
  }
  return [];
}
var TEAM_DEFAULT = "red";
var teamsConfig_default = TeamsConfig;
function chooseReinforcementsWithManagerSeed(state = {}, options = {}) {
  const seed = Math.floor(srandom() * 4294967295) >>> 0;
  return chooseReinforcements(seed, state, options);
}

// src/entities.ts
var nextId = 1;
function genId() {
  return nextId++;
}
function createShip(type = void 0, x = 0, y = 0, team = TEAM_DEFAULT) {
  const shipCfg = getShipConfig();
  const availableTypes = Object.keys(shipCfg || {});
  const resolvedType = type && shipCfg[type] ? type : availableTypes.length ? availableTypes[0] : getDefaultShipType();
  const cfg = shipCfg[resolvedType] || shipCfg[getDefaultShipType()];
  return {
    id: genId(),
    type: resolvedType,
    x,
    y,
    vx: 0,
    vy: 0,
    hp: cfg.maxHp,
    maxHp: cfg.maxHp,
    shield: cfg.maxShield || 0,
    maxShield: cfg.maxShield || 0,
    team,
    xp: 0,
    level: 1,
    cannons: JSON.parse(JSON.stringify(cfg.cannons || [])),
    accel: cfg.accel || 0,
    currentAccel: 0,
    // start at rest, AI/gamemanager sets this
    throttle: 0,
    // start at rest, AI/gamemanager sets this
    steering: 0,
    // start straight, AI/gamemanager sets this
    turnRate: cfg.turnRate || 0,
    radius: cfg.radius || 6,
    maxSpeed: cfg.maxSpeed || void 0,
    angle: 0
  };
}
function createBullet(x, y, vx, vy, team = TEAM_DEFAULT, ownerId = null, damage = 1, ttl = 2) {
  return {
    id: genId(),
    x,
    y,
    vx,
    vy,
    team,
    ownerId,
    damage,
    ttl
  };
}
function makeInitialState() {
  return {
    t: 0,
    ships: [],
    bullets: [],
    explosions: [],
    shieldHits: [],
    healthHits: [],
    engineTrailsEnabled: true
  };
}

// src/gamemanager.ts
init_entitiesConfig();

// src/config/behaviorConfig.ts
var AI_THRESHOLDS = {
  decisionTimerMin: 0.5,
  decisionTimerMax: 2,
  hpEvadeThreshold: 0.35,
  randomLow: 0.15,
  randomHigh: 0.85
};

// src/behavior.ts
init_entitiesConfig();
function len2(vx, vy) {
  return vx * vx + vy * vy;
}
function clampSpeed(s, max) {
  const v2 = len2(s.vx || 0, s.vy || 0);
  const max2 = max * max;
  if (v2 > max2 && v2 > 0) {
    const inv = max / Math.sqrt(v2);
    s.vx = (s.vx || 0) * inv;
    s.vy = (s.vy || 0) * inv;
  }
}
function aimWithSpread(from, to, spread = 0) {
  let dx = (to.x || 0) - (from.x || 0);
  let dy = (to.y || 0) - (from.y || 0);
  const d = Math.hypot(dx, dy) || 1;
  dx /= d;
  dy /= d;
  if (spread > 0) {
    const ang = Math.atan2(dy, dx);
    const jitter = srange(-spread, spread);
    const na = ang + jitter;
    return { x: Math.cos(na), y: Math.sin(na) };
  }
  return { x: dx, y: dy };
}
function tryFire(state, ship, target, dt) {
  if (Array.isArray(ship.cannons) && ship.cannons.length > 0) {
    for (const c of ship.cannons) {
      if (typeof c.__cd !== "number") c.__cd = 0;
      c.__cd -= dt;
      if (c.__cd > 0) continue;
      const spread = typeof c.spread === "number" ? c.spread : 0;
      const dir = aimWithSpread(ship, target, spread);
      const speed = typeof c.muzzleSpeed === "number" ? c.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;
      const dmg = typeof c.damage === "number" ? c.damage : typeof ship.damage === "number" ? ship.damage : typeof ship.dmg === "number" ? ship.dmg : BULLET_DEFAULTS.damage;
      const ttl = typeof c.bulletTTL === "number" ? c.bulletTTL : BULLET_DEFAULTS.ttl;
      const radius = typeof c.bulletRadius === "number" ? c.bulletRadius : BULLET_DEFAULTS.radius;
      const vx = dir.x * speed;
      const vy = dir.y * speed;
      const b = Object.assign(
        createBullet(
          ship.x || 0,
          ship.y || 0,
          vx,
          vy,
          ship.team || TEAM_DEFAULT,
          ship.id || null,
          dmg,
          ttl
        ),
        { radius }
      );
      state.bullets.push(b);
      const rate = typeof c.rate === "number" && c.rate > 0 ? c.rate : 1;
      c.__cd = 1 / rate;
    }
  }
  if (Array.isArray(ship.turrets) && ship.turrets.length > 0) {
    for (const [i, turret] of ship.turrets.entries()) {
      if (!turret) continue;
      if (typeof turret.__cd !== "number") turret.__cd = 0;
      turret.__cd -= dt;
      if (turret.__cd > 0) continue;
      let turretTarget = null;
      if (turret.targeting === "nearest") {
        const enemies = (state.ships || []).filter(
          (sh) => sh && sh.team !== ship.team
        );
        let minDist = Infinity;
        for (const enemy of enemies) {
          const dx = (enemy.x || 0) - (ship.x || 0);
          const dy = (enemy.y || 0) - (ship.y || 0);
          const d2 = dx * dx + dy * dy;
          if (d2 < minDist) {
            minDist = d2;
            turretTarget = enemy;
          }
        }
      } else if (turret.targeting === "random") {
        const enemies = (state.ships || []).filter(
          (sh) => sh && sh.team !== ship.team
        );
        if (enemies.length)
          turretTarget = enemies[Math.floor(srandom() * enemies.length)];
      } else if (turret.targeting === "focus") {
        if (ship.__ai && ship.__ai.targetId != null) {
          turretTarget = (state.ships || []).find(
            (sh) => sh && sh.id === ship.__ai.targetId
          ) || null;
        }
      } else {
        const enemies = (state.ships || []).filter(
          (sh) => sh && sh.team !== ship.team
        );
        let minDist = Infinity;
        for (const enemy of enemies) {
          const dx = (enemy.x || 0) - (ship.x || 0);
          const dy = (enemy.y || 0) - (ship.y || 0);
          const d2 = dx * dx + dy * dy;
          if (d2 < minDist) {
            minDist = d2;
            turretTarget = enemy;
          }
        }
      }
      if (!turretTarget) continue;
      const spread = typeof turret.spread === "number" ? turret.spread : 0.05;
      const dir = aimWithSpread(ship, turretTarget, spread);
      const speed = typeof turret.muzzleSpeed === "number" ? turret.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;
      const dmg = typeof turret.damage === "number" ? turret.damage : typeof ship.damage === "number" ? ship.damage : BULLET_DEFAULTS.damage;
      const ttl = typeof turret.bulletTTL === "number" ? turret.bulletTTL : BULLET_DEFAULTS.ttl;
      const radius = typeof turret.bulletRadius === "number" ? turret.bulletRadius : BULLET_DEFAULTS.radius;
      const angle = ship.angle || 0;
      const shipType = ship.type || "fighter";
      const shipCfg = (init_entitiesConfig(), __toCommonJS(entitiesConfig_exports)).getShipConfig()[shipType];
      const configRadius = shipCfg && typeof shipCfg.radius === "number" ? shipCfg.radius : ship.radius || 12;
      const [tx, ty] = turret.position || [0, 0];
      const turretX = (ship.x || 0) + Math.cos(angle) * tx * configRadius - Math.sin(angle) * ty * configRadius;
      const turretY = (ship.y || 0) + Math.sin(angle) * tx * configRadius + Math.cos(angle) * ty * configRadius;
      const vx = dir.x * speed;
      const vy = dir.y * speed;
      const b = Object.assign(
        createBullet(
          turretX,
          turretY,
          vx,
          vy,
          ship.team || TEAM_DEFAULT,
          ship.id || null,
          dmg,
          ttl
        ),
        { radius }
      );
      state.bullets.push(b);
      turret.__cd = typeof turret.cooldown === "number" && turret.cooldown > 0 ? turret.cooldown : 1;
    }
  }
}
function ensureShipAiState(s) {
  if (!s.__ai) {
    s.__ai = { state: "idle", decisionTimer: 0, targetId: null };
  }
  return s.__ai;
}
function chooseNewTarget(state, ship) {
  const enemies = (state.ships || []).filter(
    (sh) => sh && sh.team !== ship.team
  );
  if (!enemies.length) return null;
  const idx = Math.floor(srandom() * enemies.length);
  return enemies[idx];
}
function applySimpleAI(state, dt, bounds = { W: 800, H: 600 }) {
  if (!state || !Array.isArray(state.ships)) return;
  for (const s of state.ships) {
    const ai = ensureShipAiState(s);
    ai.decisionTimer = Math.max(0, (ai.decisionTimer || 0) - dt);
    let target = null;
    if (ai.targetId != null)
      target = (state.ships || []).find((sh) => sh && sh.id === ai.targetId) || null;
    if (!target) target = chooseNewTarget(state, s);
    if (target) ai.targetId = target.id;
    const maxAccel = typeof s.accel === "number" ? s.accel : 100;
    const maxSpeed = typeof s.maxSpeed === "number" ? s.maxSpeed : 160;
    s.steering = typeof s.steering === "number" ? s.steering : 0;
    s.throttle = typeof s.throttle === "number" ? s.throttle : 0;
    if (!target) {
      s.throttle = 0;
      s.steering = 0;
      ai.state = "idle";
    } else {
      if (ai.decisionTimer <= 0) {
        const hpFrac = (s.hp || 0) / Math.max(1, s.maxHp || 1);
        const rnd = srandom();
        if (hpFrac < AI_THRESHOLDS.hpEvadeThreshold || rnd < AI_THRESHOLDS.randomLow) ai.state = "evade";
        else if (rnd < AI_THRESHOLDS.randomHigh) ai.state = "engage";
        else ai.state = "idle";
        ai.decisionTimer = AI_THRESHOLDS.decisionTimerMin + srandom() * (AI_THRESHOLDS.decisionTimerMax - AI_THRESHOLDS.decisionTimerMin);
      }
      const dx = (target.x || 0) - (s.x || 0);
      const dy = (target.y || 0) - (s.y || 0);
      const desiredAngle = Math.atan2(dy, dx);
      const currentAngle = typeof s.angle === "number" ? s.angle : 0;
      let da = desiredAngle - currentAngle;
      while (da < -Math.PI) da += Math.PI * 2;
      while (da > Math.PI) da -= Math.PI * 2;
      const steeringNorm = Math.PI / 2;
      const steering = Math.max(-1, Math.min(1, da / steeringNorm));
      if (ai.state === "engage") {
        s.throttle = 1;
        s.steering = steering;
        tryFire(state, s, target, dt);
      } else if (ai.state === "evade") {
        s.throttle = 0.8;
        const awayAngle = Math.atan2(
          (s.y || 0) - (target.y || 0),
          (s.x || 0) - (target.x || 0)
        );
        let daAway = awayAngle - currentAngle;
        while (daAway < -Math.PI) daAway += Math.PI * 2;
        while (daAway > Math.PI) daAway -= Math.PI * 2;
        s.steering = Math.max(-1, Math.min(1, daAway / steeringNorm));
      } else {
        s.throttle = 0;
        s.steering = 0;
      }
    }
    clampSpeed(s, maxSpeed);
  }
}

// src/config/progressionConfig.ts
var progression = {
  xpPerDamage: 1,
  xpPerKill: 50,
  xpToLevel: (level) => 100 * Math.pow(1.25, level - 1),
  hpPercentPerLevel: (level) => Math.min(0.1, 0.05 + 0.05 / Math.sqrt(level)),
  dmgPercentPerLevel: 0.08,
  shieldPercentPerLevel: 0.06,
  speedPercentPerLevel: 0.03,
  regenPercentPerLevel: 0.04
};

// src/config/simConfig.ts
var SIM = {
  DT_MS: 16,
  MAX_ACC_MS: 250,
  bounds: { W: 1920, H: 1080 }
  // Use LOGICAL_MAP for default bounds
};
var boundaryBehavior = {
  ships: "wrap",
  bullets: "remove"
};
var LOGICAL_MAP = { W: 1920, H: 1080 };
function getDefaultBounds() {
  return { W: LOGICAL_MAP.W, H: LOGICAL_MAP.H };
}

// src/simulate.ts
function dist2(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy;
}
function simulateStep(state, dtSeconds, bounds) {
  pruneAll(state, dtSeconds, bounds);
  state.t = (state.t || 0) + dtSeconds;
  for (let i = (state.bullets || []).length - 1; i >= 0; i--) {
    const b = state.bullets[i];
    b.x += (b.vx || 0) * dtSeconds;
    b.y += (b.vy || 0) * dtSeconds;
    b.ttl = (b.ttl || 0) - dtSeconds;
    let outX = b.x < 0 || b.x >= bounds.W;
    let outY = b.y < 0 || b.y >= bounds.H;
    let outOfBounds = outX || outY;
    let remove = false;
    if (b.ttl <= 0) remove = true;
    else if (outOfBounds) {
      switch (boundaryBehavior.bullets) {
        case "remove":
          remove = true;
          break;
        case "wrap":
          if (b.x < 0) b.x += bounds.W;
          if (b.x >= bounds.W) b.x -= bounds.W;
          if (b.y < 0) b.y += bounds.H;
          if (b.y >= bounds.H) b.y -= bounds.H;
          break;
        case "bounce":
          if (outX) {
            b.vx = -(b.vx || 0);
            b.x = Math.max(0, Math.min(bounds.W, b.x));
          }
          if (outY) {
            b.vy = -(b.vy || 0);
            b.y = Math.max(0, Math.min(bounds.H, b.y));
          }
          break;
      }
    }
    if (remove) releaseBullet(b);
  }
  function pruneAll(state2, dtSeconds2, bounds2) {
    state2.particles = state2.particles || [];
    state2.explosions = state2.explosions || [];
    state2.shieldHits = state2.shieldHits || [];
    state2.healthHits = state2.healthHits || [];
    let writeBullet = 0;
    for (let read = 0; read < state2.bullets.length; read++) {
      const b = state2.bullets[read];
      b.x += (b.vx || 0) * dtSeconds2;
      b.y += (b.vy || 0) * dtSeconds2;
      b.ttl = (b.ttl || 0) - dtSeconds2;
      let outX = b.x < 0 || b.x >= bounds2.W;
      let outY = b.y < 0 || b.y >= bounds2.H;
      let outOfBounds = outX || outY;
      let remove = false;
      if (b.ttl <= 0) remove = true;
      else if (outOfBounds) {
        switch (boundaryBehavior.bullets) {
          case "remove":
            remove = true;
            break;
          case "wrap":
            if (b.x < 0) b.x += bounds2.W;
            if (b.x >= bounds2.W) b.x -= bounds2.W;
            if (b.y < 0) b.y += bounds2.H;
            if (b.y >= bounds2.H) b.y -= bounds2.H;
            break;
          case "bounce":
            if (outX) {
              b.vx = -(b.vx || 0);
              b.x = Math.max(0, Math.min(bounds2.W, b.x));
            }
            if (outY) {
              b.vy = -(b.vy || 0);
              b.y = Math.max(0, Math.min(bounds2.H, b.y));
            }
            break;
        }
      }
      if (!remove) {
        state2.bullets[writeBullet++] = b;
      } else {
        releaseBullet(b);
      }
    }
    state2.bullets.length = writeBullet;
    let writeParticle = 0;
    for (let read = 0; read < state2.particles.length; read++) {
      const p = state2.particles[read];
      p.life = (p.life || p.ttl || 0) - dtSeconds2;
      if (p.life > 0) {
        state2.particles[writeParticle++] = p;
      } else {
        releaseParticle(p);
      }
    }
    state2.particles.length = writeParticle;
    let writeExplosion = 0;
    for (let read = 0; read < state2.explosions.length; read++) {
      const e = state2.explosions[read];
      e.life = (e.life || e.ttl || 0) - dtSeconds2;
      if (e.life > 0) {
        state2.explosions[writeExplosion++] = e;
      } else {
        releaseExplosion(e);
      }
    }
    state2.explosions.length = writeExplosion;
    let writeShield = 0;
    for (let read = 0; read < state2.shieldHits.length; read++) {
      const sh = state2.shieldHits[read];
      if (typeof sh.x === "number" && typeof sh.y === "number" && sh.x >= 0 && sh.x < bounds2.W && sh.y >= 0 && sh.y < bounds2.H) {
        state2.shieldHits[writeShield++] = sh;
      } else {
        releaseShieldHit(sh);
      }
    }
    state2.shieldHits.length = writeShield;
    let writeHealth = 0;
    for (let read = 0; read < state2.healthHits.length; read++) {
      const hh = state2.healthHits[read];
      if (typeof hh.x === "number" && typeof hh.y === "number" && hh.x >= 0 && hh.x < bounds2.W && hh.y >= 0 && hh.y < bounds2.H) {
        state2.healthHits[writeHealth++] = hh;
      } else {
        releaseHealthHit(hh);
      }
    }
    state2.healthHits.length = writeHealth;
  }
  for (let si = (state.ships || []).length - 1; si >= 0; si--) {
    const s = state.ships[si];
    const throttle = typeof s.throttle === "number" ? s.throttle : 0;
    const steering = typeof s.steering === "number" ? s.steering : 0;
    const accel = typeof s.accel === "number" ? s.accel : 0;
    const turnRate = typeof s.turnRate === "number" ? s.turnRate : 3;
    const maxSpeed = typeof s.maxSpeed === "number" ? s.maxSpeed : 160;
    const angle = typeof s.angle === "number" ? s.angle : 0;
    const maxTurn = turnRate * Math.abs(steering) * dtSeconds;
    if (steering !== 0) {
      let a = angle + Math.sign(steering) * maxTurn;
      while (a < -Math.PI) a += Math.PI * 2;
      while (a > Math.PI) a -= Math.PI * 2;
      s.angle = a;
    }
    const actualAccel = accel * throttle;
    if (actualAccel > 0) {
      s.vx = (s.vx || 0) + Math.cos(s.angle || 0) * actualAccel * dtSeconds;
      s.vy = (s.vy || 0) + Math.sin(s.angle || 0) * actualAccel * dtSeconds;
    }
    const friction = typeof s.friction === "number" ? s.friction : 0.98;
    s.vx = (s.vx || 0) * friction;
    s.vy = (s.vy || 0) * friction;
    clampSpeed(s, maxSpeed);
    s.x += (s.vx || 0) * dtSeconds;
    s.y += (s.vy || 0) * dtSeconds;
    const r = typeof s.radius === "number" ? s.radius : 12;
    let outX = s.x < -r || s.x > bounds.W + r;
    let outY = s.y < -r || s.y > bounds.H + r;
    let outOfBounds = outX || outY;
    let remove = false;
    if (outOfBounds) {
      switch (boundaryBehavior.ships) {
        case "remove":
          remove = true;
          break;
        case "wrap":
          if (s.x < -r) s.x += bounds.W + r * 2;
          if (s.x > bounds.W + r) s.x -= bounds.W + r * 2;
          if (s.y < -r) s.y += bounds.H + r * 2;
          if (s.y > bounds.H + r) s.y -= bounds.H + r * 2;
          break;
        case "bounce":
          if (outX) {
            s.vx = -(s.vx || 0);
            s.x = Math.max(-r, Math.min(bounds.W + r, s.x));
          }
          if (outY) {
            s.vy = -(s.vy || 0);
            s.y = Math.max(-r, Math.min(bounds.H + r, s.y));
          }
          break;
      }
    }
    if (remove) state.ships.splice(si, 1);
  }
  for (let bi = (state.bullets || []).length - 1; bi >= 0; bi--) {
    const b = state.bullets[bi];
    for (let si = (state.ships || []).length - 1; si >= 0; si--) {
      const s = state.ships[si];
      if (s.team === b.team) continue;
      const r = (s.radius || 6) + (b.radius || 1);
      if (dist2(b, s) <= r * r) {
        const attacker = typeof b.ownerId === "number" || typeof b.ownerId === "string" ? (state.ships || []).find((sh) => sh.id === b.ownerId) : void 0;
        let dealtToShield = 0;
        let dealtToHealth = 0;
        const shield = s.shield || 0;
        if (shield > 0) {
          const absorbed = Math.min(shield, b.damage || 0);
          s.shield = shield - absorbed;
          const hitAngle = Math.atan2(
            (b.y || 0) - (s.y || 0),
            (b.x || 0) - (s.x || 0)
          );
          (state.shieldHits ||= []).push(acquireShieldHit({
            id: s.id,
            x: b.x,
            y: b.y,
            team: s.team,
            amount: absorbed,
            hitAngle
          }));
          (state.damageEvents ||= []).push({
            id: s.id,
            type: "shield",
            amount: absorbed,
            x: b.x,
            y: b.y,
            team: s.team,
            attackerId: attacker && attacker.id
          });
          const remaining = (b.damage || 0) - absorbed;
          if (remaining > 0) {
            s.hp -= remaining;
            (state.healthHits ||= []).push(acquireHealthHit({
              id: s.id,
              x: b.x,
              y: b.y,
              team: s.team,
              amount: remaining
            }));
            (state.damageEvents ||= []).push({
              id: s.id,
              type: "hp",
              amount: remaining,
              x: b.x,
              y: b.y,
              team: s.team,
              attackerId: attacker && attacker.id
            });
          }
          dealtToShield = absorbed;
          dealtToHealth = Math.max(0, (b.damage || 0) - absorbed);
        } else {
          s.hp -= b.damage || 0;
          (state.healthHits ||= []).push(acquireHealthHit({
            id: s.id,
            x: b.x,
            y: b.y,
            team: s.team,
            amount: b.damage || 0
          }));
          (state.damageEvents ||= []).push({
            id: s.id,
            type: "hp",
            amount: b.damage || 0,
            x: b.x,
            y: b.y,
            team: s.team,
            attackerId: attacker && attacker.id
          });
          dealtToHealth = b.damage || 0;
        }
        s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));
        s.shieldPercent = typeof s.maxShield === "number" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;
        if (attacker) {
          attacker.xp = (attacker.xp || 0) + (dealtToShield + dealtToHealth) * (progression.xpPerDamage || 0);
          while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {
            attacker.xp -= progression.xpToLevel(attacker.level || 1);
            attacker.level = (attacker.level || 1) + 1;
            const resolveScalar = (s2, lvl2) => typeof s2 === "function" ? s2(lvl2) : s2 || 0;
            const lvl = attacker.level || 1;
            const hpScalar = resolveScalar(
              progression.hpPercentPerLevel,
              lvl
            );
            const shScalar = resolveScalar(
              progression.shieldPercentPerLevel,
              lvl
            );
            const dmgScalar = resolveScalar(
              progression.dmgPercentPerLevel,
              lvl
            );
            const speedScalar = resolveScalar(
              progression.speedPercentPerLevel,
              lvl
            );
            const regenScalar = resolveScalar(
              progression.regenPercentPerLevel,
              lvl
            );
            const hpMul = 1 + hpScalar;
            const shMul = 1 + shScalar;
            const dmgMul = 1 + dmgScalar;
            attacker.maxHp = (attacker.maxHp || 0) * hpMul;
            attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);
            if (typeof attacker.maxShield === "number") {
              attacker.maxShield = (attacker.maxShield || 0) * shMul;
              attacker.shield = Math.min(
                attacker.maxShield,
                (attacker.shield || 0) * shMul
              );
            }
            if (Array.isArray(attacker.cannons)) {
              for (const c of attacker.cannons) {
                if (typeof c.damage === "number") c.damage *= dmgMul;
              }
            }
            if (typeof speedScalar === "number" && typeof attacker.accel === "number")
              attacker.accel = attacker.accel * (1 + speedScalar);
            if (typeof regenScalar === "number" && typeof attacker.shieldRegen === "number")
              attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);
          }
        }
        state.bullets.splice(bi, 1);
        if (s.hp <= 0) {
          console.log(
            "DEBUG: KILL BRANCH, attacker",
            attacker && attacker.id,
            "xp before",
            attacker && attacker.xp
          );
          if (attacker) {
            attacker.xp = (attacker.xp || 0) + (progression.xpPerKill || 0);
            console.log(
              "DEBUG: KILL XP AWARDED, attacker",
              attacker.id,
              "xp after",
              attacker.xp
            );
            while ((attacker.xp || 0) >= progression.xpToLevel(attacker.level || 1)) {
              attacker.xp -= progression.xpToLevel(attacker.level || 1);
              attacker.level = (attacker.level || 1) + 1;
              const resolveScalar = (s2, lvl2) => typeof s2 === "function" ? s2(lvl2) : s2 || 0;
              const lvl = attacker.level || 1;
              const hpScalar = resolveScalar(
                progression.hpPercentPerLevel,
                lvl
              );
              const shScalar = resolveScalar(
                progression.shieldPercentPerLevel,
                lvl
              );
              const dmgScalar = resolveScalar(
                progression.dmgPercentPerLevel,
                lvl
              );
              const speedScalar = resolveScalar(
                progression.speedPercentPerLevel,
                lvl
              );
              const regenScalar = resolveScalar(
                progression.regenPercentPerLevel,
                lvl
              );
              const hpMul = 1 + hpScalar;
              const shMul = 1 + shScalar;
              const dmgMul = 1 + dmgScalar;
              attacker.maxHp = (attacker.maxHp || 0) * hpMul;
              attacker.hp = Math.min(
                attacker.maxHp,
                (attacker.hp || 0) * hpMul
              );
              if (typeof attacker.maxShield === "number") {
                attacker.maxShield = (attacker.maxShield || 0) * shMul;
                attacker.shield = Math.min(
                  attacker.maxShield,
                  (attacker.shield || 0) * shMul
                );
              }
              if (Array.isArray(attacker.cannons)) {
                for (const c of attacker.cannons) {
                  if (typeof c.damage === "number") c.damage *= dmgMul;
                }
              }
              if (typeof speedScalar === "number" && typeof attacker.accel === "number")
                attacker.accel = attacker.accel * (1 + speedScalar);
              if (typeof regenScalar === "number" && typeof attacker.shieldRegen === "number")
                attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);
            }
          }
          (state.explosions ||= []).push(acquireExplosion({ x: s.x, y: s.y, team: s.team, life: 0.5, ttl: 0.5 }));
          state.ships.splice(si, 1);
        }
        break;
      }
    }
  }
  for (const s of state.ships || []) {
    if (s.maxShield)
      s.shield = Math.min(
        s.maxShield,
        (s.shield || 0) + (s.shieldRegen || 0) * dtSeconds
      );
  }
  for (const s of state.ships || []) {
    s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));
    s.shieldPercent = typeof s.maxShield === "number" && s.maxShield > 0 ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield)) : 0;
  }
  return state;
}

// src/createSimWorker.ts
function createSimWorker(url = "./simWorker.js") {
  const worker = new Worker(url, { type: "module" });
  const listeners = /* @__PURE__ */ new Map();
  worker.onmessage = (ev) => {
    const msg = ev.data;
    const cb = listeners.get(msg && msg.type);
    if (cb) cb(msg);
  };
  return {
    post(msg) {
      worker.postMessage(msg);
    },
    on(type, cb) {
      listeners.set(type, cb);
    },
    terminate() {
      worker.terminate();
    }
  };
}

// src/config/gamemanagerConfig.ts
var SHIELD = {
  ttl: 0.4,
  particleCount: 6,
  particleTTL: 0.5,
  particleColor: "#88ccff",
  particleSize: 2,
  // arcWidth (radians) for shield hit visual/particle spread centered on hitAngle
  // NOTE: Used in assetsConfig.ts visualStateDefaults and renderer logic. If not consumed, consider removing.
  arcWidth: Math.PI / 6
  // TODO: Ensure renderer/particle logic uses this or remove if redundant
};
var HEALTH = {
  ttl: 0.6,
  particleCount: 8,
  particleTTL: 0.6,
  particleColor: "#ffb3b3",
  particleSize: 2.5
};
var EXPLOSION = {
  particleCount: 30,
  particleTTL: 1.2,
  particleColor: "#ffaa33",
  particleSize: 3,
  minSpeed: 20,
  maxSpeed: 140
  // TODO: Unify particle effect configs with assetsConfig.ts animations for maintainability
};
var FALLBACK_POSITIONS = [
  { x: 100, y: 100, team: "red" },
  { x: 700, y: 500, team: "blue" }
];
var STARS = { twinkle: true, redrawInterval: 500, count: 140 };

// src/gamemanager.ts
init_entitiesConfig();
var particles = [];
var flashes = [];
var shieldFlashes = [];
var healthFlashes = [];
var particlePool = [];
var bulletPool = [];
var explosionPool = [];
var shieldHitPool = [];
var healthHitPool = [];
function releaseBullet(b) {
  if (!b.alive) return;
  b.alive = false;
  bulletPool.push(b);
}
function acquireExplosion(opts = {}) {
  let e;
  if (explosionPool.length) {
    e = explosionPool.pop();
    Object.assign(e, opts);
    e.alive = true;
    e._pooled = false;
  } else {
    e = { ...opts, alive: true, _pooled: false };
  }
  flashes.push(e);
  return e;
}
function releaseExplosion(e) {
  if (e._pooled) return;
  if (!e.alive) return;
  e.alive = false;
  e._pooled = true;
  explosionPool.push(e);
}
function acquireShieldHit(opts = {}) {
  let sh = null;
  if (shieldHitPool.length) {
    sh = shieldHitPool.pop();
    Object.assign(sh, opts);
    sh.alive = true;
    sh._pooled = false;
  } else {
    sh = { ...opts, alive: true, _pooled: false };
  }
  shieldFlashes.push(sh);
  return sh;
}
function releaseShieldHit(sh) {
  if (sh._pooled) return;
  const i = shieldFlashes.indexOf(sh);
  if (i !== -1) shieldFlashes.splice(i, 1);
  sh.alive = false;
  sh._pooled = true;
  shieldHitPool.push(sh);
}
function acquireHealthHit(opts = {}) {
  let hh = null;
  if (healthHitPool.length) {
    hh = healthHitPool.pop();
    Object.assign(hh, opts);
    hh.alive = true;
    hh._pooled = false;
  } else {
    hh = { ...opts, alive: true, _pooled: false };
  }
  healthFlashes.push(hh);
  return hh;
}
function releaseHealthHit(hh) {
  if (hh._pooled) return;
  const i = healthFlashes.indexOf(hh);
  if (i !== -1) healthFlashes.splice(i, 1);
  hh.alive = false;
  hh._pooled = true;
  healthHitPool.push(hh);
}
var config = {
  shield: { ...SHIELD },
  health: { ...HEALTH },
  explosion: { ...EXPLOSION },
  stars: { ...STARS }
};
var _seed2 = null;
var _reinforcementInterval = TeamsConfig.continuousReinforcement?.interval ?? 5;
var _reinforcementAccumulator = 0;
function releaseParticle(p) {
  if (!p._pooled) {
    p._pooled = true;
    p.alive = false;
    const idx = particles.indexOf(p);
    if (idx !== -1) {
      particles.splice(idx, 1);
    }
    particlePool.push(p);
  }
}
function setReinforcementInterval(seconds) {
  _reinforcementInterval = Number(seconds) || (TeamsConfig.continuousReinforcement?.interval ?? 5);
}
function getReinforcementInterval() {
  return _reinforcementInterval;
}
function emitManagerEvent(map, type, data) {
  const arr = map.get(type) || [];
  for (const cb of arr.slice()) {
    try {
      if (typeof cb === "function") cb(data);
    } catch (e) {
    }
  }
}
function evaluateReinforcement(dt, state, continuousOptions = {}) {
  _reinforcementAccumulator += dt;
  if (_reinforcementAccumulator >= _reinforcementInterval) {
    _reinforcementAccumulator = 0;
    try {
      if (typeof chooseReinforcementsWithManagerSeed === "function") {
        const orders = chooseReinforcementsWithManagerSeed(state, {
          ...continuousOptions,
          bounds: SIM.bounds,
          enabled: true
        });
        if (Array.isArray(orders) && orders.length) {
          const spawned = [];
          for (const o of orders) {
            try {
              const ship = createShip(
                o.type || getDefaultShipType(),
                o.x || 100,
                o.y || 100,
                o.team || "red"
              );
              state.ships.push(ship);
              spawned.push(ship);
            } catch (e) {
            }
          }
          return { spawned };
        }
      }
      const fallback = getDefaultShipType();
      const r = createShip(
        fallback,
        FALLBACK_POSITIONS[0].x,
        FALLBACK_POSITIONS[0].y,
        FALLBACK_POSITIONS[0].team
      );
      const b = createShip(
        fallback,
        FALLBACK_POSITIONS[1].x,
        FALLBACK_POSITIONS[1].y,
        FALLBACK_POSITIONS[1].team
      );
      state.ships.push(r);
      state.ships.push(b);
      return { spawned: [r, b] };
    } catch (e) {
      return null;
    }
  }
  return null;
}
function createGameManager({
  useWorker = true,
  renderer = null,
  seed = 12345,
  createSimWorker: createSimWorkerFactory
} = {}) {
  let state = makeInitialState();
  let running = false;
  const listeners = /* @__PURE__ */ new Map();
  const workerReadyCbs = [];
  let simWorker = null;
  let _workerReadyHandler = null;
  let _workerSnapshotHandler = null;
  let _workerReinforcementsHandler = null;
  let workerReady = false;
  let lastReinforcement = {
    spawned: [],
    timestamp: 0,
    options: {}
  };
  let continuous = false;
  let continuousOptions = {};
  function emit(type, msg) {
    emitManagerEvent(listeners, type, msg);
  }
  function _mgr_random() {
    return srandom();
  }
  try {
    if (useWorker) {
      const factory = createSimWorkerFactory || createSimWorker;
      let simWorkerUrl;
      try {
        simWorkerUrl = typeof import.meta !== "undefined" && import.meta.url ? new URL("./simWorker.js", import.meta.url).href : "./simWorker.js";
      } catch (e) {
        simWorkerUrl = "./simWorker.js";
      }
      simWorker = factory(simWorkerUrl);
      _workerReadyHandler = () => {
        workerReady = true;
        for (const cb of workerReadyCbs.slice()) {
          try {
            cb();
          } catch (e) {
          }
        }
      };
      simWorker.on && simWorker.on("ready", _workerReadyHandler);
      _workerSnapshotHandler = (m) => {
        if (m && m.state) state = m.state;
      };
      simWorker.on && simWorker.on("snapshot", _workerSnapshotHandler);
      _workerReinforcementsHandler = (m) => {
        emit("reinforcements", m);
      };
      simWorker.on && simWorker.on("reinforcements", _workerReinforcementsHandler);
      try {
        simWorker.post({
          type: "init",
          seed,
          bounds: SIM.bounds,
          simDtMs: SIM.DT_MS,
          state
        });
        simWorker.post({ type: "start" });
      } catch (e) {
      }
    }
  } catch (e) {
    simWorker = null;
  }
  function _evaluateAndEmit(dt) {
    const result = evaluateReinforcement(dt, state, continuousOptions);
    if (result && Array.isArray(result.spawned) && result.spawned.length) {
      lastReinforcement = {
        spawned: result.spawned,
        timestamp: Date.now(),
        options: { ...continuousOptions }
      };
      emit("reinforcements", { spawned: result.spawned });
    }
  }
  function step(dtSeconds) {
    const clampedDt = Math.min(dtSeconds, 0.05);
    if (!simWorker) {
      try {
        applySimpleAI(state, clampedDt, SIM.bounds);
      } catch (e) {
      }
      try {
        simulateStep(state, clampedDt, SIM.bounds);
      } catch (e) {
      }
    } else {
      try {
        simWorker.post && simWorker.post({ type: "snapshotRequest" });
      } catch (e) {
      }
    }
    _evaluateAndEmit(clampedDt);
    if (typeof simulateStep === "function") {
      simulateStep(state, clampedDt, SIM.bounds);
    }
    if (renderer && typeof renderer.renderState === "function") {
      try {
        renderer.renderState({
          ships: state.ships,
          bullets: state.bullets,
          flashes,
          shieldFlashes,
          healthFlashes,
          t: state.t
        });
      } catch (e) {
      }
    }
  }
  let last = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
  let acc = 0;
  function runLoop() {
    if (!running) return;
    const now = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
    acc += now - last;
    last = now;
    if (acc > 250) acc = 250;
    while (acc >= SIM.DT_MS) {
      step(SIM.DT_MS / 1e3);
      acc -= SIM.DT_MS;
    }
    try {
      requestAnimationFrame(runLoop);
    } catch (e) {
      setTimeout(runLoop, SIM.DT_MS);
    }
  }
  function on(evt, cb) {
    const arr = listeners.get(evt) || [];
    arr.push(cb);
    listeners.set(evt, arr);
  }
  function off(evt, cb) {
    const arr = listeners.get(evt) || [];
    const i = arr.indexOf(cb);
    if (i !== -1) arr.splice(i, 1);
  }
  function destroy() {
    running = false;
    try {
      if (simWorker) {
        try {
          if (typeof simWorker.off === "function") {
            try {
              if (_workerReadyHandler) simWorker.off("ready", _workerReadyHandler);
            } catch (e) {
            }
            try {
              if (_workerSnapshotHandler) simWorker.off("snapshot", _workerSnapshotHandler);
            } catch (e) {
            }
            try {
              if (_workerReinforcementsHandler) simWorker.off("reinforcements", _workerReinforcementsHandler);
            } catch (e) {
            }
          }
        } catch (e) {
        }
        try {
          if (typeof simWorker.terminate === "function") simWorker.terminate();
          else if (typeof simWorker.close === "function") simWorker.close();
          else if (typeof simWorker.post === "function") simWorker.post({ type: "stop" });
        } catch (e) {
        }
        simWorker = null;
      }
    } catch (e) {
    }
    workerReady = false;
    workerReadyCbs.length = 0;
  }
  function start() {
    if (!running) {
      running = true;
      last = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
      runLoop();
    }
  }
  function pause() {
    running = false;
  }
  function resetManager() {
    state = makeInitialState();
    if (simWorker)
      try {
        simWorker.post({ type: "command", cmd: "setState", args: { state } });
      } catch (e) {
      }
  }
  function stepOnce(dt = SIM.DT_MS / 1e3) {
    const n = Number(dt) || SIM.DT_MS / 1e3;
    step(n);
  }
  function setContinuousEnabled(v = false) {
    continuous = !!v;
    if (simWorker) {
      try {
        simWorker.post({ type: "setContinuous", value: !!v });
      } catch (e) {
      }
    } else {
      if (continuous) {
        const result = evaluateReinforcement(
          SIM.DT_MS / 1e3,
          state,
          continuousOptions
        );
        if (result && Array.isArray(result.spawned) && result.spawned.length) {
          lastReinforcement = {
            spawned: result.spawned,
            timestamp: Date.now(),
            options: { ...continuousOptions }
          };
          emit("reinforcements", { spawned: result.spawned });
        }
      }
    }
  }
  function isContinuousEnabled() {
    return !!continuous;
  }
  function setContinuousOptions(opts = {}) {
    continuousOptions = { ...continuousOptions, ...opts };
    if (simWorker)
      try {
        simWorker.post({
          type: "setContinuousOptions",
          opts: continuousOptions
        });
      } catch (e) {
      }
  }
  function getContinuousOptions() {
    return { ...continuousOptions };
  }
  function setReinforcementIntervalManager(seconds) {
    setReinforcementInterval(seconds);
    if (simWorker)
      try {
        simWorker.post({ type: "setReinforcementInterval", seconds });
      } catch (e) {
      }
  }
  function getReinforcementIntervalManager() {
    return getReinforcementInterval();
  }
  function isRunning() {
    return running;
  }
  function isWorker() {
    return !!simWorker && !!workerReady;
  }
  function onWorkerReady(cb) {
    if (typeof cb === "function") workerReadyCbs.push(cb);
  }
  function offWorkerReady(cb) {
    const i = workerReadyCbs.indexOf(cb);
    if (i !== -1) workerReadyCbs.splice(i, 1);
  }
  function spawnShip(team = "red") {
    try {
      const type = getDefaultShipType();
      const b = SIM.bounds;
      const x = Math.max(0, Math.min(b.W - 1e-6, srandom() * b.W));
      const y = Math.max(0, Math.min(b.H - 1e-6, srandom() * b.H));
      const ship = createShip(type, x, y, team);
      state.ships.push(ship);
      return ship;
    } catch (e) {
      return null;
    }
  }
  function formFleets() {
    try {
      state.ships.length = 0;
      const bounds = SIM.bounds;
      const seed2 = Math.floor(srandom() * 4294967295) >>> 0;
      const ships = makeInitialFleets(seed2, bounds, createShip);
      for (const ship of ships) {
        state.ships.push(ship);
      }
    } catch (e) {
    }
  }
  function reseedManager(newSeed = Math.floor(srandom() * 4294967295)) {
    _seed2 = newSeed >>> 0;
    srand(_seed2);
    if (simWorker)
      try {
        simWorker.post({ type: "setSeed", seed: _seed2 });
      } catch (e) {
      }
  }
  function getLastReinforcement() {
    return { ...lastReinforcement };
  }
  function snapshot() {
    return {
      ships: state.ships.slice(),
      bullets: state.bullets.slice(),
      t: state.t
    };
  }
  const score = { red: 0, blue: 0 };
  const internal = { state, bounds: SIM.bounds };
  return {
    on,
    off,
    start,
    pause,
    reset: resetManager,
    stepOnce,
    setContinuousEnabled,
    isContinuousEnabled,
    setContinuousOptions,
    getContinuousOptions,
    setReinforcementInterval: setReinforcementIntervalManager,
    getReinforcementInterval: getReinforcementIntervalManager,
    isRunning,
    isWorker,
    onWorkerReady,
    offWorkerReady,
    spawnShip,
    reseed: reseedManager,
    getLastReinforcement,
    snapshot,
    score,
    formFleets,
    destroy,
    _internal: internal
  };
}

// src/config/displayConfig.ts
var DISPLAY_DEFAULTS = {
  renderScale: 1,
  displayScale: 1,
  hpBar: { bg: "#222", fill: "#4caf50", w: 20, h: 4, dx: -10, dy: -12 }
};

// src/config/rendererConfig.ts
var RendererConfig = {
  preferred: "canvas",
  allowUrlOverride: true,
  allowWebGL: true,
  renderScale: DISPLAY_DEFAULTS.renderScale,
  displayScale: DISPLAY_DEFAULTS.displayScale,
  dynamicScaleEnabled: false,
  lastFrameTime: 0,
  frameScore: "green",
  // green, yellow, red
  // UI overlays configuration
  hpBar: DISPLAY_DEFAULTS.hpBar
};
function getPreferredRenderer() {
  try {
    if (RendererConfig.allowUrlOverride && typeof window !== "undefined" && window.location && window.location.search) {
      const p = new URLSearchParams(window.location.search);
      const r = p.get("renderer");
      if (r === "canvas" || r === "webgl") return r;
    }
  } catch (e) {
  }
  return RendererConfig.preferred;
}
var rendererConfig_default = RendererConfig;

// src/config/assets/assetsConfig.ts
var AssetsConfig = {
  meta: {
    orientation: "+X",
    coordinateSystem: "topdown-2d"
  },
  palette: {
    shipHull: "#b0b7c3",
    shipAccent: "#6c7380",
    bullet: "#ffd166",
    turret: "#94a3b8",
    // Scene background color used by renderers
    background: "#0b1220"
  },
  // 2D vector shapes defined as polygons and circles. Points are unit-sized
  // profiles (roughly radius 1). Renderer should multiply by entity radius or
  // provided scale before drawing.
  shapes2d: {
    fighter: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.2, 0], [-0.8, 0.6], [-0.5, 0], [-0.8, -0.6]] },
        { type: "polygon", points: [[0, 0.35], [-0.6, 0.65], [-0.35, 0]] },
        { type: "polygon", points: [[0, -0.35], [-0.35, 0], [-0.6, -0.65]] },
        { type: "circle", r: 0.5 }
      ],
      strokeWidth: 0.08,
      model3d: { url: void 0, scale: 1, type: "gltf", mesh: void 0 }
    },
    corvette: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.2, 0], [0.4, 0.7], [-1, 0.6], [-1.2, 0], [-1, -0.6], [0.4, -0.7]] },
        { type: "polygon", points: [[1.4, 0.22], [1.2, 0.12], [1.2, -0.12], [1.4, -0.22]] },
        { type: "circle", r: 0.6 }
      ],
      strokeWidth: 0.08,
      model3d: { url: void 0, scale: 1.4, type: "gltf", mesh: void 0 }
    },
    frigate: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.3, 0], [0.7, 0.65], [-0.3, 1], [-1.3, 0.55], [-1.3, -0.55], [-0.3, -1], [0.7, -0.65]] },
        { type: "circle", r: 0.7 }
      ],
      strokeWidth: 0.1,
      model3d: { url: void 0, scale: 1.8, type: "gltf", mesh: void 0 }
    },
    destroyer: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[1.8, 0], [1, 0.7], [0.2, 1], [-0.8, 0.9], [-1.8, 0.6], [-1.8, -0.6], [-0.8, -0.9], [0.2, -1], [1, -0.7]] },
        { type: "circle", r: 1 },
        { type: "polygon", points: [[2, 0.3], [1.8, 0.2], [1.8, -0.2], [2, -0.3]] }
      ],
      strokeWidth: 0.12,
      model3d: { url: void 0, scale: 2.2, type: "gltf", mesh: void 0 },
      turrets: [
        { kind: "basic", position: [1.2, 0.8] },
        { kind: "basic", position: [-1.2, 0.8] },
        { kind: "basic", position: [1.2, -0.8] },
        { kind: "basic", position: [-1.2, -0.8] },
        { kind: "basic", position: [0, 1.5] },
        { kind: "basic", position: [0, -1.5] }
      ]
    },
    carrier: {
      type: "compound",
      parts: [
        { type: "polygon", points: [[2.2, 0], [1.2, 1.2], [-1, 1.6], [-2.8, 1.2], [-3.2, 0], [-2.8, -1.2], [-1, -1.6], [1.2, -1.2]] },
        { type: "circle", r: 1.2 },
        { type: "polygon", points: [[2.6, 0.5], [2.2, 0.3], [2.2, -0.3], [2.6, -0.5]] }
      ],
      strokeWidth: 0.12,
      model3d: { url: void 0, scale: 3, type: "gltf", mesh: void 0 },
      turrets: [
        { kind: "basic", position: [2, 1.2] },
        { kind: "basic", position: [-2, 1.2] },
        { kind: "basic", position: [2, -1.2] },
        { kind: "basic", position: [-2, -1.2] }
      ]
    },
    bulletSmall: { type: "circle", r: 0.18 },
    bulletMedium: { type: "circle", r: 0.25 },
    bulletLarge: { type: "circle", r: 0.36 },
    turretBasic: {
      type: "compound",
      parts: [
        { type: "circle", r: 0.5 },
        { type: "polygon", points: [[-0.2, 0.2], [0.7, 0.2], [0.7, -0.2], [-0.2, -0.2]] }
      ],
      strokeWidth: 0.08
    },
    // Small effect/particle shapes for renderer-driven effects
    particleSmall: { type: "circle", r: 0.12 },
    particleMedium: { type: "circle", r: 0.22 },
    explosionParticle: { type: "circle", r: 0.32 },
    shieldRing: { type: "circle", r: 1.2 }
  }
};
AssetsConfig.animations = {
  engineFlare: {
    type: "polygon",
    points: [[0, 0], [-0.3, 0.15], [-0.5, 0], [-0.3, -0.15]],
    pulseRate: 8,
    // configurable alpha multiplier for engine overlay
    alpha: 0.4,
    // local-space X offset (negative = behind ship)
    offset: -0.9
  },
  shieldEffect: {
    type: "circle",
    r: 1.2,
    strokeWidth: 0.1,
    color: "#88ccff",
    pulseRate: 2,
    // map shieldPct -> alpha = base + scale * shieldPct
    alphaBase: 0.25,
    alphaScale: 0.75
  },
  damageParticles: {
    type: "particles",
    color: "#ff6b6b",
    count: 6,
    lifetime: 0.8,
    spread: 0.6
  },
  engineTrail: {
    type: "trail",
    color: "#fffc00",
    // bright yellow for high contrast
    maxLength: 40,
    // much longer trail
    width: 0.35,
    // thicker trail line
    fade: 0.35
    // slower fading, more persistent
  }
};
AssetsConfig.damageStates = {
  light: { opacity: 0.9, accentColor: "#b0b7c3" },
  moderate: { opacity: 0.75, accentColor: "#d4a06a" },
  heavy: { opacity: 0.5, accentColor: "#ff6b6b" }
};
AssetsConfig.visualStateDefaults = {
  fighter: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles", engineTrail: "engineTrail", arcWidth: Math.PI / 12 },
  corvette: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles", engineTrail: "engineTrail", arcWidth: Math.PI / 12 },
  frigate: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles", engineTrail: "engineTrail", arcWidth: Math.PI / 12 },
  destroyer: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles", engineTrail: "engineTrail", arcWidth: Math.PI / 12 },
  carrier: { engine: "engineFlare", shield: "shieldEffect", damageParticles: "damageParticles", engineTrail: "engineTrail", arcWidth: Math.PI / 12 }
};
AssetsConfig.damageThresholds = { moderate: 0.66, heavy: 0.33 };
AssetsConfig.shieldArcWidth = Math.PI / 12;
function getVisualConfig(type) {
  const shape = getShipAsset(type);
  const visuals = AssetsConfig.visualStateDefaults[type] || AssetsConfig.visualStateDefaults.fighter;
  return { shape, visuals, palette: AssetsConfig.palette, animations: AssetsConfig.animations, damageStates: AssetsConfig.damageStates };
}
function getShipAsset(type) {
  return AssetsConfig.shapes2d[type] || AssetsConfig.shapes2d.fighter;
}
function getBulletAsset(kind = "small") {
  if (kind === "large") return AssetsConfig.shapes2d.bulletLarge;
  if (kind === "medium") return AssetsConfig.shapes2d.bulletMedium;
  return AssetsConfig.shapes2d.bulletSmall;
}
function getTurretAsset(_kind = "basic") {
  return AssetsConfig.shapes2d.turretBasic;
}
var assetsConfig_default = AssetsConfig;

// src/canvasrenderer.ts
init_entitiesConfig();
var CanvasRenderer = class {
  canvas;
  ctx = null;
  bufferCanvas;
  bufferCtx = null;
  providesOwnLoop = false;
  type = "canvas";
  // ratio between backing store pixels and CSS (logical) pixels
  pixelRatio = 1;
  constructor(canvas) {
    this.canvas = canvas;
    this.bufferCanvas = document.createElement("canvas");
    this.bufferCtx = this.bufferCanvas.getContext("2d");
  }
  init() {
    this.ctx = this.canvas.getContext("2d");
    if (!this.ctx) {
      const noop = () => {
      };
      const noOpCtx = {
        setTransform: noop,
        imageSmoothingEnabled: true,
        clearRect: noop,
        save: noop,
        restore: noop,
        fillRect: noop,
        beginPath: noop,
        moveTo: noop,
        lineTo: noop,
        closePath: noop,
        fill: noop,
        stroke: noop,
        arc: noop,
        translate: noop,
        rotate: noop,
        drawImage: noop,
        globalAlpha: 1,
        strokeStyle: "#000",
        fillStyle: "#000",
        lineWidth: 1,
        globalCompositeOperation: "source-over"
      };
      this.ctx = noOpCtx;
    }
    this.bufferCtx = this.bufferCanvas.getContext("2d") || this.ctx;
    if (!this.bufferCtx) return false;
    try {
      const renderScale = rendererConfig_default && typeof rendererConfig_default.renderScale === "number" ? rendererConfig_default.renderScale : 1;
      this.pixelRatio = renderScale;
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.imageSmoothingEnabled = true;
    } catch (e) {
      this.pixelRatio = 1;
    }
    return true;
  }
  isRunning() {
    return false;
  }
  renderState(state, interpolation = 0) {
    function drawRing(x, y, R, color, alpha = 1, thickness = 2) {
      try {
        bufferCtx.save();
        bufferCtx.globalAlpha = Math.max(0, Math.min(1, alpha));
        bufferCtx.strokeStyle = color;
        bufferCtx.lineWidth = thickness * renderScale;
        bufferCtx.beginPath();
        bufferCtx.arc(x * renderScale, y * renderScale, Math.max(1, R * renderScale), 0, Math.PI * 2);
        bufferCtx.stroke();
        bufferCtx.restore();
      } catch (e) {
      }
    }
    const ctx = this.ctx;
    const bufferCtx = this.bufferCtx;
    if (!ctx || !bufferCtx) return;
    const LOGICAL_W = 1920, LOGICAL_H = 1080;
    const renderScale = rendererConfig_default && typeof rendererConfig_default.renderScale === "number" ? rendererConfig_default.renderScale : 1;
    const fitScale = rendererConfig_default._fitScale || 1;
    const bufferW = Math.round(LOGICAL_W * renderScale);
    const bufferH = Math.round(LOGICAL_H * renderScale);
    if (this.bufferCanvas.width !== bufferW || this.bufferCanvas.height !== bufferH) {
      this.bufferCanvas.width = bufferW;
      this.bufferCanvas.height = bufferH;
      this.bufferCtx = this.bufferCanvas.getContext("2d");
      if (!this.bufferCtx) return;
    }
    const activeBufferCtx = this.bufferCtx;
    activeBufferCtx.setTransform(1, 0, 0, 1, 0, 0);
    activeBufferCtx.clearRect(0, 0, bufferW, bufferH);
    activeBufferCtx.save();
    activeBufferCtx.fillStyle = assetsConfig_default.palette.background || "#0b1220";
    activeBufferCtx.fillRect(0, 0, bufferW, bufferH);
    activeBufferCtx.restore();
    function drawPolygon(points) {
      if (!points || points.length === 0) return;
      activeBufferCtx.beginPath();
      activeBufferCtx.moveTo(points[0][0] * renderScale, points[0][1] * renderScale);
      for (let i = 1; i < points.length; i++) activeBufferCtx.lineTo(points[i][0] * renderScale, points[i][1] * renderScale);
      activeBufferCtx.closePath();
      activeBufferCtx.fill();
    }
    if (state && state.starCanvas) {
      try {
        activeBufferCtx.save();
        activeBufferCtx.globalCompositeOperation = "source-over";
        activeBufferCtx.drawImage(state.starCanvas, 0, 0, bufferW, bufferH);
        activeBufferCtx.restore();
      } catch (e) {
      }
    }
    const now = state && state.t || 0;
    try {
      const dmgAnim = assetsConfig_default.animations && assetsConfig_default.animations.damageParticles;
      if (Array.isArray(state.damageEvents) && dmgAnim) {
        state.particles = state.particles || [];
        for (const ev of state.damageEvents) {
          const count = dmgAnim.count || 6;
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (dmgAnim.spread || 0.6);
            state.particles.push({
              x: ev.x || 0,
              y: ev.y || 0,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              r: 0.6 + Math.random() * 0.8,
              color: dmgAnim.color || "#ff6b6b",
              lifetime: dmgAnim.lifetime || 0.8,
              age: 0,
              shape: "circle"
            });
          }
        }
        state.damageEvents = [];
      }
    } catch (e) {
    }
    for (const s of state.ships || []) {
      const sx = (s.x || 0) * renderScale;
      const sy = (s.y || 0) * renderScale;
      if (sx < 0 || sx >= bufferW || sy < 0 || sy >= bufferH) continue;
      if (state.engineTrailsEnabled) {
        s.trail = s.trail || [];
        const last = s.trail.length ? s.trail[s.trail.length - 1] : null;
        if (!last || last.x !== s.x || last.y !== s.y) {
          s.trail.push({ x: s.x, y: s.y });
        }
        const vconf2 = getVisualConfig(s.type || getDefaultShipType());
        const trailName = vconf2.visuals && vconf2.visuals.engineTrail || "engineTrail";
      }
      if (Array.isArray(s.trail)) {
        for (let i = 0; i < s.trail.length; i++) {
          const tx = s.trail[i].x || 0;
          const ty = s.trail[i].y || 0;
          const tAlpha = 0.2 + 0.5 * (i / s.trail.length);
          const txx = tx * renderScale;
          const tyy = ty * renderScale;
          if (txx < 0 || txx >= bufferW || tyy < 0 || tyy >= bufferH) continue;
          activeBufferCtx.save();
          activeBufferCtx.globalAlpha = tAlpha;
          activeBufferCtx.fillStyle = "#aee1ff";
          activeBufferCtx.beginPath();
          activeBufferCtx.arc(txx, tyy, 6 * renderScale, 0, Math.PI * 2);
          activeBufferCtx.fill();
          activeBufferCtx.restore();
        }
      }
      const vconf = getVisualConfig(s.type || getDefaultShipType());
      const shape = getShipAsset(s.type || getDefaultShipType());
      activeBufferCtx.save();
      activeBufferCtx.translate((s.x || 0) * renderScale, (s.y || 0) * renderScale);
      activeBufferCtx.rotate(s.angle || 0);
      let teamColor = assetsConfig_default.palette.shipHull || "#888";
      if (s.team === "red" && teamsConfig_default.teams.red) teamColor = teamsConfig_default.teams.red.color;
      else if (s.team === "blue" && teamsConfig_default.teams.blue) teamColor = teamsConfig_default.teams.blue.color;
      activeBufferCtx.fillStyle = teamColor;
      if (shape.type === "circle") {
        activeBufferCtx.beginPath();
        activeBufferCtx.arc(0, 0, (s.radius || 12) * renderScale, 0, Math.PI * 2);
        activeBufferCtx.fill();
      } else if (shape.type === "polygon") {
        drawPolygon(shape.points);
      } else if (shape.type === "compound") {
        for (const part of shape.parts) {
          if (part.type === "circle") {
            activeBufferCtx.beginPath();
            activeBufferCtx.arc(0, 0, (part.r || 1) * (s.radius || 12) * renderScale, 0, Math.PI * 2);
            activeBufferCtx.fill();
          } else if (part.type === "polygon") {
            drawPolygon(part.points);
          }
        }
      }
      if (Array.isArray(s.turrets) && s.turrets.length > 0) {
        for (const turret of s.turrets) {
          if (!turret || !turret.position) continue;
          const turretShape = getTurretAsset(turret.kind || "basic");
          const shipType = s.type || "fighter";
          const shipCfg = (init_entitiesConfig(), __toCommonJS(entitiesConfig_exports)).getShipConfig()[shipType];
          const configRadius = shipCfg && typeof shipCfg.radius === "number" ? shipCfg.radius : s.radius || 12;
          const turretScale = configRadius * renderScale * 0.5;
          const angle = s.angle || 0;
          const [tx, ty] = turret.position;
          const turretX = Math.cos(angle) * tx * configRadius - Math.sin(angle) * ty * configRadius;
          const turretY = Math.sin(angle) * tx * configRadius + Math.cos(angle) * ty * configRadius;
          activeBufferCtx.save();
          activeBufferCtx.translate(turretX, turretY);
          activeBufferCtx.rotate(0);
          activeBufferCtx.fillStyle = assetsConfig_default.palette.turret || "#94a3b8";
          if (turretShape.type === "circle") {
            activeBufferCtx.beginPath();
            activeBufferCtx.arc(0, 0, (turretShape.r || 1) * turretScale, 0, Math.PI * 2);
            activeBufferCtx.fill();
          } else if (turretShape.type === "polygon") {
            activeBufferCtx.save();
            activeBufferCtx.scale(turretScale, turretScale);
            drawPolygon(turretShape.points);
            activeBufferCtx.restore();
          } else if (turretShape.type === "compound") {
            for (const part of turretShape.parts) {
              if (part.type === "circle") {
                activeBufferCtx.beginPath();
                activeBufferCtx.arc(0, 0, (part.r || 1) * turretScale, 0, Math.PI * 2);
                activeBufferCtx.fill();
              } else if (part.type === "polygon") {
                activeBufferCtx.save();
                activeBufferCtx.scale(turretScale, turretScale);
                drawPolygon(part.points);
                activeBufferCtx.restore();
              }
            }
          }
          activeBufferCtx.restore();
        }
      }
      if ((s.shield ?? 0) > 0) {
        if (sx >= 0 && sx < bufferW && sy >= 0 && sy < bufferH) {
          const shAnim = assetsConfig_default.animations && assetsConfig_default.animations.shieldEffect;
          try {
            if (shAnim) {
              const pulse = typeof shAnim.pulseRate === "number" ? 0.5 + 0.5 * Math.sin(now * shAnim.pulseRate) : 1;
              const shieldNorm = Math.max(0, Math.min(1, (s.shield || 0) / (s.maxShield || s.shield || 1)));
              const alphaBase = typeof shAnim.alphaBase === "number" ? shAnim.alphaBase : shAnim.alpha || 0.25;
              const alphaScale = typeof shAnim.alphaScale === "number" ? shAnim.alphaScale : 0.75;
              const alpha = Math.max(0, Math.min(1, alphaBase + alphaScale * pulse * shieldNorm));
              const R = (shAnim.r || 1.2) * (s.radius || 12);
              activeBufferCtx.save();
              activeBufferCtx.globalAlpha = alpha;
              activeBufferCtx.strokeStyle = shAnim.color || "#3ab6ff";
              activeBufferCtx.lineWidth = (shAnim.strokeWidth || 0.08) * (s.radius || 12) * renderScale;
              activeBufferCtx.beginPath();
              activeBufferCtx.arc((s.x || 0) * renderScale, (s.y || 0) * renderScale, Math.max(1, R * renderScale), 0, Math.PI * 2);
              activeBufferCtx.stroke();
              activeBufferCtx.restore();
            } else {
              drawRing(s.x, s.y, (s.radius || 12) * 1.2, "#3ab6ff", 0.5, 3 * renderScale);
            }
          } catch (e) {
          }
        }
      }
    }
    try {
      const nowT = state.t || 0;
      for (const s of state.ships || []) {
        try {
          let flash = null;
          const arr = Array.isArray(state.healthFlashes) ? state.healthFlashes.filter((f) => f.id === s.id) : [];
          let bestTs = -Infinity;
          for (const f of arr) {
            if (!f) continue;
            const fTs = typeof f._ts === "number" ? f._ts : 0;
            const fTtl = typeof f.ttl === "number" ? f.ttl : 0.4;
            if (fTs + fTtl >= nowT - 1e-6 && fTs > bestTs) {
              bestTs = fTs;
              flash = f;
            }
          }
          if (flash) {
            const ttl = flash.ttl || 0.4;
            const life = flash.life != null ? flash.life : ttl;
            const t = Math.max(0, Math.min(1, life / ttl));
            const R = 6 + (1 - t) * 18;
            const alpha = 0.9 * t;
            const fx = (flash.x || (s.x || 0)) * renderScale;
            const fy = (flash.y || (s.y || 0)) * renderScale;
            if (fx >= 0 && fx < bufferW && fy >= 0 && fy < bufferH) {
              activeBufferCtx.save();
              activeBufferCtx.globalAlpha = Math.max(0, Math.min(1, alpha));
              activeBufferCtx.strokeStyle = "#ff7766";
              activeBufferCtx.lineWidth = 2 * renderScale;
              activeBufferCtx.beginPath();
              activeBufferCtx.arc(fx, fy, Math.max(1, R * renderScale), 0, Math.PI * 2);
              activeBufferCtx.stroke();
              activeBufferCtx.restore();
            }
          }
        } catch (e) {
        }
      }
    } catch (e) {
    }
    for (const b of state.bullets || []) {
      try {
        const bx = (b.x || 0) * renderScale;
        const by = (b.y || 0) * renderScale;
        if (bx < 0 || bx >= bufferW || by < 0 || by >= bufferH) continue;
        const r = b.radius || b.bulletRadius || 1.5;
        const kind = typeof b.bulletRadius === "number" ? b.bulletRadius < 2 ? "small" : b.bulletRadius < 3 ? "medium" : "large" : "small";
        const shape = getBulletAsset(kind);
        activeBufferCtx.save();
        activeBufferCtx.translate(bx, by);
        const px = Math.max(1, r * renderScale);
        activeBufferCtx.fillStyle = assetsConfig_default.palette.bullet;
        if (shape.type === "circle") {
          activeBufferCtx.beginPath();
          activeBufferCtx.arc(0, 0, px, 0, Math.PI * 2);
          activeBufferCtx.fill();
        } else if (shape.type === "polygon") {
          drawPolygon(shape.points);
        } else if (shape.type === "compound") {
          for (const part of shape.parts) {
            if (part.type === "circle") {
              activeBufferCtx.beginPath();
              activeBufferCtx.arc(0, 0, (part.r || 1) * px, 0, Math.PI * 2);
              activeBufferCtx.fill();
            } else if (part.type === "polygon") {
              drawPolygon(part.points);
            }
          }
        }
        activeBufferCtx.restore();
      } catch (e) {
      }
    }
    try {
      const shapes = assetsConfig_default.shapes2d || {};
      for (const p of state.particles || []) {
        try {
          const px = (p.x || 0) * renderScale;
          const py = (p.y || 0) * renderScale;
          if (px < 0 || px >= bufferW || py < 0 || py >= bufferH) continue;
          activeBufferCtx.save();
          const shapeName = p.assetShape || (p.r > 0.5 ? "particleMedium" : "particleSmall");
          const shape = shapes[shapeName];
          const color = p.color || "#ffdca8";
          activeBufferCtx.fillStyle = color;
          activeBufferCtx.globalAlpha = Math.max(0, Math.min(1, 1 - (p.age || 0) / (p.lifetime || 1)));
          activeBufferCtx.translate(px, py);
          if (shape) {
            if (shape.type === "circle") {
              const rr = (shape.r || 0.12) * (p.r || 1) * renderScale * 6;
              activeBufferCtx.beginPath();
              activeBufferCtx.arc(0, 0, rr, 0, Math.PI * 2);
              activeBufferCtx.fill();
            } else if (shape.type === "polygon") {
              activeBufferCtx.beginPath();
              const pts = shape.points || [];
              if (pts.length) {
                activeBufferCtx.moveTo((pts[0][0] || 0) * renderScale, (pts[0][1] || 0) * renderScale);
                for (let i = 1; i < pts.length; i++) activeBufferCtx.lineTo((pts[i][0] || 0) * renderScale, (pts[i][1] || 0) * renderScale);
                activeBufferCtx.closePath();
                activeBufferCtx.fill();
              }
            } else if (shape.type === "compound") {
              for (const part of shape.parts || []) {
                if (part.type === "circle") {
                  const rr = (part.r || 0.12) * (p.r || 1) * renderScale * 6;
                  activeBufferCtx.beginPath();
                  activeBufferCtx.arc(0, 0, rr, 0, Math.PI * 2);
                  activeBufferCtx.fill();
                } else if (part.type === "polygon") {
                  activeBufferCtx.beginPath();
                  const pts = part.points || [];
                  if (pts.length) {
                    activeBufferCtx.moveTo((pts[0][0] || 0) * renderScale, (pts[0][1] || 0) * renderScale);
                    for (let i = 1; i < pts.length; i++) activeBufferCtx.lineTo((pts[i][0] || 0) * renderScale, (pts[i][1] || 0) * renderScale);
                    activeBufferCtx.closePath();
                    activeBufferCtx.fill();
                  }
                }
              }
            } else {
              activeBufferCtx.beginPath();
              activeBufferCtx.arc(0, 0, (p.r || 2) * renderScale, 0, Math.PI * 2);
              activeBufferCtx.fill();
            }
          } else {
            activeBufferCtx.beginPath();
            activeBufferCtx.arc(0, 0, (p.r || 2) * renderScale, 0, Math.PI * 2);
            activeBufferCtx.fill();
          }
          activeBufferCtx.restore();
        } catch (e) {
        }
      }
    } catch (e) {
    }
    try {
      const expShape = assetsConfig_default.shapes2d && assetsConfig_default.shapes2d.explosionParticle;
      for (const ex of state.explosions || []) {
        try {
          const exx = (ex.x || 0) * renderScale;
          const exy = (ex.y || 0) * renderScale;
          const life = ex.life || 0.5;
          const ttl = ex.ttl || 0.5;
          const t = Math.max(0, Math.min(1, life / ttl));
          const alpha = (1 - t) * 0.9;
          activeBufferCtx.save();
          activeBufferCtx.globalAlpha = alpha;
          activeBufferCtx.translate(exx, exy);
          activeBufferCtx.fillStyle = ex.color || "#ffd089";
          if (expShape && expShape.type === "circle") {
            const rr = (expShape.r || 0.32) * (ex.scale || 1) * renderScale * 6;
            activeBufferCtx.beginPath();
            activeBufferCtx.arc(0, 0, rr * (1 + (1 - t)), 0, Math.PI * 2);
            activeBufferCtx.fill();
          } else {
            activeBufferCtx.beginPath();
            activeBufferCtx.arc(0, 0, Math.max(2, (ex.scale || 1) * 12 * (1 - t)), 0, Math.PI * 2);
            activeBufferCtx.fill();
          }
          activeBufferCtx.restore();
        } catch (e) {
        }
      }
    } catch (e) {
    }
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(
      this.bufferCanvas,
      0,
      0,
      this.bufferCanvas.width,
      this.bufferCanvas.height,
      0,
      0,
      this.canvas.width,
      this.canvas.height
    );
    ctx.restore();
  }
};

// src/webglrenderer.ts
init_entitiesConfig();
var WebGLRenderer = class {
  // Fullscreen quad shader for blitting FBO to main canvas
  quadProg = null;
  quadVBO = null;
  quadLoc_pos = -1;
  quadLoc_tex = null;
  // Offscreen framebuffer and texture for buffer rendering
  fbo = null;
  fboTexture = null;
  _fboWidth = 0;
  _fboHeight = 0;
  // Public accessors for tests/consumers (read-only)
  get fboWidth() {
    return this._fboWidth;
  }
  get fboHeight() {
    return this._fboHeight;
  }
  canvas;
  gl = null;
  // simple GL program state for point rendering
  prog = null;
  attribLoc_pos = -1;
  attribLoc_size = -1;
  attribLoc_color = -1;
  vertexBuffer = null;
  providesOwnLoop = false;
  type = "webgl";
  pixelRatio = 1;
  // textured quad shader for rendering baked asset textures
  texProg = null;
  texVBO = null;
  texAttrib_pos = -1;
  texAttrib_uv = -1;
  texLoc_tex = null;
  // map of shape keys to GL textures
  shapeTextures = {};
  shapeCanvasSize = 64;
  // Public helpers to inspect the baked texture cache in tests or callers
  hasCachedTexture(key) {
    return !!this.shapeTextures[key];
  }
  getCachedTexture(key) {
    return this.shapeTextures[key] || null;
  }
  constructor(canvas) {
    this.canvas = canvas;
  }
  init() {
    try {
      const gl = this.gl;
      const vsQuad = `attribute vec2 a_pos; varying vec2 v_tex; void main(){ v_tex = (a_pos+1.0)*0.5; gl_Position = vec4(a_pos,0,1); }`;
      const fsQuad = `precision mediump float; varying vec2 v_tex; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, v_tex); }`;
      const compile = (src, type) => {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(s);
          gl.deleteShader(s);
          throw new Error("Shader compile error: " + info);
        }
        return s;
      };
      const vsObj = compile(vsQuad, gl.VERTEX_SHADER);
      const fsObj = compile(fsQuad, gl.FRAGMENT_SHADER);
      const prog = gl.createProgram();
      gl.attachShader(prog, vsObj);
      gl.attachShader(prog, fsObj);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error("Program link error: " + gl.getProgramInfoLog(prog));
      }
      this.quadProg = prog;
      this.quadLoc_pos = gl.getAttribLocation(prog, "a_pos");
      this.quadLoc_tex = gl.getUniformLocation(prog, "u_tex");
      this.quadVBO = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVBO);
      const quadVerts = new Float32Array([
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    } catch (e) {
      this.quadProg = null;
    }
    try {
      const gl = this.gl;
      const vs = `attribute vec2 a_pos; attribute vec2 a_uv; varying vec2 v_uv; void main(){ v_uv = a_uv; gl_Position = vec4(a_pos, 0.0, 1.0); }`;
      const fs = `precision mediump float; varying vec2 v_uv; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, v_uv); }`;
      const compile = (src, type) => {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(s);
          gl.deleteShader(s);
          throw new Error("Shader compile error: " + info);
        }
        return s;
      };
      const vsObj = compile(vs, gl.VERTEX_SHADER);
      const fsObj = compile(fs, gl.FRAGMENT_SHADER);
      const prog = gl.createProgram();
      gl.attachShader(prog, vsObj);
      gl.attachShader(prog, fsObj);
      gl.linkProgram(prog);
      if (gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        this.texProg = prog;
        this.texAttrib_pos = gl.getAttribLocation(prog, "a_pos");
        this.texAttrib_uv = gl.getAttribLocation(prog, "a_uv");
        this.texLoc_tex = gl.getUniformLocation(prog, "u_tex");
        this.texVBO = gl.createBuffer();
      } else {
        this.texProg = null;
      }
    } catch (e) {
      this.texProg = null;
    }
    try {
      this.gl = this.canvas.getContext("webgl2");
      if (!this.gl) {
        this.gl = this.canvas.getContext("webgl") || this.canvas.getContext("experimental-webgl");
        if (!this.gl) return false;
      }
      const gl = this.gl;
      const LOGICAL_W = 1920, LOGICAL_H = 1080;
      const renderScale = RendererConfig && typeof RendererConfig.renderScale === "number" ? RendererConfig.renderScale : 1;
      const bufferW = Math.round(LOGICAL_W * renderScale);
      const bufferH = Math.round(LOGICAL_H * renderScale);
      this.fboTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.fboTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, bufferW, bufferH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.fboTexture, 0);
      this._fboWidth = bufferW;
      this._fboHeight = bufferH;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      try {
        const bg = (AssetsConfig.palette.background || "#0b1220").replace("#", "");
        const bigint = parseInt(bg.length === 3 ? bg.split("").map((c) => c + c).join("") : bg, 16);
        const r = (bigint >> 16 & 255) / 255;
        const g = (bigint >> 8 & 255) / 255;
        const b = (bigint & 255) / 255;
        gl.clearColor(r, g, b, 1);
      } catch {
        gl.clearColor(0.02, 0.03, 0.06, 1);
      }
      try {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } catch (e) {
      }
      try {
        const cssW = this.canvas.clientWidth || this.canvas.width || 1;
        this.pixelRatio = (this.canvas.width || cssW) / cssW;
      } catch (e) {
        this.pixelRatio = 1;
      }
      try {
        const vs = `attribute vec2 a_pos; attribute float a_size; attribute vec4 a_color; varying vec4 v_color; void main(){ v_color=a_color; gl_Position = vec4(a_pos, 0.0, 1.0); gl_PointSize = a_size; }`;
        const fs = `precision mediump float; varying vec4 v_color; void main(){ vec2 c = gl_PointCoord - vec2(0.5); if(length(c) > 0.5) discard; gl_FragColor = v_color; }`;
        const compile = (src, type) => {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(s);
            gl.deleteShader(s);
            throw new Error("Shader compile error: " + info);
          }
          return s;
        };
        const vsObj = compile(vs, gl.VERTEX_SHADER);
        const fsObj = compile(fs, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vsObj);
        gl.attachShader(prog, fsObj);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw new Error("Program link error: " + gl.getProgramInfoLog(prog));
        }
        this.prog = prog;
        this.attribLoc_pos = gl.getAttribLocation(prog, "a_pos");
        this.attribLoc_size = gl.getAttribLocation(prog, "a_size");
        this.attribLoc_color = gl.getAttribLocation(prog, "a_color");
        this.vertexBuffer = gl.createBuffer();
      } catch (e) {
        this.prog = null;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  // Called when backing-store size (canvas.width/height) changes so
  // the renderer can update internal scaling/viewport without a full re-init.
  updateScale() {
    if (!this.gl) return;
    try {
      const cssW = this.canvas.clientWidth || Math.round((this.canvas.width || 1) / (this.pixelRatio || 1));
      this.pixelRatio = (this.canvas.width || cssW) / Math.max(1, cssW);
    } catch (e) {
    }
  }
  isRunning() {
    return false;
  }
  renderState(state, interpolation = 0) {
    if (!this.gl) return;
    const gl = this.gl;
    const LOGICAL_W = 1920, LOGICAL_H = 1080;
    const renderScale = RendererConfig && typeof RendererConfig.renderScale === "number" ? RendererConfig.renderScale : 1;
    const bufferW = Math.round(LOGICAL_W * renderScale);
    const bufferH = Math.round(LOGICAL_H * renderScale);
    if (this.fboWidth !== bufferW || this.fboHeight !== bufferH) {
      if (this.fboTexture) gl.deleteTexture(this.fboTexture);
      if (this.fbo) gl.deleteFramebuffer(this.fbo);
      this.fboTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.fboTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, bufferW, bufferH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.fboTexture, 0);
      this._fboWidth = bufferW;
      this._fboHeight = bufferH;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    if (this.fbo && this.fboTexture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.viewport(0, 0, bufferW, bufferH);
      gl.clear(gl.COLOR_BUFFER_BIT);
      if (this.prog && this.vertexBuffer) {
        try {
          const w = bufferW;
          const h = bufferH;
          const ships = state.ships || [];
          const verts = [];
          const now = state && state.t || 0;
          for (const s of ships) {
            const x = s.x || 0;
            const y = s.y || 0;
            const clipX = x / Math.max(1, LOGICAL_W) * 2 - 1;
            const clipY = 1 - y / Math.max(1, LOGICAL_H) * 2;
            const radius = s.radius || 6;
            const ps = Math.max(2, radius * 2);
            const teamObj = s.team === "blue" ? TeamsConfig.teams.blue : TeamsConfig.teams.red;
            const colorHex = teamObj && teamObj.color || AssetsConfig.palette.shipHull || "#888";
            const hexToRgba = (hex) => {
              const h2 = hex.replace("#", "");
              const bigint = parseInt(h2.length === 3 ? h2.split("").map((c) => c + c).join("") : h2, 16);
              const r = (bigint >> 16 & 255) / 255;
              const g = (bigint >> 8 & 255) / 255;
              const b = (bigint & 255) / 255;
              return [r, g, b, 1];
            };
            const baseColor = hexToRgba(colorHex);
            try {
              const shipAssetKey = s.type || getDefaultShipType();
              const shipTex = this.bakeShapeToTexture(shipAssetKey);
              if (shipTex && this.texProg) {
                const quadW = radius * 2 / Math.max(1, w) * 2;
                const quadH = radius * 2 / Math.max(1, h) * 2;
                this.drawTexturedQuad(shipTex, clipX, clipY, quadW, quadH);
                continue;
              }
            } catch (e) {
            }
            verts.push(clipX, clipY, ps, baseColor[0], baseColor[1], baseColor[2], baseColor[3]);
            if (Array.isArray(s.trail)) {
              for (let i = 0; i < s.trail.length; i++) {
                const tx = s.trail[i].x || 0;
                const ty = s.trail[i].y || 0;
                const tClipX = tx / Math.max(1, LOGICAL_W) * 2 - 1;
                const tClipY = 1 - ty / Math.max(1, LOGICAL_H) * 2;
                const tAlpha = 0.2 + 0.5 * (i / s.trail.length);
                verts.push(tClipX, tClipY, Math.max(2, radius), 0.7, 0.7, 1, tAlpha);
              }
            }
            if (s.shield > 0) {
              try {
                const shKey = "shieldRing";
                const shTex = this.bakeShapeToTexture(shKey);
                if (shTex && this.texProg) {
                  const quadW = radius * 2.4 / Math.max(1, w) * 2;
                  const quadH = radius * 2.4 / Math.max(1, h) * 2;
                  this.drawTexturedQuad(shTex, clipX, clipY, quadW, quadH);
                } else {
                  verts.push(clipX, clipY, ps * 1.2, 0.3, 0.7, 1, 0.5);
                }
              } catch (e) {
                verts.push(clipX, clipY, ps * 1.2, 0.3, 0.7, 1, 0.5);
              }
            }
            if (Array.isArray(healthFlashes)) {
              const flash = healthFlashes.find((f) => f.id === s.id);
              if (flash && flash.ttl > 0) {
                verts.push(clipX, clipY, ps * 1.3, 1, 0.3, 0.3, 0.7);
              }
            }
          }
          const floatArr = new Float32Array(verts);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, floatArr, gl.DYNAMIC_DRAW);
          gl.useProgram(this.prog);
          const stride = 7 * 4;
          gl.enableVertexAttribArray(this.attribLoc_pos);
          gl.vertexAttribPointer(this.attribLoc_pos, 2, gl.FLOAT, false, stride, 0);
          gl.enableVertexAttribArray(this.attribLoc_size);
          gl.vertexAttribPointer(this.attribLoc_size, 1, gl.FLOAT, false, stride, 2 * 4);
          gl.enableVertexAttribArray(this.attribLoc_color);
          gl.vertexAttribPointer(this.attribLoc_color, 4, gl.FLOAT, false, stride, 3 * 4);
          const count = Math.floor(floatArr.length / 7);
          gl.drawArrays(gl.POINTS, 0, count);
        } catch (e) {
        }
      }
      try {
        const shapes = AssetsConfig.shapes2d || {};
        for (const b of state.bullets || []) {
          try {
            const bx = b.x || 0;
            const by = b.y || 0;
            const clipX = bx / Math.max(1, LOGICAL_W) * 2 - 1;
            const clipY = 1 - by / Math.max(1, LOGICAL_H) * 2;
            const r = b.radius || b.bulletRadius || 1.5;
            const kind = b.kind || "bullet";
            const assetKey = `bullet_${kind}`;
            const tex = this.bakeShapeToTexture(assetKey) || this.bakeShapeToTexture("bullet") || this.bakeShapeToTexture("particleSmall");
            if (tex && this.texProg) {
              const quadW = r * 2 / Math.max(1, this.fboWidth) * 2;
              const quadH = r * 2 / Math.max(1, this.fboHeight) * 2;
              this.drawTexturedQuad(tex, clipX, clipY, quadW, quadH);
              continue;
            }
            const clipSize = Math.max(1, r * 2);
            const color = AssetsConfig.palette && AssetsConfig.palette.bullet || "#fff";
            const hexToRgba = (hex) => {
              const h = hex.replace("#", "");
              const bigint = parseInt(h.length === 3 ? h.split("").map((c) => c + c).join("") : h, 16);
              const rr = (bigint >> 16 & 255) / 255;
              const gg = (bigint >> 8 & 255) / 255;
              const bcol = (bigint & 255) / 255;
              return [rr, gg, bcol, 1];
            };
            const floatArr = new Float32Array([clipX, clipY, clipSize, 1, 1, 1, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, floatArr, gl.DYNAMIC_DRAW);
            gl.useProgram(this.prog);
            const stride = 7 * 4;
            gl.enableVertexAttribArray(this.attribLoc_pos);
            gl.vertexAttribPointer(this.attribLoc_pos, 2, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(this.attribLoc_size);
            gl.vertexAttribPointer(this.attribLoc_size, 1, gl.FLOAT, false, stride, 2 * 4);
            gl.enableVertexAttribArray(this.attribLoc_color);
            gl.vertexAttribPointer(this.attribLoc_color, 4, gl.FLOAT, false, stride, 3 * 4);
            gl.drawArrays(gl.POINTS, 0, 1);
          } catch (e) {
          }
        }
      } catch (e) {
      }
      try {
        for (const p of state.particles || []) {
          try {
            const px = p.x || 0;
            const py = p.y || 0;
            const clipX = px / Math.max(1, LOGICAL_W) * 2 - 1;
            const clipY = 1 - py / Math.max(1, LOGICAL_H) * 2;
            const size = p.r || 2;
            const shapeKey = p.assetShape || (p.r > 0.5 ? "particleMedium" : "particleSmall");
            const tex = this.bakeShapeToTexture(shapeKey) || this.bakeShapeToTexture("particleSmall");
            if (tex && this.texProg) {
              const quadW = size * 2 / Math.max(1, this.fboWidth) * 2;
              const quadH = size * 2 / Math.max(1, this.fboHeight) * 2;
              this.drawTexturedQuad(tex, clipX, clipY, quadW, quadH);
            }
          } catch (e) {
          }
        }
      } catch (e) {
      }
      try {
        for (const ex of state.explosions || []) {
          try {
            const exx = ex.x || 0;
            const exy = ex.y || 0;
            const clipX = exx / Math.max(1, LOGICAL_W) * 2 - 1;
            const clipY = 1 - exy / Math.max(1, LOGICAL_H) * 2;
            const tex = this.bakeShapeToTexture("explosionParticle") || null;
            const s = ex.scale || 1;
            if (tex && this.texProg) {
              const wq = 12 * s / Math.max(1, this.fboWidth) * 2;
              const hq = 12 * s / Math.max(1, this.fboHeight) * 2;
              this.drawTexturedQuad(tex, clipX, clipY, wq, hq);
            } else {
              const floatArr = new Float32Array([clipX, clipY, Math.max(2, 12 * s), 1, 1, 0.8, 1]);
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, floatArr, gl.DYNAMIC_DRAW);
              gl.useProgram(this.prog);
              const stride = 7 * 4;
              gl.enableVertexAttribArray(this.attribLoc_pos);
              gl.vertexAttribPointer(this.attribLoc_pos, 2, gl.FLOAT, false, stride, 0);
              gl.enableVertexAttribArray(this.attribLoc_size);
              gl.vertexAttribPointer(this.attribLoc_size, 1, gl.FLOAT, false, stride, 2 * 4);
              gl.enableVertexAttribArray(this.attribLoc_color);
              gl.vertexAttribPointer(this.attribLoc_color, 4, gl.FLOAT, false, stride, 3 * 4);
              gl.drawArrays(gl.POINTS, 0, 1);
            }
          } catch (e) {
          }
        }
      } catch (e) {
      }
    }
    if (this.fboTexture && this.quadProg && this.quadVBO && this.gl) {
      const displayScale = RendererConfig && typeof RendererConfig.displayScale === "number" ? RendererConfig.displayScale : 1;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, Math.round(this.canvas.width * displayScale), Math.round(this.canvas.height * displayScale));
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.quadProg);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.fboTexture);
      if (this.quadLoc_tex) gl.uniform1i(this.quadLoc_tex, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVBO);
      gl.enableVertexAttribArray(this.quadLoc_pos);
      gl.vertexAttribPointer(this.quadLoc_pos, 2, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.disableVertexAttribArray(this.quadLoc_pos);
    }
    try {
    } catch (e) {
    }
  }
  // Bake a 2D asset shape into a canvas and upload to a GL texture (cached)
  bakeShapeToTexture(key) {
    if (!this.gl) return null;
    if (this.shapeTextures[key]) return this.shapeTextures[key];
    try {
      const gl = this.gl;
      const shapes = AssetsConfig.shapes2d || {};
      const shape = shapes[key];
      const size = this.shapeCanvasSize;
      const cvs = document.createElement("canvas");
      cvs.width = size;
      cvs.height = size;
      const ctx2 = cvs.getContext("2d");
      ctx2.clearRect(0, 0, size, size);
      ctx2.translate(size / 2, size / 2);
      const scale = size / 4;
      ctx2.fillStyle = AssetsConfig.palette && AssetsConfig.palette.shipHull || "#eee";
      if (!shape) {
        ctx2.beginPath();
        ctx2.arc(0, 0, Math.max(4, size * 0.12), 0, Math.PI * 2);
        ctx2.fill();
      } else if (shape.type === "circle") {
        ctx2.beginPath();
        ctx2.arc(0, 0, (shape.r || 0.5) * scale, 0, Math.PI * 2);
        ctx2.fill();
      } else if (shape.type === "polygon") {
        const pts = shape.points || [];
        if (pts.length) {
          ctx2.beginPath();
          ctx2.moveTo((pts[0][0] || 0) * scale, (pts[0][1] || 0) * scale);
          for (let i = 1; i < pts.length; i++) ctx2.lineTo((pts[i][0] || 0) * scale, (pts[i][1] || 0) * scale);
          ctx2.closePath();
          ctx2.fill();
        }
      } else if (shape.type === "compound") {
        for (const part of shape.parts || []) {
          if (part.type === "circle") {
            ctx2.beginPath();
            ctx2.arc(0, 0, (part.r || 0.5) * scale, 0, Math.PI * 2);
            ctx2.fill();
          } else if (part.type === "polygon") {
            const pts = part.points || [];
            if (pts.length) {
              ctx2.beginPath();
              ctx2.moveTo((pts[0][0] || 0) * scale, (pts[0][1] || 0) * scale);
              for (let i = 1; i < pts.length; i++) ctx2.lineTo((pts[i][0] || 0) * scale, (pts[i][1] || 0) * scale);
              ctx2.closePath();
              ctx2.fill();
            }
          }
        }
      }
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, cvs);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.shapeTextures[key] = tex;
      return tex;
    } catch (e) {
      return null;
    }
  }
  // Draw a textured quad at clip-space coordinates [-1..1] using the baked texture
  drawTexturedQuad(tex, clipX, clipY, clipW, clipH) {
    if (!this.gl || !this.texProg || !tex) return;
    try {
      const gl = this.gl;
      gl.useProgram(this.texProg);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      if (this.texLoc_tex) gl.uniform1i(this.texLoc_tex, 0);
      const x1 = clipX - clipW / 2;
      const x2 = clipX + clipW / 2;
      const y1 = clipY - clipH / 2;
      const y2 = clipY + clipH / 2;
      const verts = new Float32Array([
        x1,
        y1,
        0,
        0,
        x2,
        y1,
        1,
        0,
        x1,
        y2,
        0,
        1,
        x2,
        y1,
        1,
        0,
        x2,
        y2,
        1,
        1,
        x1,
        y2,
        0,
        1
      ]);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texVBO);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
      const stride = 4 * 4;
      gl.enableVertexAttribArray(this.texAttrib_pos);
      gl.vertexAttribPointer(this.texAttrib_pos, 2, gl.FLOAT, false, stride, 0);
      gl.enableVertexAttribArray(this.texAttrib_uv);
      gl.vertexAttribPointer(this.texAttrib_uv, 2, gl.FLOAT, false, stride, 2 * 4);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.disableVertexAttribArray(this.texAttrib_pos);
      gl.disableVertexAttribArray(this.texAttrib_uv);
    } catch (e) {
    }
  }
};

// src/main.ts
async function startApp(rootDocument = document) {
  const gameState = makeInitialState();
  let canvas = rootDocument.getElementById("world");
  if (!canvas) {
    try {
      const el = rootDocument.createElement("canvas");
      el.id = "world";
      rootDocument.body.appendChild(el);
      canvas = el;
    } catch (e) {
      canvas = null;
    }
  }
  const ui = {
    startPause: rootDocument.getElementById("startPause"),
    reset: rootDocument.getElementById("reset"),
    addRed: rootDocument.getElementById("addRed"),
    addBlue: rootDocument.getElementById("addBlue"),
    toggleTrails: rootDocument.getElementById("toggleTrails"),
    speed: rootDocument.getElementById("speed"),
    redScore: rootDocument.getElementById("redScore"),
    blueScore: rootDocument.getElementById("blueScore"),
    stats: rootDocument.getElementById("stats"),
    continuousCheckbox: rootDocument.getElementById("continuousCheckbox"),
    seedBtn: rootDocument.getElementById("seedBtn"),
    formationBtn: rootDocument.getElementById("formationBtn")
  };
  try {
    if (ui.stats) ui.stats.textContent = "Ships: 0 (R:0 B:0) Bullets: 0";
  } catch (e) {
  }
  const LOGICAL_BOUNDS = getDefaultBounds();
  const disposables = [];
  let uiRaf = null;
  let workerIndicatorRaf = null;
  const pendingTimers = /* @__PURE__ */ new Set();
  function addListener(target, type, handler) {
    if (!target) return;
    try {
      target.addEventListener(type, handler);
      disposables.push(() => {
        try {
          target.removeEventListener(type, handler);
        } catch (e) {
        }
      });
    } catch (e) {
    }
  }
  function clearAllTimers() {
    for (const id of Array.from(pendingTimers)) {
      try {
        clearTimeout(id);
      } catch (e) {
      }
      pendingTimers.delete(id);
    }
  }
  function updateCanvasBackingStore() {
    const dpr = window.devicePixelRatio || 1;
    const renderScale = RendererConfig && typeof RendererConfig.renderScale === "number" ? RendererConfig.renderScale : 1;
    const logicalW = LOGICAL_BOUNDS.W;
    const logicalH = LOGICAL_BOUNDS.H;
    if (canvas) {
      const bufferW = Math.round(logicalW * renderScale / dpr);
      const bufferH = Math.round(logicalH * renderScale / dpr);
      canvas.width = bufferW;
      canvas.height = bufferH;
      canvas.style.width = bufferW + "px";
      canvas.style.height = bufferH + "px";
      const dimsEl = document.getElementById("rendererDims");
      if (dimsEl) {
        dimsEl.textContent = `${canvas.width} x ${canvas.height} px @ ${dpr}x`;
      }
    }
    RendererConfig._renderScale = renderScale;
    RendererConfig._offsetX = 0;
    RendererConfig._offsetY = 0;
    const scaleVal = rootDocument.getElementById("rendererScaleValue");
    if (scaleVal) scaleVal.textContent = renderScale.toFixed(2);
  }
  function fitCanvasToWindow() {
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const bufferW = canvas ? canvas.width : LOGICAL_BOUNDS.W;
    const bufferH = canvas ? canvas.height : LOGICAL_BOUNDS.H;
    const scale = Math.min(winW / bufferW, winH / bufferH);
    const scaledW = bufferW * scale;
    const scaledH = bufferH * scale;
    const offsetX = Math.round((winW - scaledW) / 2);
    const offsetY = Math.round((winH - scaledH) / 2);
    if (canvas) {
      canvas.style.width = `${bufferW}px`;
      canvas.style.height = `${bufferH}px`;
      canvas.style.position = "absolute";
      canvas.style.left = `${offsetX}px`;
      canvas.style.top = `${offsetY}px`;
      canvas.style.transformOrigin = "top left";
      canvas.style.transform = `scale(${scale})`;
    }
    document.body.style.overflow = "hidden";
  }
  const scaleSlider = rootDocument.getElementById("rendererScaleRange");
  const dynamicCheckbox = rootDocument.getElementById("dynamicScaleCheckbox");
  let internalScaleUpdate = false;
  if (scaleSlider) {
    const onScaleInput = (ev) => {
      if (internalScaleUpdate) return;
      const val = parseFloat(ev.target.value);
      if (!isNaN(val)) {
        RendererConfig.renderScale = val;
        RendererConfig.dynamicScaleEnabled = false;
        if (dynamicCheckbox) dynamicCheckbox.checked = false;
        updateCanvasBackingStore();
        fitCanvasToWindow();
      }
    };
    addListener(scaleSlider, "input", onScaleInput);
    const scaleVal = rootDocument.getElementById("rendererScaleValue");
    if (scaleVal) scaleVal.textContent = scaleSlider.value;
    updateCanvasBackingStore();
    fitCanvasToWindow();
  }
  if (dynamicCheckbox) {
    const onDynamicChange = (ev) => {
      const enabled = !!ev.target.checked;
      RendererConfig.dynamicScaleEnabled = enabled;
    };
    addListener(dynamicCheckbox, "change", onDynamicChange);
    dynamicCheckbox.checked = !!RendererConfig.dynamicScaleEnabled;
  }
  fitCanvasToWindow();
  addListener(window, "resize", fitCanvasToWindow);
  let renderer = null;
  const pref = getPreferredRenderer();
  if (canvas) {
    if (pref === "webgl") {
      try {
        const w = new WebGLRenderer(canvas);
        if (w && w.init && w.init()) renderer = w;
      } catch (e) {
      }
    }
    if (!renderer) {
      try {
        renderer = new CanvasRenderer(canvas);
        renderer.init && renderer.init();
      } catch (e) {
        renderer = null;
      }
    }
  }
  if (!renderer) {
    renderer = {
      type: "noop",
      init: () => false,
      renderState: (_) => {
      },
      isRunning: () => false
    };
  }
  try {
    window.gm = window.gm || {};
  } catch (e) {
  }
  const gm = createGameManager({ renderer, useWorker: false, seed: 12345 });
  if (gm && gm._internal) {
    gm._internal.bounds = LOGICAL_BOUNDS;
    gm._internal.state = gameState;
  }
  try {
    if (typeof window !== "undefined" && window.gm) Object.assign(window.gm, gm);
  } catch (e) {
  }
  let simSpeedMultiplier = 1;
  if (ui.speed) {
    const onSpeedClick = () => {
      simSpeedMultiplier = simSpeedMultiplier >= 4 ? 0.25 : simSpeedMultiplier * 2;
      ui.speed.textContent = `Speed: ${simSpeedMultiplier}\xD7`;
    };
    addListener(ui.speed, "click", onSpeedClick);
    ui.speed.textContent = `Speed: ${simSpeedMultiplier}\xD7`;
  }
  if (gm && typeof gm.stepOnce === "function") {
    const origStepOnce = gm.stepOnce.bind(gm);
    gm.stepOnce = (dt = 0.016) => origStepOnce(dt * simSpeedMultiplier);
  }
  if (ui.formationBtn) {
    const onFormationClick = () => {
      if (gm && typeof gm.formFleets === "function") {
        gm.formFleets();
      }
    };
    addListener(ui.formationBtn, "click", onFormationClick);
  }
  let engineTrailsEnabled = true;
  gameState.engineTrailsEnabled = engineTrailsEnabled;
  if (ui.toggleTrails) {
    const onToggleTrails = () => {
      engineTrailsEnabled = !engineTrailsEnabled;
      gameState.engineTrailsEnabled = engineTrailsEnabled;
      ui.toggleTrails.textContent = engineTrailsEnabled ? "\u2604 Trails: On" : "\u2604 Trails: Off";
    };
    addListener(ui.toggleTrails, "click", onToggleTrails);
    ui.toggleTrails.textContent = engineTrailsEnabled ? "\u2604 Trails: On" : "\u2604 Trails: Off";
  }
  try {
    const host = location && location.hostname || "";
    const urlParams = typeof URLSearchParams !== "undefined" ? new URLSearchParams(location.search) : null;
    const autotest = urlParams && urlParams.get("autotest") === "1" || !!window.__AUTO_REINFORCE_DEV__;
    if ((host === "127.0.0.1" || host === "localhost") && autotest) {
      try {
        if (gm && typeof gm.setContinuousEnabled === "function") gm.setContinuousEnabled(true);
      } catch (e) {
      }
      try {
        if (gm && typeof gm.setReinforcementInterval === "function") gm.setReinforcementInterval(0.01);
      } catch (e) {
      }
      try {
        if (gm && typeof gm.stepOnce === "function") gm.stepOnce(0.02);
      } catch (e) {
      }
    }
  } catch (e) {
  }
  let lastReinforcementSummary = "";
  let reinforcementsHandler = null;
  try {
    if (gm && typeof gm.on === "function") {
      reinforcementsHandler = (msg) => {
        const list = msg && msg.spawned || [];
        const types = list.map((s) => s.type).filter(Boolean);
        const summary = `Reinforcements: spawned ${list.length} ships (${types.join(", ")})`;
        lastReinforcementSummary = summary;
        try {
          const tid = setTimeout(() => {
            lastReinforcementSummary = "";
          }, 3e3);
          pendingTimers.add(tid);
        } catch (e) {
        }
        try {
          if (ui && ui.stats) ui.stats.textContent = `${ui.stats.textContent} | ${summary}`;
        } catch (e) {
        }
      };
      gm.on("reinforcements", reinforcementsHandler);
    }
  } catch (e) {
  }
  const workerIndicator = rootDocument.getElementById("workerIndicator");
  let toastContainer = rootDocument.getElementById("toastContainer");
  if (!toastContainer) {
    try {
      toastContainer = rootDocument.createElement("div");
      toastContainer.id = "toastContainer";
      toastContainer.style.position = "fixed";
      toastContainer.style.right = "16px";
      toastContainer.style.top = "16px";
      toastContainer.style.zIndex = "9999";
      toastContainer.style.pointerEvents = "none";
      rootDocument.body.appendChild(toastContainer);
      disposables.push(() => {
        try {
          if (toastContainer && toastContainer.parentNode) toastContainer.parentNode.removeChild(toastContainer);
        } catch (e) {
        }
      });
    } catch (e) {
      toastContainer = null;
    }
  }
  function showToast(msg, opts = {}) {
    try {
      if (!toastContainer) return;
      const ttl = typeof opts.ttl === "number" ? opts.ttl : 2e3;
      const el = rootDocument.createElement("div");
      el.style.background = "rgba(20,20,30,0.9)";
      el.style.color = "#fff";
      el.style.padding = "8px 12px";
      el.style.marginTop = "6px";
      el.style.borderRadius = "6px";
      el.style.boxShadow = "0 2px 8px rgba(0,0,0,0.5)";
      el.style.fontFamily = "sans-serif";
      el.style.fontSize = "13px";
      el.style.pointerEvents = "auto";
      el.textContent = msg;
      toastContainer.appendChild(el);
      const tid = setTimeout(() => {
        try {
          el.style.transition = "opacity 300ms ease";
          el.style.opacity = "0";
        } catch (e) {
        }
        ;
        setTimeout(() => {
          try {
            if (el && el.parentNode) el.parentNode.removeChild(el);
          } catch (err) {
          }
        }, 350);
      }, ttl);
      pendingTimers.add(tid);
    } catch (e) {
    }
  }
  let levelupHandler = null;
  try {
    if (gm && typeof gm.on === "function") {
      levelupHandler = (m) => {
        try {
          const ship = m && m.ship || null;
          const lvl = m && m.newLevel || (m && m.newLevel === 0 ? 0 : void 0);
          const who = ship && ship.team ? `${ship.team} ship` : "Ship";
          const msg = `${who} leveled up to ${lvl}`;
          showToast(msg, { ttl: 2200 });
        } catch (e) {
        }
      };
      gm.on("levelup", levelupHandler);
    }
  } catch (e) {
  }
  if (workerIndicator) {
    try {
      const refresh = () => {
        try {
          workerIndicator.textContent = gm.isWorker && gm.isWorker() ? "Worker" : "Main";
        } catch (e) {
        }
        try {
          workerIndicatorRaf = requestAnimationFrame(refresh);
        } catch (e) {
          workerIndicatorRaf = null;
        }
      };
      refresh();
    } catch (e) {
      workerIndicator.textContent = "Unknown";
    }
  }
  try {
    if (ui.startPause) addListener(ui.startPause, "click", () => {
      if (gm.isRunning()) {
        gm.pause();
        ui.startPause.textContent = "\u25B6 Start";
      } else {
        gm.start();
        ui.startPause.textContent = "\u23F8 Pause";
      }
    });
  } catch (e) {
  }
  try {
    if (ui.reset) addListener(ui.reset, "click", () => gm.reset());
  } catch (e) {
  }
  try {
    if (ui.addRed) addListener(ui.addRed, "click", () => gm.spawnShip("red"));
  } catch (e) {
  }
  try {
    if (ui.addBlue) addListener(ui.addBlue, "click", () => gm.spawnShip("blue"));
  } catch (e) {
  }
  function onSeedBtnClick() {
    try {
      const raw = typeof window !== "undefined" && typeof window.prompt === "function" ? window.prompt("Enter new seed (leave blank for random):", "") : null;
      if (raw == null) return;
      const trimmed = String(raw).trim();
      if (trimmed === "") {
        try {
          gm.reseed();
          showToast("Reseeded with random seed");
        } catch (e) {
        }
        return;
      }
      const asNum = Number(trimmed);
      if (!Number.isFinite(asNum) || Math.floor(asNum) !== asNum) {
        try {
          showToast("Invalid seed. Please enter an integer.");
        } catch (e) {
        }
        return;
      }
      try {
        gm.reseed(asNum >>> 0);
        showToast(`Reseeded with ${asNum >>> 0}`);
      } catch (e) {
      }
    } catch (e) {
    }
  }
  try {
    if (ui.seedBtn) addListener(ui.seedBtn, "click", onSeedBtnClick);
  } catch (e) {
  }
  try {
    if (ui.continuousCheckbox) {
      addListener(ui.continuousCheckbox, "change", (ev) => {
        const v = !!ev.target.checked;
        if (gm && typeof gm.setContinuousEnabled === "function") gm.setContinuousEnabled(v);
      });
    }
  } catch (e) {
  }
  function uiTick() {
    const startTick = performance.now();
    let skipRender = false;
    try {
      const s = gm.snapshot();
      ui.redScore.textContent = `Red ${gm.score.red}`;
      ui.blueScore.textContent = `Blue ${gm.score.blue}`;
      const redCount = s.ships.filter((sh) => sh.team === "red").length;
      const blueCount = s.ships.filter((sh) => sh.team === "blue").length;
      ui.stats.textContent = `Ships: ${s.ships.length} (R:${redCount} B:${blueCount}) Bullets: ${s.bullets.length}` + (lastReinforcementSummary ? ` | ${lastReinforcementSummary}` : "");
    } catch (e) {
    }
    const endTick = performance.now();
    const tickTime = endTick - startTick;
    if (tickTime > SIM.DT_MS) {
      skipRender = true;
    }
    const dynamicEnabled = !!RendererConfig.dynamicScaleEnabled;
    const scaleSliderEl = rootDocument.getElementById("rendererScaleRange");
    const scaleValEl = rootDocument.getElementById("rendererScaleValue");
    const now = performance.now();
    RendererConfig._lastUiTick = RendererConfig._lastUiTick || now;
    const dt = now - RendererConfig._lastUiTick;
    RendererConfig._lastUiTick = now;
    RendererConfig.lastFrameTime = dt;
    let frameScore = "green";
    if (dt > 33) frameScore = "red";
    else if (dt > 20) frameScore = "yellow";
    RendererConfig.frameScore = frameScore;
    if (scaleValEl) {
      scaleValEl.style.color = frameScore === "green" ? "#4caf50" : frameScore === "yellow" ? "#ffd600" : "#ff1744";
    }
    if (dynamicEnabled && scaleSliderEl) {
      let scale = RendererConfig.renderScale;
      if (frameScore === "red" && scale > 0.25) scale = Math.max(0.25, scale - 0.05);
      else if (frameScore === "green" && scale < 2) scale = Math.min(2, scale + 0.01);
      if (scale !== RendererConfig.renderScale) {
        RendererConfig.renderScale = scale;
        internalScaleUpdate = true;
        scaleSliderEl.value = scale.toFixed(2);
        if (scaleValEl) scaleValEl.textContent = scale.toFixed(2);
        fitCanvasToWindow();
        internalScaleUpdate = false;
      }
    }
    if (!skipRender) {
      try {
        uiRaf = requestAnimationFrame(uiTick);
      } catch (e) {
        uiRaf = null;
      }
    } else {
      const tid = setTimeout(uiTick, SIM.DT_MS);
      if (typeof tid === "number") pendingTimers.add(tid);
    }
  }
  uiRaf = requestAnimationFrame(uiTick);
  function dispose() {
    try {
      if (gm && typeof gm.destroy === "function") gm.destroy();
    } catch (e) {
    }
    try {
      if (gm && typeof gm.pause === "function") gm.pause();
    } catch (e) {
    }
    try {
      if (gm && typeof gm.off === "function") {
        if (reinforcementsHandler) gm.off("reinforcements", reinforcementsHandler);
        if (levelupHandler) gm.off("levelup", levelupHandler);
      }
    } catch (e) {
    }
    if (uiRaf != null) {
      try {
        cancelAnimationFrame(uiRaf);
      } catch (e) {
      }
      uiRaf = null;
    }
    if (workerIndicatorRaf != null) {
      try {
        cancelAnimationFrame(workerIndicatorRaf);
      } catch (e) {
      }
      workerIndicatorRaf = null;
    }
    try {
      clearAllTimers();
    } catch (e) {
    }
    for (const fn of disposables.slice()) {
      try {
        fn();
      } catch (e) {
      }
    }
    disposables.length = 0;
    try {
      if (typeof window !== "undefined" && window.gm) {
        try {
          delete window.gm;
        } catch (e) {
        }
      }
    } catch (e) {
    }
  }
  return { gm, renderer, dispose };
}
if (typeof window !== "undefined") {
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", () => startApp(document));
  else startApp(document);
}
var main_default = startApp;
export {
  main_default as default,
  startApp
};
//# sourceMappingURL=bundled.js.map

</script>
</body>
</html>