{
  "version": 3,
  "sources": ["../src/config/entitiesConfig.ts", "../src/config/progressionConfig.ts", "../src/config/simConfig.ts", "../src/rng.ts", "../src/entities.ts", "../src/config/teamsConfig.ts", "../src/config/behaviorConfig.ts", "../src/behavior.ts", "../src/simulate.ts", "../src/simWorker.ts"],
  "sourcesContent": ["// entitiesConfig.ts - ship-type defaults and visuals helpers (typed)\n//\n// Tuning rationale (2025-08-24):\n// - Playfield size: 1920x1080\n// - Ship speeds (maxSpeed, accel): Higher speed enables kiting and rapid repositioning; slower ships are easier to flank.\n// - Turn rates (turnRate): Higher turn rate allows ships to evade, flank, and respond to threats quickly; low turn rate makes ships vulnerable to flanking.\n// - Weapon ranges (muzzleSpeed * bulletTTL): Longer range supports kiting and edge play; shorter range requires close engagement and rewards flanking.\n// - Weapon rate (rate): Higher fire rate enables sustained pressure and kiting; lower rate rewards timing and positioning.\n// - Ship radius: Larger ships are easier to hit and harder to flank; smaller ships excel at flanking and evasion.\n// - Boundary options (see simConfig.ts): Enable edge play (wrap, bounce, remove) for tactical escapes and repositioning.\n// - See patch history for details\nimport {\n  getShipAsset,\n  getBulletAsset,\n  getTurretAsset,\n} from \"./assets/assetsConfig\";\n\n// CannonCfg parameters and tactical impact:\n// - damage: Higher damage increases threat, rewards flanking and burst attacks.\n// - rate: Higher rate supports kiting and pressure; lower rate rewards timing.\n// - spread: More spread makes weapons less accurate, favors close-range flanking.\n// - muzzleSpeed: Higher speed increases range and kiting potential.\n// - bulletRadius: Larger radius makes shots easier to land, favors area denial.\n// - bulletTTL: Longer TTL increases range, supports edge play and kiting.\nexport type CannonCfg = {\n  damage: number;\n  rate: number;\n  spread?: number;\n  muzzleSpeed?: number;\n  bulletRadius?: number;\n  bulletTTL?: number;\n};\n\n// ShipTypeCfg parameters and tactical impact:\n// - maxHp, armor, maxShield: Higher values increase survivability, allow for riskier flanking and edge play.\n// - shieldRegen: Faster regen supports hit-and-run and kiting.\n// - damage/dmg: Higher damage rewards successful flanking and burst attacks.\n// - radius: Smaller radius makes ships harder to hit and better at flanking; larger radius increases vulnerability.\n// - cannons: Weapon loadout affects tactical options (see CannonCfg).\n// - accel: Higher acceleration enables rapid repositioning and kiting.\n// - turnRate: Higher turn rate allows for quick flanking, evasion, and edge play.\n// - maxSpeed: Higher speed supports kiting and edge escapes; lower speed makes ships easier to pursue and flank.\n// - turrets: Multiple turrets increase area control, make flanking harder.\n// - friction: Lower friction (closer to 1) enables sustained velocity for kiting and edge play; higher friction increases tactical vulnerability to pursuit and flanking.\n// All entities and events are pruned immediately upon destruction or expiration, ensuring tactical scenarios remain robust and consistent.\nexport type ShipTypeCfg = {\n  maxHp: number;\n  armor?: number;\n  maxShield?: number;\n  shieldRegen?: number;\n  dmg?: number;\n  damage?: number;\n  radius?: number;\n  cannons?: CannonCfg[];\n  accel?: number;\n  turnRate?: number;\n  maxSpeed?: number;\n  carrier?: {\n    fighterCooldown: number;\n    maxFighters: number;\n    spawnPerCooldown: number;\n  };\n  turrets?: Array<{\n    position: [number, number]; // relative to ship center, in radius units\n    kind: string; // turret asset kind\n    targeting?: \"nearest\" | \"random\" | \"focus\" | \"custom\"; // targeting logic\n    cooldown?: number; // seconds between shots\n    lastFired?: number; // timestamp of last shot\n  }>;\n};\n\nexport type ShipConfigMap = Record<string, ShipTypeCfg>;\n\nexport const ShipConfig: ShipConfigMap = {\n  fighter: {\n    maxHp: 15,\n    armor: 0,\n    maxShield: 8,\n    shieldRegen: 1.0,\n    dmg: 3,\n    damage: 3,\n    radius: 12,\n    cannons: [\n      {\n        damage: 3,\n        rate: 3,\n        spread: 0.1,\n        muzzleSpeed: 260, // was 300\n        bulletRadius: 1.5,\n        bulletTTL: 1.1, // was 1.2\n      },\n    ],\n    accel: 5,\n    turnRate: 6,\n    maxSpeed: 160,\n  },\n  corvette: {\n    maxHp: 50,\n    armor: 0,\n    maxShield: Math.round(50 * 0.6),\n    shieldRegen: 0.5,\n    dmg: 5,\n    damage: 5,\n    radius: 20,\n    accel: 5,\n    turnRate: 3.5, // was 3\n    maxSpeed: 145, // was 140\n    cannons: [\n      {\n        damage: 6,\n        rate: 1.2,\n        spread: 0.05,\n        muzzleSpeed: 180, // was 220\n        bulletRadius: 2,\n        bulletTTL: 1.8, // was 2.0\n      },\n    ],\n  },\n  frigate: {\n    maxHp: 80,\n    armor: 1,\n    maxShield: Math.round(80 * 0.6),\n    shieldRegen: 0.4,\n    dmg: 8,\n    damage: 8,\n    radius: 24,\n    cannons: [\n      {\n        damage: 8,\n        rate: 1.0,\n        spread: 0.06,\n        muzzleSpeed: 180, // was 200\n        bulletRadius: 2.5,\n        bulletTTL: 2.0, // was 2.2\n      },\n    ],\n    accel: 5,\n    turnRate: 2.5, // was 2.2\n    maxSpeed: 125, // was 120\n  },\n  destroyer: {\n    maxHp: 120,\n    armor: 2,\n    maxShield: Math.round(120 * 0.6),\n    shieldRegen: 0.3,\n    dmg: 12,\n    damage: 12,\n    radius: 40,\n    cannons: new Array(6).fill(0).map(() => ({\n      damage: 6,\n      rate: 0.8,\n      spread: 0.08,\n      muzzleSpeed: 160, // was 240\n      bulletRadius: 2.5,\n      bulletTTL: 1.8, // was 2.4\n    })),\n    accel: 5,\n    turnRate: 2.0, // was 1.6\n    maxSpeed: 110, // was 100\n    turrets: [\n      {\n        position: [1.2, 0.8],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n      {\n        position: [-1.2, 0.8],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n      {\n        position: [1.2, -0.8],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n      {\n        position: [-1.2, -0.8],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n      {\n        position: [0, 1.5],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n      {\n        position: [0, -1.5],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 0.8,\n      },\n    ],\n  },\n  carrier: {\n    maxHp: 200,\n    armor: 3,\n    maxShield: Math.round(200 * 0.6),\n    shieldRegen: 0.2,\n    dmg: 2,\n    damage: 2,\n    radius: 40,\n    cannons: new Array(4).fill(0).map(() => ({\n      damage: 4,\n      rate: 0.6,\n      spread: 0.12,\n      muzzleSpeed: 140, // was 180\n      bulletRadius: 3,\n      bulletTTL: 2.2, // was 2.8\n    })),\n    accel: 5,\n    turnRate: 1.2, // was 0.8\n    maxSpeed: 95, // was 80\n    carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 },\n    turrets: [\n      {\n        position: [2.0, 1.2],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 1.0,\n      },\n      {\n        position: [-2.0, 1.2],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 1.0,\n      },\n      {\n        position: [2.0, -1.2],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 1.0,\n      },\n      {\n        position: [-2.0, -1.2],\n        kind: \"basic\",\n        targeting: \"nearest\",\n        cooldown: 1.0,\n      },\n    ],\n  },\n};\nexport function getShipConfig() {\n  return ShipConfig;\n}\n\n// Bullet global defaults (used if not per-ship)\nexport const BULLET_DEFAULTS = {\n  damage: 1,\n  ttl: 2.0,\n  radius: 1.5,\n  muzzleSpeed: 240,\n};\n\n// Particle defaults (used for generic effects)\nexport const PARTICLE_DEFAULTS = {\n  ttl: 1,\n  color: \"#fff\",\n  size: 2,\n};\n\n// Team fallback default\n\nexport function bulletKindForRadius(r: number): string {\n  if (r < 2) return \"small\";\n  if (r < 2.5) return \"medium\";\n  if (r < 3.5) return \"large\";\n  return \"heavy\";\n}\n\nexport function getDefaultShipType(): string {\n  return Object.keys(ShipConfig)[0] || \"fighter\";\n}\n\nexport default ShipConfig;\n", "// Enhanced progression with diminishing returns and extra per-level scalars\r\nexport const progression = {\r\n  xpPerDamage: 1,\r\n  xpPerKill: 50,\r\n  xpToLevel: (level: number) => 100 * Math.pow(1.25, level - 1),\r\n  hpPercentPerLevel: (level: number) => Math.min(0.10, 0.05 + 0.05 / Math.sqrt(level)),\r\n  dmgPercentPerLevel: 0.08,\r\n  shieldPercentPerLevel: 0.06,\r\n  speedPercentPerLevel: 0.03,\r\n  regenPercentPerLevel: 0.04,\r\n};\r\n\r\nexport default progression;\r\n", "import type { BoundaryBehavior } from './types';\nexport const SIM = { DT_MS: 16, MAX_ACC_MS: 250 } as const;\n// boundaryBehavior: Tactical impact and pruning rationale\n// - 'remove': Ships/bullets are eliminated at map edge; punishes edge play, rewards central control. Pruning is immediate for out-of-bounds entities.\n// - 'wrap': Ships/bullets reappear on opposite edge; enables edge escapes, flanking via wrap, and kiting around boundaries. Pruning only occurs for expired entities.\n// - 'bounce': Ships/bullets reflect off edge; supports tactical repositioning, edge denial, and hit-and-run. Pruning is immediate for expired entities.\n// All entities, particles, and events are pruned immediately upon destruction, expiration, or leaving bounds, ensuring robust cleanup and tactical consistency.\nexport const boundaryBehavior: { ships: BoundaryBehavior; bullets: BoundaryBehavior } = {\n  ships: 'wrap',\n  bullets: 'remove',\n};\n\nexport const progression = {\n  xpPerDamage: 1,\n  xpPerKill: 50,\n  xpToLevel: (level: number) => 100 + level * 50,\n};\n\nexport default { SIM, progression, boundaryBehavior };\n", "// src/rng.ts - Seeded RNG utilities (ported from rng.js)\r\nlet _seed = 1;\r\n\r\nexport function srand(seed: number = 1) {\r\n  // store as 32-bit unsigned\r\n  _seed = seed >>> 0;\r\n}\r\n\r\n// mulberry32 PRNG\r\nfunction mulberry32(a: number) {\r\n  return function() {\r\n    let t = (a += 0x6D2B79F5) >>> 0;\r\n    t = Math.imul(t ^ (t >>> 15), t | 1);\r\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\r\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n  };\r\n}\r\n\r\nexport function srandom(): number {\r\n  const f = mulberry32(_seed);\r\n  // advance seed deterministically\r\n  _seed = (_seed + 0x9E3779B1) >>> 0;\r\n  return f();\r\n}\r\n\r\nexport function srange(min: number, max: number): number {\r\n  return min + (max - min) * srandom();\r\n}\r\n\r\nexport function srangeInt(min: number, max: number): number {\r\n  // exclusive upper bound to match expectations\r\n  return Math.floor(srange(min, max));\r\n}\r\n\r\nexport default { srand, srandom, srange, srangeInt };\r\n", "import { getShipConfig, getDefaultShipType, BULLET_DEFAULTS } from \"./config/entitiesConfig\";\nimport { TEAM_DEFAULT } from \"./config/teamsConfig\";\nimport type { ShipConfigMap, ShipSpec } from \"./types/index\";\n\nlet nextId = 1;\nexport function genId(): number {\n  return nextId++;\n}\n\nexport type Cannon = {\n  damage: number;\n  rate: number;\n  spread?: number;\n  muzzleSpeed?: number;\n  bulletRadius?: number;\n  bulletTTL?: number;\n};\n\nexport type Ship = {\n  id: number;\n  type: string;\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  hp: number;\n  maxHp: number;\n  shield?: number;\n  maxShield?: number;\n  team?: string;\n  xp?: number;\n  level?: number;\n  cannons?: Cannon[];\n  accel?: number; // max acceleration from config\n  currentAccel?: number; // dynamic, set by AI/gamemanager, 0..accel\n  throttle?: number; // 0..1, set by AI/gamemanager\n  steering?: number; // -1..1, set by AI/gamemanager\n  turnRate?: number;\n  radius?: number;\n  angle?: number; // heading in radians\n  friction?: number; // velocity damping factor (default 0.98)\n  maxSpeed?: number; // max speed override for tests/simulation\n  // optional AI runtime slot used by tests and behavior logic\n  __ai?: any;\n};\n\nexport function createShip(\n  type: string | undefined = undefined,\n  x = 0,\n  y = 0,\n  team = TEAM_DEFAULT,\n): Ship {\n  const shipCfg = getShipConfig() as ShipConfigMap;\n  const availableTypes = Object.keys(shipCfg || {});\n  const resolvedType =\n    type && shipCfg[type]\n      ? type\n      : availableTypes.length\n        ? availableTypes[0]\n        : getDefaultShipType();\n  const cfg = (shipCfg[resolvedType] ||\n    shipCfg[getDefaultShipType()]) as Partial<ShipSpec>;\n  return {\n    id: genId(),\n    type: resolvedType,\n    x,\n    y,\n    vx: 0,\n    vy: 0,\n    hp: cfg.maxHp,\n    maxHp: cfg.maxHp,\n    shield: cfg.maxShield || 0,\n    maxShield: cfg.maxShield || 0,\n    team,\n    xp: 0,\n    level: 1,\n    cannons: JSON.parse(JSON.stringify(cfg.cannons || [])),\n    accel: cfg.accel || 0,\n    currentAccel: 0, // start at rest, AI/gamemanager sets this\n    throttle: 0, // start at rest, AI/gamemanager sets this\n    steering: 0, // start straight, AI/gamemanager sets this\n    turnRate: cfg.turnRate || 0,\n    radius: cfg.radius || 6,\n    maxSpeed: cfg.maxSpeed || undefined,\n    angle: 0,\n  } as Ship;\n}\n\nexport type Bullet = {\n  id: number;\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  team: string;\n  ownerId?: number | null;\n  damage: number;\n  ttl: number;\n};\n\nexport function createBullet(\n  x: number,\n  y: number,\n  vx: number,\n  vy: number,\n  team = TEAM_DEFAULT,\n  ownerId: number | null = null,\n  damage = 1,\n  ttl = 2.0,\n): Bullet {\n  return {\n    id: genId(),\n    x,\n    y,\n    vx,\n    vy,\n    team,\n    ownerId,\n    damage,\n    ttl,\n  } as Bullet;\n}\n\nexport type GameState = {\n  t: number;\n  ships: Ship[];\n  bullets: Bullet[];\n  explosions: any[];\n  shieldHits: any[];\n  healthHits: any[];\n  engineTrailsEnabled?: boolean;\n};\n\nexport function makeInitialState(): GameState {\n  return {\n    t: 0,\n    ships: [],\n    bullets: [],\n    explosions: [],\n    shieldHits: [],\n    healthHits: [],\n    engineTrailsEnabled: true,\n  };\n}\n\nexport default { createShip, createBullet, makeInitialState };\n", "// teamsConfig.ts - Teams and fleet helpers (typed)\nimport { getDefaultShipType, getShipConfig } from \"./entitiesConfig\"; // should be './config/entitiesConfig'\nexport type Team = { id: string; color: string; label?: string };\nexport const TeamsConfig = {\n  teams: {\n    red: { id: \"red\", color: \"#ff4d4d\", label: \"Red\" },\n    blue: { id: \"blue\", color: \"#4da6ff\", label: \"Blue\" },\n  },\n  defaultFleet: {\n    counts: (() => {\n      // Build a default counts map from available ShipConfig types so new\n      // ship types are automatically included without needing manual edits.\n      const shipCfg = getShipConfig();\n      const types = Object.keys(shipCfg || {});\n      // sane defaults: make fighters most common, others rarer\n      const defaultCounts: Record<string, number> = {};\n      for (const t of types) {\n        if (t === \"fighter\") defaultCounts[t] = 8;\n        else if (t === \"corvette\") defaultCounts[t] = 3;\n        else if (t === \"frigate\") defaultCounts[t] = 2;\n        else if (t === \"destroyer\") defaultCounts[t] = 1;\n        else if (t === \"carrier\") defaultCounts[t] = 1;\n        else defaultCounts[t] = 1;\n      }\n      return defaultCounts;\n    })(),\n    spacing: 28,\n    jitter: { x: 80, y: 120 },\n  },\n  // continuousReinforcement controls: enable/disable, scoreMargin is the\n  // imbalance fraction (e.g. 0.12 means reinforce when weakest ratio < 0.38),\n  // perTick is the maximum ships considered per reinforcement tick, and\n  // shipTypes is an optional array of types to choose from randomly. If\n  // omitted, keys from defaultFleet.counts are used.\n  continuousReinforcement: {\n    enabled: false,\n    scoreMargin: 0.12,\n    perTick: 1,\n    interval: 5.0,\n    shipTypes: undefined as string[] | undefined,\n  },\n};\n\n// Local seeded PRNG (does not affect global rng)\nfunction mulberry32(seed: number) {\n  let t = seed >>> 0;\n  return function () {\n    t += 0x6d2b79f5;\n    let r = Math.imul(t ^ (t >>> 15), 1 | t);\n    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);\n    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;\n  };\n}\n\nfunction hashStringToInt(s: string) {\n  let h = 2166136261 >>> 0;\n  for (let i = 0; i < s.length; i++) {\n    h ^= s.charCodeAt(i);\n    h = Math.imul(h, 16777619) >>> 0;\n  }\n  return h >>> 0;\n}\n\nexport function generateFleetForTeam(\n  seed = 0,\n  teamId: \"red\" | \"blue\" = \"red\",\n  bounds = { W: 800, H: 600 },\n  shipFactory?: (type: string, x: number, y: number, team: string) => any,\n  options: any = {},\n) {\n  const cfg = Object.assign({}, TeamsConfig.defaultFleet, options.fleet || {});\n  const spacing = options.spacing ?? cfg.spacing;\n  const jitter = Object.assign({}, cfg.jitter, options.jitter || {});\n  const centerY = bounds.H / 2;\n  const baseX = teamId === \"red\" ? bounds.W * 0.22 : bounds.W * 0.78;\n  const rng = mulberry32((seed >>> 0) + hashStringToInt(teamId));\n  const out: any[] = [];\n  for (const [type, count] of Object.entries(cfg.counts)) {\n    for (let i = 0; i < (count as number); i++) {\n      const r = spacing * Math.sqrt(rng());\n      const angle = rng() * Math.PI * 2;\n      const dx = Math.cos(angle) * r + (rng() - 0.5) * (jitter.x ?? 0);\n      const dy = Math.sin(angle) * r + (rng() - 0.5) * (jitter.y ?? 0);\n      const x = Math.max(0, Math.min(bounds.W - 1e-6, baseX + dx));\n      const y = Math.max(0, Math.min(bounds.H - 1e-6, centerY + dy));\n      if (typeof shipFactory === \"function\")\n        out.push(shipFactory(type, x, y, teamId));\n      else out.push({ type, x, y, team: teamId });\n    }\n  }\n  return out;\n}\n\nexport function makeInitialFleets(\n  seed = 0,\n  bounds = { W: 800, H: 600 },\n  shipFactory?: (type: string, x: number, y: number, team: string) => any,\n  options: any = {},\n) {\n  const red = generateFleetForTeam(seed, \"red\", bounds, shipFactory, options);\n  const blue = generateFleetForTeam(\n    seed + 1,\n    \"blue\",\n    bounds,\n    shipFactory,\n    options,\n  );\n  return red.concat(blue);\n}\n\nexport function chooseReinforcements(\n  seed = 0,\n  state: any = {},\n  options: any = {},\n) {\n  const cfg = Object.assign({}, TeamsConfig.continuousReinforcement, options);\n  // (no-op) merge options onto default continuous reinforcement config\n  if (!cfg.enabled) return [] as any[];\n  const teamStrength: Record<string, number> = {};\n  if (Array.isArray(state.ships)) {\n    for (const s of state.ships) {\n      if (!s || !s.team) continue;\n      const hp = typeof s.hp === \"number\" ? s.hp : 1;\n      teamStrength[s.team] = (teamStrength[s.team] || 0) + hp;\n    }\n  }\n  const teams = Object.keys(TeamsConfig.teams);\n  if (teams.length === 0) return [];\n  for (const t of teams) {\n    if (!teamStrength[t]) {\n      const cnt = (state.ships || []).filter(\n        (s: any) => s && s.team === t,\n      ).length;\n      teamStrength[t] = cnt > 0 ? cnt : 0;\n    }\n  }\n  let weakest = teams[0];\n  let strongest = teams[0];\n  for (const t of teams) {\n    if (teamStrength[t] < teamStrength[weakest]) weakest = t;\n    if (teamStrength[t] > teamStrength[strongest]) strongest = t;\n  }\n  const total = teams.reduce((s, t) => s + (teamStrength[t] || 0), 0) || 1;\n  const weakestRatio = (teamStrength[weakest] || 0) / total;\n  if (weakestRatio < 0.5 - cfg.scoreMargin) {\n    const orders: any[] = [];\n    const rng = mulberry32((seed >>> 0) + hashStringToInt(weakest));\n    // determine candidate ship types: either explicit list or keys from defaultFleet\n    const candidateTypes =\n      Array.isArray(cfg.shipTypes) && cfg.shipTypes.length\n        ? cfg.shipTypes\n        : Object.keys(TeamsConfig.defaultFleet.counts || { fighter: 1 });\n    // Build weights for candidate types using defaultFleet counts when available\n    const countsMap =\n      TeamsConfig && TeamsConfig.defaultFleet && TeamsConfig.defaultFleet.counts\n        ? TeamsConfig.defaultFleet.counts\n        : {};\n    const weights = candidateTypes.map((t: string) =>\n      Math.max(0, Number((countsMap as any)[t]) || 1),\n    );\n    const totalWeight =\n      weights.reduce((s: number, w: number) => s + w, 0) ||\n      candidateTypes.length ||\n      1;\n    // Helper: weighted random pick for ship types\n    const weightedPick = () => {\n      const r = rng() * totalWeight;\n      let acc = 0;\n      for (let i = 0; i < candidateTypes.length; i++) {\n        acc += weights[i];\n        if (r < acc) return candidateTypes[i];\n      }\n      return candidateTypes[candidateTypes.length - 1];\n    };\n    // Randomize number to spawn between 1 and cfg.perTick (inclusive)\n    const maxPerTick = Math.max(1, Math.floor(Number(cfg.perTick) || 1));\n    const spawnCount = Math.max(1, Math.floor(rng() * maxPerTick) + 1);\n    // spawnCount computed deterministically from the provided seed\n    const b = options.bounds || { W: 800, H: 600 };\n    const centerY = b.H / 2;\n    const baseX = weakest === \"red\" ? b.W * 0.18 : b.W * 0.82;\n    for (let i = 0; i < spawnCount; i++) {\n      const x = Math.max(0, Math.min(b.W - 1e-6, baseX + (rng() - 0.5) * 120));\n      const y = Math.max(\n        0,\n        Math.min(b.H - 1e-6, centerY + (rng() - 0.5) * 160),\n      );\n      const type =\n        Array.isArray(cfg.shipTypes) && cfg.shipTypes.length\n          ? candidateTypes[Math.floor(rng() * candidateTypes.length)] ||\n            getDefaultShipType()\n          : weightedPick();\n      orders.push({ type, team: weakest, x, y });\n    }\n    // return deterministic orders\n    return orders;\n  }\n  return [] as any[];\n}\n\n// Team fallback default\nexport const TEAM_DEFAULT = \"red\";\n\nexport default TeamsConfig;\n\n// Helper: call chooseReinforcements using a manager-derived seed (from global RNG)\n// This is convenient for callers (like gamemanager) that want to keep\n// reinforcements deterministic relative to the global `srand`/`srandom` state.\nimport { srandom } from \"../rng\";\nexport function chooseReinforcementsWithManagerSeed(\n  state: any = {},\n  options: any = {},\n) {\n  const seed = Math.floor(srandom() * 0xffffffff) >>> 0;\n  return chooseReinforcements(seed, state, options);\n}\n", "export const EVASIVE_DURATION = 0.8; // seconds\nexport const TURN_RATES = { default: 4.0 } as const; // radians per second typical turn rate\nexport const EVASIVE_THRUST_MULT = 1.5; // multiplier for thrust during evasive maneuvers\nexport const SEPARATION_MULT = 0.6; // separation force multiplier between ships\n\n// AI logic thresholds and decision timer\nexport const AI_THRESHOLDS = {\n  decisionTimerMin: 0.5,\n  decisionTimerMax: 2.0,\n  hpEvadeThreshold: 0.35,\n  randomLow: 0.15,\n  randomHigh: 0.85,\n};\n\n// Ship movement global defaults (used if not per-ship)\nexport const SHIP_MOVEMENT_DEFAULTS = {\n  maxSpeed: 160,\n  maxAccel: 5,\n};\n\nexport default {\n  EVASIVE_DURATION,\n  TURN_RATES,\n  EVASIVE_THRUST_MULT,\n  SEPARATION_MULT,\n  AI_THRESHOLDS,\n  SHIP_MOVEMENT_DEFAULTS,\n};\n", "// behavior.ts - deterministic, simple AI for steering and firing\n// Uses seeded RNG for any randomness so results are reproducible.\nimport { srandom, srange } from \"./rng\";\nimport { createBullet } from \"./entities\";\nimport { AI_THRESHOLDS, SHIP_MOVEMENT_DEFAULTS } from \"./config/behaviorConfig\";\nimport { BULLET_DEFAULTS } from \"./config/entitiesConfig\";\nimport { TEAM_DEFAULT } from \"./config/teamsConfig\";\n\ntype ShipLike = {\n  id?: number;\n  x?: number;\n  y?: number;\n  vx?: number;\n  vy?: number;\n  team?: string;\n  hp?: number;\n  maxHp?: number;\n  cannons?: any[];\n  accel?: number; // max acceleration from config\n  currentAccel?: number; // dynamic, set by AI/gamemanager, 0..accel\n  radius?: number;\n  turnRate?: number;\n  damage?: number;\n  dmg?: number;\n  maxSpeed?: number; // NEW: max speed per ship\n  steering?: number; // NEW: steering intent (-1..1)\n  throttle?: number; // NEW: throttle intent (0..1)\n  __ai?: any;\n  turrets?: any[];\n  angle?: number;\n  type?: string; // Added for config sync\n};\n\ntype State = { ships: ShipLike[]; bullets: any[] };\n\nfunction len2(vx: number, vy: number) {\n  return vx * vx + vy * vy;\n}\nfunction clampSpeed(s: ShipLike, max: number) {\n  const v2 = len2(s.vx || 0, s.vy || 0);\n  const max2 = max * max;\n  if (v2 > max2 && v2 > 0) {\n    const inv = max / Math.sqrt(v2);\n    s.vx = (s.vx || 0) * inv;\n    s.vy = (s.vy || 0) * inv;\n  }\n}\n\nexport { clampSpeed };\n\nfunction aimWithSpread(from: ShipLike, to: ShipLike, spread = 0) {\n  let dx = (to.x || 0) - (from.x || 0);\n  let dy = (to.y || 0) - (from.y || 0);\n  const d = Math.hypot(dx, dy) || 1;\n  dx /= d;\n  dy /= d;\n  if (spread > 0) {\n    const ang = Math.atan2(dy, dx);\n    const jitter = srange(-spread, spread);\n    const na = ang + jitter;\n    return { x: Math.cos(na), y: Math.sin(na) };\n  }\n  return { x: dx, y: dy };\n}\n\nfunction tryFire(state: State, ship: ShipLike, target: ShipLike, dt: number) {\n  // Legacy cannons (single target, all fire at once)\n  if (Array.isArray(ship.cannons) && ship.cannons.length > 0) {\n    for (const c of ship.cannons) {\n      if (typeof c.__cd !== \"number\") c.__cd = 0;\n      c.__cd -= dt;\n      if (c.__cd > 0) continue;\n      const spread = typeof c.spread === \"number\" ? c.spread : 0;\n      const dir = aimWithSpread(ship, target, spread);\n      const speed = typeof c.muzzleSpeed === \"number\" ? c.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;\n      const dmg = typeof c.damage === \"number\"\n        ? c.damage\n        : typeof ship.damage === \"number\"\n          ? ship.damage\n          : typeof ship.dmg === \"number\"\n            ? ship.dmg\n            : BULLET_DEFAULTS.damage;\n      const ttl = typeof c.bulletTTL === \"number\" ? c.bulletTTL : BULLET_DEFAULTS.ttl;\n      const radius = typeof c.bulletRadius === \"number\" ? c.bulletRadius : BULLET_DEFAULTS.radius;\n      const vx = dir.x * speed;\n      const vy = dir.y * speed;\n      const b = Object.assign(\n        createBullet(\n          ship.x || 0,\n          ship.y || 0,\n          vx,\n          vy,\n          ship.team || TEAM_DEFAULT,\n          ship.id || null,\n          dmg,\n          ttl,\n        ),\n        { radius },\n      );\n      state.bullets.push(b);\n      const rate = typeof c.rate === \"number\" && c.rate > 0 ? c.rate : 1;\n      c.__cd = 1 / rate;\n    }\n  }\n  // Multi-turret support: each turret fires independently\n  if (Array.isArray(ship.turrets) && ship.turrets.length > 0) {\n    for (const [i, turret] of ship.turrets.entries()) {\n      if (!turret) continue;\n      if (typeof turret.__cd !== \"number\") turret.__cd = 0;\n      turret.__cd -= dt;\n      if (turret.__cd > 0) continue;\n      // Target selection per turret\n      let turretTarget: ShipLike | null = null;\n      if (turret.targeting === \"nearest\") {\n        const enemies = (state.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team,\n        );\n        let minDist = Infinity;\n        for (const enemy of enemies) {\n          const dx = (enemy.x || 0) - (ship.x || 0);\n          const dy = (enemy.y || 0) - (ship.y || 0);\n          const d2 = dx * dx + dy * dy;\n          if (d2 < minDist) {\n            minDist = d2;\n            turretTarget = enemy;\n          }\n        }\n      } else if (turret.targeting === \"random\") {\n        const enemies = (state.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team,\n        );\n        if (enemies.length)\n          turretTarget = enemies[Math.floor(srandom() * enemies.length)];\n      } else if (turret.targeting === \"focus\") {\n        // Use ship's main target if available\n        if (ship.__ai && ship.__ai.targetId != null) {\n          turretTarget =\n            (state.ships || []).find(\n              (sh) => sh && sh.id === ship.__ai.targetId,\n            ) || null;\n        }\n      } else {\n        // Default: nearest\n        const enemies = (state.ships || []).filter(\n          (sh) => sh && sh.team !== ship.team,\n        );\n        let minDist = Infinity;\n        for (const enemy of enemies) {\n          const dx = (enemy.x || 0) - (ship.x || 0);\n          const dy = (enemy.y || 0) - (ship.y || 0);\n          const d2 = dx * dx + dy * dy;\n          if (d2 < minDist) {\n            minDist = d2;\n            turretTarget = enemy;\n          }\n        }\n      }\n      if (!turretTarget) continue;\n      // Fire from turret position (relative to ship center, using config radius)\n      const spread = typeof turret.spread === \"number\" ? turret.spread : 0.05;\n      const dir = aimWithSpread(ship, turretTarget, spread);\n      const speed = typeof turret.muzzleSpeed === \"number\" ? turret.muzzleSpeed : BULLET_DEFAULTS.muzzleSpeed;\n      const dmg = typeof turret.damage === \"number\"\n        ? turret.damage\n        : typeof ship.damage === \"number\"\n          ? ship.damage\n          : BULLET_DEFAULTS.damage;\n      const ttl = typeof turret.bulletTTL === \"number\" ? turret.bulletTTL : BULLET_DEFAULTS.ttl;\n      const radius = typeof turret.bulletRadius === \"number\" ? turret.bulletRadius : BULLET_DEFAULTS.radius;\n      // Always use config radius for turret position\n      const angle = ship.angle || 0;\n      // Get latest config radius for this ship type\n      const shipType = ship.type || \"fighter\";\n      const shipCfg = require(\"./config/entitiesConfig\").getShipConfig()[shipType];\n      const configRadius = shipCfg && typeof shipCfg.radius === \"number\" ? shipCfg.radius : (ship.radius || 12);\n      const [tx, ty] = turret.position || [0, 0];\n      const turretX =\n        (ship.x || 0) +\n        Math.cos(angle) * tx * configRadius -\n        Math.sin(angle) * ty * configRadius;\n      const turretY =\n        (ship.y || 0) +\n        Math.sin(angle) * tx * configRadius +\n        Math.cos(angle) * ty * configRadius;\n      const vx = dir.x * speed;\n      const vy = dir.y * speed;\n      const b = Object.assign(\n        createBullet(\n          turretX,\n          turretY,\n          vx,\n          vy,\n          ship.team || TEAM_DEFAULT,\n          ship.id || null,\n          dmg,\n          ttl,\n        ),\n        { radius },\n      );\n      state.bullets.push(b);\n      turret.__cd =\n        typeof turret.cooldown === \"number\" && turret.cooldown > 0\n          ? turret.cooldown\n          : 1.0;\n    }\n  }\n}\n\nfunction ensureShipAiState(s: ShipLike) {\n  if (!s.__ai) {\n    s.__ai = { state: \"idle\", decisionTimer: 0, targetId: null };\n  }\n  return s.__ai;\n}\n\nfunction chooseNewTarget(state: State, ship: ShipLike) {\n  const enemies = (state.ships || []).filter(\n    (sh) => sh && sh.team !== ship.team,\n  );\n  if (!enemies.length) return null;\n  const idx = Math.floor(srandom() * enemies.length);\n  return enemies[idx];\n}\n\nfunction steerAway(\n  s: ShipLike,\n  tx: number,\n  ty: number,\n  accel: number,\n  dt: number,\n) {\n  const dx = (s.x || 0) - tx;\n  const dy = (s.y || 0) - ty;\n  const d = Math.hypot(dx, dy) || 1;\n  const nx = dx / d;\n  const ny = dy / d;\n  s.vx = (s.vx || 0) + nx * accel * dt;\n  s.vy = (s.vy || 0) + ny * accel * dt;\n}\n\nexport function applySimpleAI(\n  state: State,\n  dt: number,\n  bounds = { W: 800, H: 600 },\n) {\n  if (!state || !Array.isArray(state.ships)) return;\n  for (const s of state.ships) {\n    const ai = ensureShipAiState(s);\n    ai.decisionTimer = Math.max(0, (ai.decisionTimer || 0) - dt);\n\n    let target: ShipLike | null = null;\n    if (ai.targetId != null)\n      target =\n        (state.ships || []).find((sh) => sh && sh.id === ai.targetId) || null;\n    if (!target) target = chooseNewTarget(state, s);\n    if (target) ai.targetId = target.id;\n\n    // Set throttle and steering dynamically based on intent\n    const maxAccel = typeof s.accel === \"number\" ? s.accel : 100;\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\n    s.steering = typeof s.steering === \"number\" ? s.steering : 0;\n    s.throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\n\n    if (!target) {\n      // Idle: no acceleration, no steering\n      s.throttle = 0;\n      s.steering = 0;\n      ai.state = \"idle\";\n    } else {\n      if (ai.decisionTimer <= 0) {\n        const hpFrac = (s.hp || 0) / Math.max(1, s.maxHp || 1);\n        const rnd = srandom();\n        if (hpFrac < AI_THRESHOLDS.hpEvadeThreshold || rnd < AI_THRESHOLDS.randomLow) ai.state = \"evade\";\n        else if (rnd < AI_THRESHOLDS.randomHigh) ai.state = \"engage\";\n        else ai.state = \"idle\";\n        ai.decisionTimer = AI_THRESHOLDS.decisionTimerMin + srandom() * (AI_THRESHOLDS.decisionTimerMax - AI_THRESHOLDS.decisionTimerMin);\n      }\n\n      // Calculate desired angle to target\n      const dx = (target.x || 0) - (s.x || 0);\n      const dy = (target.y || 0) - (s.y || 0);\n      const desiredAngle = Math.atan2(dy, dx);\n      const currentAngle = typeof s.angle === \"number\" ? s.angle : 0;\n      let da = desiredAngle - currentAngle;\n      while (da < -Math.PI) da += Math.PI * 2;\n      while (da > Math.PI) da -= Math.PI * 2;\n      // Normalize steering to -1..1 using config\n      const steeringNorm = Math.PI / 2; // could be config if needed\n      const steering = Math.max(-1, Math.min(1, da / steeringNorm));\n\n      if (ai.state === \"engage\") {\n        s.throttle = 1;\n        s.steering = steering;\n        tryFire(state, s, target, dt);\n      } else if (ai.state === \"evade\") {\n        s.throttle = 0.8; // could be config if needed\n        // Steer away from target\n        const awayAngle = Math.atan2(\n          (s.y || 0) - (target.y || 0),\n          (s.x || 0) - (target.x || 0),\n        );\n        let daAway = awayAngle - currentAngle;\n        while (daAway < -Math.PI) daAway += Math.PI * 2;\n        while (daAway > Math.PI) daAway -= Math.PI * 2;\n        s.steering = Math.max(-1, Math.min(1, daAway / steeringNorm));\n      } else {\n        s.throttle = 0;\n        s.steering = 0;\n      }\n    }\n    clampSpeed(s, maxSpeed);\n  }\n}\n\nexport function getShipAiState(ship: ShipLike) {\n  if (!ship || !ship.__ai) return null;\n  const { targetId, ...rest } = ship.__ai;\n  return Object.assign({}, rest);\n}\n\nexport default { applySimpleAI, getShipAiState };\n", "// simulate.ts - TypeScript implementation ported from simulate.js\nimport { srange, srand, srandom } from \"./rng\";\nimport { progression as progressionCfg } from \"./config/progressionConfig\";\nimport { SIM, boundaryBehavior } from \"./config/simConfig\";\nimport { clampSpeed } from \"./behavior\";\n\nexport type Bounds = { W: number; H: number };\n\n// SIM constants migrated to simConfig.ts\n// Use SIM.DT_MS and SIM.MAX_ACC_MS instead\n\nfunction dist2(a: { x: number; y: number }, b: { x: number; y: number }) {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\n\nexport function simulateStep(state: any, dtSeconds: number, bounds: Bounds) {\n  // Advance time\n  state.t = (state.t || 0) + dtSeconds;\n\n  // Move bullets and handle boundary behavior\n  for (let i = (state.bullets || []).length - 1; i >= 0; i--) {\n    const b = state.bullets[i];\n    b.x += (b.vx || 0) * dtSeconds;\n    b.y += (b.vy || 0) * dtSeconds;\n    b.ttl = (b.ttl || 0) - dtSeconds;\n    let outX = b.x < 0 || b.x >= bounds.W;\n    let outY = b.y < 0 || b.y >= bounds.H;\n    let outOfBounds = outX || outY;\n    let remove = false;\n    if (b.ttl <= 0) remove = true;\n    else if (outOfBounds) {\n      switch (boundaryBehavior.bullets) {\n        case 'remove':\n          remove = true;\n          break;\n        case 'wrap':\n          if (b.x < 0) b.x += bounds.W;\n          if (b.x >= bounds.W) b.x -= bounds.W;\n          if (b.y < 0) b.y += bounds.H;\n          if (b.y >= bounds.H) b.y -= bounds.H;\n          break;\n        case 'bounce':\n          if (outX) {\n            b.vx = -(b.vx || 0);\n            b.x = Math.max(0, Math.min(bounds.W, b.x));\n          }\n          if (outY) {\n            b.vy = -(b.vy || 0);\n            b.y = Math.max(0, Math.min(bounds.H, b.y));\n          }\n          break;\n      }\n    }\n    if (remove) state.bullets.splice(i, 1);\n  }\n  // Prune out-of-bounds shieldHits, healthHits, explosions, damageEvents\n  function pruneHits(arr: any[], bounds: Bounds) {\n    if (!Array.isArray(arr)) return arr;\n    return arr.filter(\n      (e) =>\n        typeof e.x === \"number\" &&\n        typeof e.y === \"number\" &&\n        e.x >= 0 &&\n        e.x < bounds.W &&\n        e.y >= 0 &&\n        e.y < bounds.H,\n    );\n  }\n  if (Array.isArray(state.shieldHits))\n  // Prune particles/events after their lifetime\n  if (state.particles) {\n    state.particles = state.particles.filter((p: any) => {\n      p.life = (p.life || p.ttl || 0) - dtSeconds;\n      return p.life > 0;\n    });\n  }\n  if (state.explosions) {\n    state.explosions = state.explosions.filter((e: any) => {\n      e.life = (e.life || e.ttl || 0) - dtSeconds;\n      return e.life > 0;\n    });\n  }\n    state.shieldHits = pruneHits(state.shieldHits, bounds);\n  if (Array.isArray(state.healthHits))\n    state.healthHits = pruneHits(state.healthHits, bounds);\n  if (Array.isArray(state.explosions))\n    state.explosions = pruneHits(state.explosions, bounds);\n  if (Array.isArray(state.damageEvents))\n    state.damageEvents = pruneHits(state.damageEvents, bounds);\n\n  // Move ships and update heading\n  for (let si = (state.ships || []).length - 1; si >= 0; si--) {\n    const s = state.ships[si];\n    // --- Physics-based movement ---\n    const throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\n    const steering = typeof s.steering === \"number\" ? s.steering : 0;\n    const accel = typeof s.accel === \"number\" ? s.accel : 0;\n    const turnRate = typeof s.turnRate === \"number\" ? s.turnRate : 3;\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\n    const angle = typeof s.angle === \"number\" ? s.angle : 0;\n\n    // Update angle based on steering\n    const maxTurn = turnRate * Math.abs(steering) * dtSeconds;\n    if (steering !== 0) {\n      let a = angle + Math.sign(steering) * maxTurn;\n      while (a < -Math.PI) a += Math.PI * 2;\n      while (a > Math.PI) a -= Math.PI * 2;\n      s.angle = a;\n    }\n\n    // Update velocity based on throttle and angle\n    const actualAccel = accel * throttle;\n    if (actualAccel > 0) {\n      s.vx = (s.vx || 0) + Math.cos(s.angle || 0) * actualAccel * dtSeconds;\n      s.vy = (s.vy || 0) + Math.sin(s.angle || 0) * actualAccel * dtSeconds;\n    }\n\n    // Apply friction/damping to velocity\n    const friction = typeof s.friction === \"number\" ? s.friction : 0.98;\n    s.vx = (s.vx || 0) * friction;\n    s.vy = (s.vy || 0) * friction;\n\n    // Clamp speed using shared function\n    clampSpeed(s, maxSpeed);\n\n    // Move ship\n    s.x += (s.vx || 0) * dtSeconds;\n    s.y += (s.vy || 0) * dtSeconds;\n    // Boundary behavior for ships\n    const r = typeof s.radius === \"number\" ? s.radius : 12;\n    let outX = s.x < -r || s.x > bounds.W + r;\n    let outY = s.y < -r || s.y > bounds.H + r;\n    let outOfBounds = outX || outY;\n    let remove = false;\n    if (outOfBounds) {\n      switch (boundaryBehavior.ships) {\n        case 'remove':\n          remove = true;\n          break;\n        case 'wrap':\n          if (s.x < -r) s.x += bounds.W + r * 2;\n          if (s.x > bounds.W + r) s.x -= bounds.W + r * 2;\n          if (s.y < -r) s.y += bounds.H + r * 2;\n          if (s.y > bounds.H + r) s.y -= bounds.H + r * 2;\n          break;\n        case 'bounce':\n          if (outX) {\n            s.vx = -(s.vx || 0);\n            s.x = Math.max(-r, Math.min(bounds.W + r, s.x));\n          }\n          if (outY) {\n            s.vy = -(s.vy || 0);\n            s.y = Math.max(-r, Math.min(bounds.H + r, s.y));\n          }\n          break;\n      }\n    }\n    if (remove) state.ships.splice(si, 1);\n  }\n\n  // Bullet collisions\n  for (let bi = (state.bullets || []).length - 1; bi >= 0; bi--) {\n    const b = state.bullets[bi];\n    for (let si = (state.ships || []).length - 1; si >= 0; si--) {\n      const s = state.ships[si];\n      if (s.team === b.team) continue;\n      const r = (s.radius || 6) + (b.radius || 1);\n      if (dist2(b, s) <= r * r) {\n        const attacker =\n          typeof b.ownerId === \"number\" || typeof b.ownerId === \"string\"\n            ? (state.ships || []).find((sh: any) => sh.id === b.ownerId)\n            : undefined;\n        let dealtToShield = 0;\n        let dealtToHealth = 0;\n        const shield = s.shield || 0;\n        if (shield > 0) {\n          const absorbed = Math.min(shield, b.damage || 0);\n          s.shield = shield - absorbed;\n          const hitAngle = Math.atan2(\n            (b.y || 0) - (s.y || 0),\n            (b.x || 0) - (s.x || 0),\n          );\n          (state.shieldHits ||= []).push({\n            id: s.id,\n            hitX: b.x,\n            hitY: b.y,\n            team: s.team,\n            amount: absorbed,\n            hitAngle,\n          });\n          // expose damage event for renderer (shield hit)\n          (state.damageEvents ||= []).push({\n            id: s.id,\n            type: \"shield\",\n            amount: absorbed,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            attackerId: attacker && attacker.id,\n          });\n          const remaining = (b.damage || 0) - absorbed;\n          if (remaining > 0) {\n            s.hp -= remaining;\n            (state.healthHits ||= []).push({\n              id: s.id,\n              hitX: b.x,\n              hitY: b.y,\n              team: s.team,\n              amount: remaining,\n            });\n            // expose damage event for renderer (health hit)\n            (state.damageEvents ||= []).push({\n              id: s.id,\n              type: \"hp\",\n              amount: remaining,\n              x: b.x,\n              y: b.y,\n              team: s.team,\n              attackerId: attacker && attacker.id,\n            });\n          }\n          dealtToShield = absorbed;\n          dealtToHealth = Math.max(0, (b.damage || 0) - absorbed);\n        } else {\n          s.hp -= b.damage || 0;\n          (state.healthHits ||= []).push({\n            id: s.id,\n            hitX: b.x,\n            hitY: b.y,\n            team: s.team,\n            amount: b.damage || 0,\n          });\n          // expose damage event for renderer (health hit)\n          (state.damageEvents ||= []).push({\n            id: s.id,\n            type: \"hp\",\n            amount: b.damage || 0,\n            x: b.x,\n            y: b.y,\n            team: s.team,\n            attackerId: attacker && attacker.id,\n          });\n          dealtToHealth = b.damage || 0;\n        }\n\n        // Update percent fields for renderer convenience\n        s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n        s.shieldPercent =\n          typeof s.maxShield === \"number\" && s.maxShield > 0\n            ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield))\n            : 0;\n        // XP for damage\n        if (attacker) {\n          attacker.xp =\n            (attacker.xp || 0) +\n            (dealtToShield + dealtToHealth) * (progressionCfg.xpPerDamage || 0);\n          while (\n            (attacker.xp || 0) >= progressionCfg.xpToLevel(attacker.level || 1)\n          ) {\n            attacker.xp -= progressionCfg.xpToLevel(attacker.level || 1);\n            attacker.level = (attacker.level || 1) + 1;\n            // Support function or number scalars for progression\n            const resolveScalar = (s: any, lvl: number) =>\n              typeof s === \"function\" ? s(lvl) : s || 0;\n            const lvl = attacker.level || 1;\n            const hpScalar = resolveScalar(\n              progressionCfg.hpPercentPerLevel,\n              lvl,\n            );\n            const shScalar = resolveScalar(\n              progressionCfg.shieldPercentPerLevel,\n              lvl,\n            );\n            const dmgScalar = resolveScalar(\n              progressionCfg.dmgPercentPerLevel,\n              lvl,\n            );\n            const speedScalar = resolveScalar(\n              (progressionCfg as any).speedPercentPerLevel,\n              lvl,\n            );\n            const regenScalar = resolveScalar(\n              (progressionCfg as any).regenPercentPerLevel,\n              lvl,\n            );\n\n            const hpMul = 1 + hpScalar;\n            const shMul = 1 + shScalar;\n            const dmgMul = 1 + dmgScalar;\n\n            attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n            attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);\n            if (typeof attacker.maxShield === \"number\") {\n              attacker.maxShield = (attacker.maxShield || 0) * shMul;\n              attacker.shield = Math.min(\n                attacker.maxShield,\n                (attacker.shield || 0) * shMul,\n              );\n            }\n            if (Array.isArray(attacker.cannons)) {\n              for (const c of attacker.cannons) {\n                if (typeof c.damage === \"number\") c.damage *= dmgMul;\n              }\n            }\n            // Apply optional speed and shield regen increases\n            if (\n              typeof speedScalar === \"number\" &&\n              typeof attacker.accel === \"number\"\n            )\n              attacker.accel = attacker.accel * (1 + speedScalar);\n            if (\n              typeof regenScalar === \"number\" &&\n              typeof attacker.shieldRegen === \"number\"\n            )\n              attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n          }\n        }\n        state.bullets.splice(bi, 1);\n        if (s.hp <= 0) {\n          // eslint-disable-next-line no-console\n          console.log(\n            \"DEBUG: KILL BRANCH, attacker\",\n            attacker && attacker.id,\n            \"xp before\",\n            attacker && attacker.xp,\n          );\n          if (attacker) {\n            attacker.xp = (attacker.xp || 0) + (progressionCfg.xpPerKill || 0);\n            // eslint-disable-next-line no-console\n            console.log(\n              \"DEBUG: KILL XP AWARDED, attacker\",\n              attacker.id,\n              \"xp after\",\n              attacker.xp,\n            );\n            while (\n              (attacker.xp || 0) >=\n              progressionCfg.xpToLevel(attacker.level || 1)\n            ) {\n              attacker.xp -= progressionCfg.xpToLevel(attacker.level || 1);\n              attacker.level = (attacker.level || 1) + 1;\n              // Support function or number scalars for progression on kill XP\n              const resolveScalar = (s: any, lvl: number) =>\n                typeof s === \"function\" ? s(lvl) : s || 0;\n              const lvl = attacker.level || 1;\n              const hpScalar = resolveScalar(\n                progressionCfg.hpPercentPerLevel,\n                lvl,\n              );\n              const shScalar = resolveScalar(\n                progressionCfg.shieldPercentPerLevel,\n                lvl,\n              );\n              const dmgScalar = resolveScalar(\n                progressionCfg.dmgPercentPerLevel,\n                lvl,\n              );\n              const speedScalar = resolveScalar(\n                (progressionCfg as any).speedPercentPerLevel,\n                lvl,\n              );\n              const regenScalar = resolveScalar(\n                (progressionCfg as any).regenPercentPerLevel,\n                lvl,\n              );\n\n              const hpMul = 1 + hpScalar;\n              const shMul = 1 + shScalar;\n              const dmgMul = 1 + dmgScalar;\n              attacker.maxHp = (attacker.maxHp || 0) * hpMul;\n              attacker.hp = Math.min(\n                attacker.maxHp,\n                (attacker.hp || 0) * hpMul,\n              );\n              if (typeof attacker.maxShield === \"number\") {\n                attacker.maxShield = (attacker.maxShield || 0) * shMul;\n                attacker.shield = Math.min(\n                  attacker.maxShield,\n                  (attacker.shield || 0) * shMul,\n                );\n              }\n              if (Array.isArray(attacker.cannons)) {\n                for (const c of attacker.cannons) {\n                  if (typeof c.damage === \"number\") c.damage *= dmgMul;\n                }\n              }\n              // Apply optional speed and shield regen increases\n              if (\n                typeof speedScalar === \"number\" &&\n                typeof attacker.accel === \"number\"\n              )\n                attacker.accel = attacker.accel * (1 + speedScalar);\n              if (\n                typeof regenScalar === \"number\" &&\n                typeof attacker.shieldRegen === \"number\"\n              )\n                attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\n            }\n          }\n          (state.explosions ||= []).push({ x: s.x, y: s.y, team: s.team });\n          state.ships.splice(si, 1);\n        }\n        break;\n      }\n    }\n  }\n\n  // Shield regen\n  for (const s of state.ships || []) {\n    if (s.maxShield)\n      s.shield = Math.min(\n        s.maxShield,\n        (s.shield || 0) + (s.shieldRegen || 0) * dtSeconds,\n      );\n  }\n\n  // refresh percent convenience fields after regen\n  for (const s of state.ships || []) {\n    s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\n    s.shieldPercent =\n      typeof s.maxShield === \"number\" && s.maxShield > 0\n        ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield))\n        : 0;\n  }\n\n  return state;\n}\n\nexport default { simulateStep };\n", "// src/simWorker.ts - simulation worker implementation (compiled to JS and loaded as module Worker)\r\nimport { simulateStep } from './simulate';\r\nimport { applySimpleAI } from './behavior';\r\nimport { srand } from './rng';\r\nimport type { /* Bounds type can be extended in src/types if needed */ } from './types';\r\n\r\ntype Bounds = { W: number; H: number };\r\n\r\nlet state: any = null;\r\nlet bounds: Bounds = { W: 800, H: 600 };\r\nlet simDtMs = 16;\r\nlet running = false;\r\nlet acc = 0;\r\nlet last = 0;\r\n\r\nfunction postSnapshot() {\r\n\ttry {\r\n\t\tpostMessage({ type: 'snapshot', state });\r\n\t\t// Clear transient event arrays so the worker does not repeatedly resend\r\n\t\t// the same events on every snapshot. The snapshot is cloned by postMessage\r\n\t\t// so it's safe to clear them here.\r\n\t\ttry { clearTransientEvents(state); } catch (e) { /* ignore */ }\r\n\t} catch (e) {\r\n\t\t// ignore\r\n\t}\r\n}\r\n\r\n// exported for tests: clear transient worker event arrays after snapshot\r\nexport function clearTransientEvents(s: any) {\r\n  if (!s || typeof s !== 'object') return;\r\n  try {\r\n    if (Array.isArray(s.explosions)) s.explosions.length = 0;\r\n    if (Array.isArray(s.shieldHits)) s.shieldHits.length = 0;\r\n    if (Array.isArray(s.healthHits)) s.healthHits.length = 0;\r\n  } catch (e) { /* ignore */ }\r\n}\r\n\r\nfunction tick() {\r\n\tif (!running) return;\r\n\tconst now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();\r\n\tif (!last) last = now;\r\n\tacc += now - last; last = now;\r\n\tif (acc > 250) acc = 250;\r\n\t\twhile (acc >= simDtMs) {\r\n\t\t\ttry {\r\n\t\t\t\t\t// Apply deterministic AI before physics step\r\n\t\t\t\t\tapplySimpleAI(state as any, simDtMs / 1000, bounds);\r\n\t\t\t\t\tsimulateStep(state, simDtMs / 1000, bounds);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconst errAny: any = e as any;\r\n\t\t\t\tconst stack = errAny && errAny.stack ? errAny.stack : '';\r\n\t\t\t\tpostMessage({ type: 'error', message: String(e), stack });\r\n\t\t\t}\r\n\t\t\tacc -= simDtMs;\r\n\t\t}\r\n\tpostSnapshot();\r\n\tsetTimeout(tick, 0);\r\n}\r\n\r\n(self as any).onmessage = (ev: MessageEvent) => {\r\n\tconst msg = ev.data;\r\n\ttry {\r\n\t\tswitch (msg && msg.type) {\r\n\t\t\tcase 'init':\r\n\t\t\t\tif (typeof msg.seed === 'number') srand(msg.seed);\r\n\t\t\t\tif (msg.bounds) bounds = msg.bounds;\r\n\t\t\t\tif (typeof msg.simDtMs === 'number') simDtMs = msg.simDtMs;\r\n\t\t\t\tif (msg.state) state = msg.state;\r\n\t\t\t\tpostMessage({ type: 'ready' });\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'start':\r\n\t\t\t\tif (!state) { postMessage({ type: 'error', message: 'no state' }); break; }\r\n\t\t\t\trunning = true; acc = 0; last = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); tick();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'stop':\r\n\t\t\t\trunning = false; break;\r\n\t\t\tcase 'snapshotRequest':\r\n\t\t\t\tpostSnapshot(); break;\r\n\t\t\tcase 'setSeed':\r\n\t\t\t\tif (typeof msg.seed === 'number') { srand(msg.seed); }\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'command':\r\n\t\t\t\tif (msg.cmd === 'spawnShip' && state) {\r\n\t\t\t\t\tstate.ships.push(msg.args.ship);\r\n\t\t\t\t} else if (msg.cmd === 'spawnShipBullet' && state) {\r\n\t\t\t\t\tstate.bullets.push(msg.args.bullet);\r\n\t\t\t\t} else if (msg.cmd === 'setState') {\r\n\t\t\t\t\tstate = msg.args.state;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// ignore\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t} catch (err: any) {\r\n\t\t\tconst stack = err && (err as any).stack ? (err as any).stack : '';\r\n\t\t\tpostMessage({ type: 'error', message: String(err), stack });\r\n\t\t}\r\n};\r\n\r\nexport default null;\r\n"],
  "mappings": "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",
  "names": ["state", "state", "bounds", "state", "bounds", "s", "lvl"]
}
