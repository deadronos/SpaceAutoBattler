{
  "version": 3,
  "sources": ["../src/rng.ts", "../src/config/entitiesConfig.ts", "../src/config/simConfig.ts", "../src/config/teamsConfig.ts", "../src/pools/pool.ts", "../src/entities.ts", "../src/config/assets/assetsConfig.ts", "../src/config/progressionConfig.ts", "../src/pools/PoolManager.ts", "../src/pools/assetPool.ts", "../src/config/gamemanagerConfig.ts", "../src/gamemanager.ts", "../src/config/behaviorConfig.ts", "../src/behavior.ts", "../src/spatialGrid.ts", "../src/simulate.ts", "../src/simWorker.ts"],
  "sourcesContent": ["// src/rng.ts - Seeded RNG utilities (ported from rng.js)\r\nlet _seed = 1;\r\n\r\nexport function srand(seed: number = 1) {\r\n  // store as 32-bit unsigned\r\n  _seed = seed >>> 0;\r\n}\r\n\r\n// mulberry32 PRNG\r\nfunction mulberry32(a: number) {\r\n  return function() {\r\n    let t = (a += 0x6D2B79F5) >>> 0;\r\n    t = Math.imul(t ^ (t >>> 15), t | 1);\r\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\r\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n  };\r\n}\r\n\r\nexport function srandom(): number {\r\n  const f = mulberry32(_seed);\r\n  // advance seed deterministically\r\n  _seed = (_seed + 0x9E3779B1) >>> 0;\r\n  return f();\r\n}\r\n\r\nexport function srange(min: number, max: number): number {\r\n  return min + (max - min) * srandom();\r\n}\r\n\r\nexport function srangeInt(min: number, max: number): number {\r\n  // exclusive upper bound to match expectations\r\n  return Math.floor(srange(min, max));\r\n}\r\n\r\nexport default { srand, srandom, srange, srangeInt };\r\n", "// entitiesConfig.ts - ship-type defaults and visuals helpers (typed)\r\n//\r\n// Tuning rationale (2025-08-24):\r\n// - Playfield size: 1920x1080\r\n// - Ship speeds (maxSpeed, accel): Higher speed enables kiting and rapid repositioning; slower ships are easier to flank.\r\n// - Turn rates (turnRate): Higher turn rate allows ships to evade, flank, and respond to threats quickly; low turn rate makes ships vulnerable to flanking.\r\n// - Weapon ranges (muzzleSpeed * bulletTTL): Longer range supports kiting and edge play; shorter range requires close engagement and rewards flanking.\r\n// - Weapon rate (rate): Higher fire rate enables sustained pressure and kiting; lower rate rewards timing and positioning.\r\n// - Ship radius: Larger ships are easier to hit and harder to flank; smaller ships excel at flanking and evasion.\r\n// - Boundary options (see simConfig.ts): Enable edge play (wrap, bounce, remove) for tactical escapes and repositioning.\r\n// - See patch history for details\r\nimport {\r\n  getShipAsset,\r\n  getBulletAsset,\r\n  getTurretAsset,\r\n} from \"./assets/assetsConfig\";\r\n\r\n// CannonCfg parameters and tactical impact:\r\n// - damage: Higher damage increases threat, rewards flanking and burst attacks.\r\n// - rate: Higher rate supports kiting and pressure; lower rate rewards timing.\r\n// - spread: More spread makes weapons less accurate, favors close-range flanking.\r\n// - muzzleSpeed: Higher speed increases range and kiting potential.\r\n// - bulletRadius: Larger radius makes shots easier to land, favors area denial.\r\n// - bulletTTL: Longer TTL increases range, supports edge play and kiting.\r\nexport type CannonCfg = {\r\n  damage: number;\r\n  rate: number;\r\n  spread?: number;\r\n  muzzleSpeed?: number;\r\n  bulletRadius?: number;\r\n  bulletTTL?: number;\r\n  // optional per-weapon effective range (units). If omitted, engine uses muzzleSpeed*bulletTTL or BULLET_DEFAULTS.range\r\n  range?: number;\r\n};\r\n\r\n// ShipTypeCfg parameters and tactical impact:\r\n// - maxHp, armor, maxShield: Higher values increase survivability, allow for riskier flanking and edge play.\r\n// - shieldRegen: Faster regen supports hit-and-run and kiting.\r\n// - damage/dmg: Higher damage rewards successful flanking and burst attacks.\r\n// - radius: Smaller radius makes ships harder to hit and better at flanking; larger radius increases vulnerability.\r\n// - cannons: Weapon loadout affects tactical options (see CannonCfg).\r\n// - accel: Higher acceleration enables rapid repositioning and kiting.\r\n// - turnRate: Higher turn rate allows for quick flanking, evasion, and edge play.\r\n// - maxSpeed: Higher speed supports kiting and edge escapes; lower speed makes ships easier to pursue and flank.\r\n// - turrets: Multiple turrets increase area control, make flanking harder.\r\n// - friction: Lower friction (closer to 1) enables sustained velocity for kiting and edge play; higher friction increases tactical vulnerability to pursuit and flanking.\r\n// All entities and events are pruned immediately upon destruction or expiration, ensuring tactical scenarios remain robust and consistent.\r\nexport type ShipTypeCfg = {\r\n  maxHp: number;\r\n  armor?: number;\r\n  maxShield?: number;\r\n  shieldRegen?: number;\r\n  // size classification for tuning: 'small' | 'medium' | 'large'\r\n  size?: \"small\" | \"medium\" | \"large\";\r\n  dmg?: number;\r\n  damage?: number;\r\n  radius?: number;\r\n  cannons?: CannonCfg[];\r\n  accel?: number;\r\n  turnRate?: number;\r\n  maxSpeed?: number;\r\n  carrier?: {\r\n    fighterCooldown: number;\r\n    maxFighters: number;\r\n    spawnPerCooldown: number;\r\n  };\r\n  turrets?: Array<{\r\n    position: [number, number]; // relative to ship center, in radius units\r\n    kind: string; // turret asset kind\r\n    targeting?: \"nearest\" | \"random\" | \"focus\" | \"custom\"; // targeting logic\r\n    cooldown?: number; // seconds between shots\r\n    lastFired?: number; // timestamp of last shot\r\n    // optional turret firing range (units)\r\n    range?: number;\r\n  }>;\r\n};\r\n\r\nexport type ShipConfigMap = Record<string, ShipTypeCfg>;\r\n\r\nexport const ShipConfig: ShipConfigMap = {\r\n  fighter: {\r\n    maxHp: 15,\r\n    // size classification used for armor/shield tuning\r\n    size: \"small\",\r\n    armor: 0,\r\n    maxShield: 8,\r\n    shieldRegen: 1.0,\r\n    dmg: 3,\r\n    damage: 3,\r\n    radius: 12,\r\n    cannons: [\r\n      {\r\n        damage: 3,\r\n        rate: 3,\r\n        spread: 0.1,\r\n        muzzleSpeed: 260, // reduced back (/10)\r\n        bulletRadius: 1.5,\r\n        bulletTTL: 1.1, // was 1.2\r\n        // effective range (muzzleSpeed * bulletTTL) scaled to engine units\r\n        range: Math.round(260 * 1.1),\r\n      },\r\n    ],\r\n\r\n    // Refined tuning: slightly higher accel and a moderate maxSpeed for clearer motion\r\n    accel: 100, // ~10x accel\r\n    turnRate: 6,\r\n    maxSpeed: 2200, // ~10x maxSpeed\r\n  },\r\n  corvette: {\r\n    maxHp: 50,\r\n    size: \"medium\",\r\n    armor: 0,\r\n    maxShield: Math.round(50 * 0.6),\r\n    shieldRegen: 0.5,\r\n    dmg: 5,\r\n    damage: 5,\r\n    radius: 20,\r\n    accel: 80,\r\n    turnRate: 3.5, // was 3\r\n    maxSpeed: 1800, // ~10x increased\r\n    cannons: [\r\n      {\r\n        damage: 6,\r\n        rate: 1.2,\r\n        spread: 0.05,\r\n        muzzleSpeed: 180, // reduced back (/10)\r\n        bulletRadius: 2,\r\n        bulletTTL: 1.8, // was 2.0\r\n        range: Math.round(180 * 1.8),\r\n      },\r\n    ],\r\n  },\r\n  frigate: {\r\n    maxHp: 80,\r\n    size: \"medium\",\r\n    armor: 1,\r\n    maxShield: Math.round(80 * 0.6),\r\n    shieldRegen: 0.4,\r\n    dmg: 8,\r\n    damage: 8,\r\n    radius: 24,\r\n    cannons: [\r\n      {\r\n        damage: 8,\r\n        rate: 1.0,\r\n        spread: 0.06,\r\n        muzzleSpeed: 180, // reduced back (/10)\r\n        bulletRadius: 2.5,\r\n        bulletTTL: 2.0, // was 2.2\r\n        range: Math.round(180 * 2.0),\r\n      },\r\n    ],\r\n    accel: 70,\r\n    turnRate: 2.5, // was 2.2\r\n    maxSpeed: 1500, // ~10x increased\r\n  },\r\n  destroyer: {\r\n    maxHp: 120,\r\n    size: \"large\",\r\n    armor: 2,\r\n    maxShield: Math.round(120 * 0.6),\r\n    shieldRegen: 0.3,\r\n    dmg: 12,\r\n    damage: 12,\r\n    radius: 40,\r\n    cannons: new Array(6).fill(0).map(() => ({\r\n      damage: 6,\r\n      rate: 0.8,\r\n      spread: 0.08,\r\n      muzzleSpeed: 160, // reduced back (/10)\r\n      bulletRadius: 2.5,\r\n      bulletTTL: 1.8, // was 2.4\r\n      range: Math.round(160 * 1.8),\r\n    })),\r\n    accel: 60,\r\n    turnRate: 2.0, // was 1.6\r\n    maxSpeed: 1300, // ~10x increased\r\n    turrets: [\r\n      {\r\n        position: [1.2, 0.8],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n        // turret effective range (units)\r\n        range: 300,\r\n      },\r\n      {\r\n        position: [-1.2, 0.8],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n      },\r\n      {\r\n        position: [1.2, -0.8],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n      },\r\n      {\r\n        position: [-1.2, -0.8],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n      },\r\n      {\r\n        position: [0, 1.5],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n      },\r\n      {\r\n        position: [0, -1.5],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 0.8,\r\n      },\r\n    ],\r\n  },\r\n  carrier: {\r\n    maxHp: 200,\r\n    size: \"large\",\r\n    armor: 3,\r\n    maxShield: Math.round(200 * 0.6),\r\n    shieldRegen: 0.2,\r\n    dmg: 2,\r\n    damage: 2,\r\n    radius: 40,\r\n    cannons: new Array(4).fill(0).map(() => ({\r\n      damage: 4,\r\n      rate: 0.6,\r\n      spread: 0.12,\r\n      muzzleSpeed: 140, // reduced back (/10)\r\n      bulletRadius: 3,\r\n      bulletTTL: 2.2, // was 2.8\r\n      range: Math.round(140 * 2.2),\r\n    })),\r\n    accel: 55,\r\n    turnRate: 1.2, // was 0.8\r\n    maxSpeed: 1100, // ~10x increased\r\n    carrier: { fighterCooldown: 1.5, maxFighters: 6, spawnPerCooldown: 2 },\r\n    turrets: [\r\n      {\r\n        position: [2.0, 1.2],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 1.0,\r\n        range: 300,\r\n      },\r\n      {\r\n        position: [-2.0, 1.2],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 1.0,\r\n      },\r\n      {\r\n        position: [2.0, -1.2],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 1.0,\r\n      },\r\n      {\r\n        position: [-2.0, -1.2],\r\n        kind: \"basic\",\r\n        targeting: \"nearest\",\r\n        cooldown: 1.0,\r\n      },\r\n    ],\r\n  },\r\n};\r\n\r\n// Per-size defaults to provide consistent tuning shortcuts. These values are\r\n// applied when a ShipTypeCfg omits explicit armor/shield tuning. They make it\r\n// easy to adjust broad balance by class (small/medium/large) in one place.\r\nexport const SIZE_DEFAULTS: Record<\r\n  \"small\" | \"medium\" | \"large\",\r\n  Partial<ShipTypeCfg>\r\n> = {\r\n  small: {\r\n    armor: 0,\r\n    maxShield: 8,\r\n    shieldRegen: 1.0,\r\n    radius: 12,\r\n    turnRate: 6,\r\n    accel: 100,\r\n    maxSpeed: 2200,\r\n  },\r\n  medium: {\r\n    armor: 1,\r\n    maxShield: 40,\r\n    shieldRegen: 0.5,\r\n    radius: 24,\r\n    turnRate: 3.5,\r\n    accel: 80,\r\n    maxSpeed: 1800,\r\n  },\r\n  large: {\r\n    armor: 2,\r\n    maxShield: 120,\r\n    shieldRegen: 0.25,\r\n    radius: 40,\r\n    turnRate: 2.0,\r\n    accel: 60,\r\n    maxSpeed: 1300,\r\n  },\r\n};\r\n\r\nexport function getSizeDefaults(size: \"small\" | \"medium\" | \"large\") {\r\n  return SIZE_DEFAULTS[size] || SIZE_DEFAULTS.small;\r\n}\r\n\r\n// Runtime configuration helpers: update per-size defaults in-place.\r\nexport function setSizeDefaults(\r\n  size: \"small\" | \"medium\" | \"large\",\r\n  patch: Partial<ShipTypeCfg>,\r\n) {\r\n  SIZE_DEFAULTS[size] = Object.assign({}, SIZE_DEFAULTS[size], patch);\r\n}\r\n\r\nexport function setAllSizeDefaults(patch: Partial<ShipTypeCfg>) {\r\n  SIZE_DEFAULTS.small = Object.assign({}, SIZE_DEFAULTS.small, patch);\r\n  SIZE_DEFAULTS.medium = Object.assign({}, SIZE_DEFAULTS.medium, patch);\r\n  SIZE_DEFAULTS.large = Object.assign({}, SIZE_DEFAULTS.large, patch);\r\n}\r\n// NOTE: The factory that creates Ship objects (`createShip` in src/entities.ts)\r\n// enforces a positive fallback for `maxSpeed` when the config is missing or\r\n// set to 0. This guards against malformed saved state or partial config\r\n// payloads which would otherwise clamp ship velocity to 0 and prevent\r\n// translation while still allowing rotation/firing (a common source of\r\n// confusing \"ships rotate and shoot but don't move\" bugs).\r\nexport function getShipConfig() {\r\n  // Normalize weapon ranges at runtime so configs may omit 'range'.\r\n  // For cannons: range = Math.round(muzzleSpeed * bulletTTL) or BULLET_DEFAULTS.range\r\n  // For turrets: if missing, inherit first cannon range or BULLET_DEFAULTS.range\r\n  Object.keys(ShipConfig).forEach((key) => {\r\n    const cfg = ShipConfig[key];\r\n    if (cfg.cannons) {\r\n      cfg.cannons.forEach((c) => {\r\n        if (c.range == null) {\r\n          const ms = c.muzzleSpeed ?? BULLET_DEFAULTS.muzzleSpeed;\r\n          const ttl = c.bulletTTL ?? BULLET_DEFAULTS.ttl;\r\n          const computed =\r\n            Number.isFinite(ms) && Number.isFinite(ttl)\r\n              ? Math.round(ms * ttl)\r\n              : BULLET_DEFAULTS.range;\r\n          c.range = computed || BULLET_DEFAULTS.range;\r\n        }\r\n      });\r\n    }\r\n    // Turret range fallback: prefer existing turret.range, else try first cannon, else BULLET_DEFAULTS.range\r\n    if (cfg.turrets) {\r\n      const firstCannonRange =\r\n        cfg.cannons && cfg.cannons.length\r\n          ? cfg.cannons[0].range || BULLET_DEFAULTS.range\r\n          : BULLET_DEFAULTS.range;\r\n      cfg.turrets.forEach((t) => {\r\n        if (t.range == null) {\r\n          t.range = firstCannonRange;\r\n        }\r\n      });\r\n    }\r\n  });\r\n  return ShipConfig;\r\n}\r\n\r\n// Bullet global defaults (used if not per-ship)\r\nexport const BULLET_DEFAULTS = {\r\n  damage: 1,\r\n  ttl: 2.0,\r\n  radius: 1.5,\r\n  muzzleSpeed: 24,\r\n  // default effective range (units)\r\n  range: 300,\r\n};\r\n\r\n// Particle defaults (used for generic effects)\r\nexport const PARTICLE_DEFAULTS = {\r\n  ttl: 1,\r\n  color: \"#fff\",\r\n  size: 2,\r\n};\r\n\r\n// Team fallback default\r\n\r\nexport function bulletKindForRadius(r: number): string {\r\n  if (r < 2) return \"small\";\r\n  if (r < 2.5) return \"medium\";\r\n  if (r < 3.5) return \"large\";\r\n  return \"heavy\";\r\n}\r\n\r\nexport function getDefaultShipType(): string {\r\n  return Object.keys(ShipConfig)[0] || \"fighter\";\r\n}\r\n\r\nexport default ShipConfig;\r\n", "import type { BoundaryBehavior } from \"./types\";\r\n\r\nexport interface SimConfig {\r\n  DT_MS: number;\r\n  MAX_ACC_MS: number;\r\n  bounds: { W: number; H: number };\r\n  friction: number; // Velocity damping factor for ships\r\n  gridCellSize?: number; // spatial grid cell size (px)\r\n}\r\n\r\nexport const SIM: SimConfig = {\r\n  DT_MS: 16,\r\n  MAX_ACC_MS: 250,\r\n  bounds: { W: 1920, H: 1080 }, // Use LOGICAL_MAP for default bounds\r\n  friction: 0.99,\r\n  gridCellSize: 64,\r\n};\r\n// boundaryBehavior: Tactical impact and pruning rationale\r\n// - 'remove': Ships/bullets are eliminated at map edge; punishes edge play, rewards central control. Pruning is immediate for out-of-bounds entities.\r\n// - 'wrap': Ships/bullets reappear on opposite edge; enables edge escapes, flanking via wrap, and kiting around boundaries. Pruning only occurs for expired entities.\r\n// - 'bounce': Ships/bullets reflect off edge; supports tactical repositioning, edge denial, and hit-and-run. Pruning is immediate for expired entities.\r\n// All entities, particles, and events are pruned immediately upon destruction, expiration, or leaving bounds, ensuring robust cleanup and tactical consistency.\r\nexport const boundaryBehavior: {\r\n  ships: BoundaryBehavior;\r\n  bullets: BoundaryBehavior;\r\n} = {\r\n  ships: \"wrap\",\r\n  bullets: \"remove\",\r\n};\r\n\r\nexport const progression = {\r\n  xpPerDamage: 1,\r\n  xpPerKill: 50,\r\n  xpToLevel: (level: number) => 100 + level * 50,\r\n};\r\n\r\nexport const LOGICAL_MAP = { W: 1920, H: 1080 };\r\n\r\nexport function getDefaultBounds() {\r\n  // Fixed logical map size for simulation and rendering\r\n  return { W: LOGICAL_MAP.W, H: LOGICAL_MAP.H };\r\n}\r\n\r\nexport default {\r\n  SIM,\r\n  progression,\r\n  boundaryBehavior,\r\n  LOGICAL_MAP,\r\n  getDefaultBounds,\r\n};\r\n", "// teamsConfig.ts - Teams and fleet helpers (typed)\r\nimport { getDefaultShipType, getShipConfig } from \"./entitiesConfig\"; // should be './config/entitiesConfig'\r\nimport { getDefaultBounds } from \"./simConfig\";\r\nexport type Team = { id: string; color: string; label?: string };\r\nexport const TeamsConfig = {\r\n  teams: {\r\n    red: { id: \"red\", color: \"#ff4d4d\", label: \"Red\" },\r\n    blue: { id: \"blue\", color: \"#4da6ff\", label: \"Blue\" },\r\n  },\r\n  defaultFleet: {\r\n    counts: (() => {\r\n      // Build a default counts map from available ShipConfig types so new\r\n      // ship types are automatically included without needing manual edits.\r\n      const shipCfg = getShipConfig();\r\n      const types = Object.keys(shipCfg || {});\r\n      // sane defaults: make fighters most common, others rarer\r\n      const defaultCounts: Record<string, number> = {};\r\n      for (const t of types) {\r\n        if (t === \"fighter\") defaultCounts[t] = 8;\r\n        else if (t === \"corvette\") defaultCounts[t] = 3;\r\n        else if (t === \"frigate\") defaultCounts[t] = 2;\r\n        else if (t === \"destroyer\") defaultCounts[t] = 1;\r\n        else if (t === \"carrier\") defaultCounts[t] = 1;\r\n        else defaultCounts[t] = 1;\r\n      }\r\n      return defaultCounts;\r\n    })(),\r\n    spacing: 28,\r\n    jitter: { x: 80, y: 120 },\r\n  },\r\n  // continuousReinforcement controls: enable/disable, scoreMargin is the\r\n  // imbalance fraction (e.g. 0.12 means reinforce when weakest ratio < 0.38),\r\n  // perTick is the maximum ships considered per reinforcement tick, and\r\n  // shipTypes is an optional array of types to choose from randomly. If\r\n  // omitted, keys from defaultFleet.counts are used.\r\n  continuousReinforcement: {\r\n    enabled: false,\r\n    scoreMargin: 0.12,\r\n    perTick: 1,\r\n    interval: 5.0,\r\n    shipTypes: undefined as string[] | undefined,\r\n  },\r\n};\r\n\r\n// Local seeded PRNG (does not affect global rng)\r\nfunction mulberry32(seed: number) {\r\n  let t = seed >>> 0;\r\n  return function () {\r\n    t += 0x6d2b79f5;\r\n    let r = Math.imul(t ^ (t >>> 15), 1 | t);\r\n    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);\r\n    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;\r\n  };\r\n}\r\n\r\nfunction hashStringToInt(s: string) {\r\n  let h = 2166136261 >>> 0;\r\n  for (let i = 0; i < s.length; i++) {\r\n    h ^= s.charCodeAt(i);\r\n    h = Math.imul(h, 16777619) >>> 0;\r\n  }\r\n  return h >>> 0;\r\n}\r\n\r\nexport function generateFleetForTeam(\r\n  seed = 0,\r\n  teamId: \"red\" | \"blue\" = \"red\",\r\n  bounds?: { W: number; H: number },\r\n  shipFactory?: (type: string, x: number, y: number, team: string) => any,\r\n  options: any = {},\r\n) {\r\n  const b = bounds || getDefaultBounds();\r\n  const cfg = Object.assign({}, TeamsConfig.defaultFleet, options.fleet || {});\r\n  const spacing = options.spacing ?? cfg.spacing;\r\n  const jitter = Object.assign({}, cfg.jitter, options.jitter || {});\r\n  const centerY = b.H / 2;\r\n  const baseX = teamId === \"red\" ? b.W * 0.22 : b.W * 0.78;\r\n  const rng = mulberry32((seed >>> 0) + hashStringToInt(teamId));\r\n  const out: any[] = [];\r\n  for (const [type, count] of Object.entries(cfg.counts)) {\r\n    for (let i = 0; i < (count as number); i++) {\r\n      const r = spacing * Math.sqrt(rng());\r\n      const angle = rng() * Math.PI * 2;\r\n      const dx = Math.cos(angle) * r + (rng() - 0.5) * (jitter.x ?? 0);\r\n      const dy = Math.sin(angle) * r + (rng() - 0.5) * (jitter.y ?? 0);\r\n  const x = Math.max(0, Math.min(b.W - 1e-6, baseX + dx));\r\n  const y = Math.max(0, Math.min(b.H - 1e-6, centerY + dy));\r\n      if (typeof shipFactory === \"function\")\r\n        out.push(shipFactory(type, x, y, teamId));\r\n      else out.push({ type, x, y, team: teamId });\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function makeInitialFleets(\r\n  seed = 0,\r\n  bounds?: { W: number; H: number },\r\n  shipFactory?: (type: string, x: number, y: number, team: string) => any,\r\n  options: any = {},\r\n) {\r\n  const b = bounds || getDefaultBounds();\r\n  const red = generateFleetForTeam(seed, \"red\", b, shipFactory, options);\r\n  const blue = generateFleetForTeam(\r\n    seed + 1,\r\n    \"blue\",\r\n    b,\r\n    shipFactory,\r\n    options,\r\n  );\r\n  return red.concat(blue);\r\n}\r\n\r\nexport function chooseReinforcements(\r\n  seed = 0,\r\n  state: any = {},\r\n  options: any = {},\r\n) {\r\n  const cfg = Object.assign({}, TeamsConfig.continuousReinforcement, options);\r\n  // (no-op) merge options onto default continuous reinforcement config\r\n  if (!cfg.enabled) return [] as any[];\r\n  const teamStrength: Record<string, number> = {};\r\n  if (Array.isArray(state.ships)) {\r\n    for (const s of state.ships) {\r\n      if (!s || !s.team) continue;\r\n      const hp = typeof s.hp === \"number\" ? s.hp : 1;\r\n      teamStrength[s.team] = (teamStrength[s.team] || 0) + hp;\r\n    }\r\n  }\r\n  const teams = Object.keys(TeamsConfig.teams);\r\n  if (teams.length === 0) return [];\r\n  for (const t of teams) {\r\n    if (!teamStrength[t]) {\r\n      const cnt = (state.ships || []).filter(\r\n        (s: any) => s && s.team === t,\r\n      ).length;\r\n      teamStrength[t] = cnt > 0 ? cnt : 0;\r\n    }\r\n  }\r\n  let weakest = teams[0];\r\n  let strongest = teams[0];\r\n  for (const t of teams) {\r\n    if (teamStrength[t] < teamStrength[weakest]) weakest = t;\r\n    if (teamStrength[t] > teamStrength[strongest]) strongest = t;\r\n  }\r\n  const total = teams.reduce((s, t) => s + (teamStrength[t] || 0), 0) || 1;\r\n  const weakestRatio = (teamStrength[weakest] || 0) / total;\r\n  if (weakestRatio < 0.5 - cfg.scoreMargin) {\r\n    const orders: any[] = [];\r\n    const rng = mulberry32((seed >>> 0) + hashStringToInt(weakest));\r\n    // determine candidate ship types: either explicit list or keys from defaultFleet\r\n    const candidateTypes =\r\n      Array.isArray(cfg.shipTypes) && cfg.shipTypes.length\r\n        ? cfg.shipTypes\r\n        : Object.keys(TeamsConfig.defaultFleet.counts || { fighter: 1 });\r\n    // Build weights for candidate types using defaultFleet counts when available\r\n    const countsMap =\r\n      TeamsConfig && TeamsConfig.defaultFleet && TeamsConfig.defaultFleet.counts\r\n        ? TeamsConfig.defaultFleet.counts\r\n        : {};\r\n    const weights = candidateTypes.map((t: string) =>\r\n      Math.max(0, Number((countsMap as any)[t]) || 1),\r\n    );\r\n    const totalWeight =\r\n      weights.reduce((s: number, w: number) => s + w, 0) ||\r\n      candidateTypes.length ||\r\n      1;\r\n    // Helper: weighted random pick for ship types\r\n    const weightedPick = () => {\r\n      const r = rng() * totalWeight;\r\n      let acc = 0;\r\n      for (let i = 0; i < candidateTypes.length; i++) {\r\n        acc += weights[i];\r\n        if (r < acc) return candidateTypes[i];\r\n      }\r\n      return candidateTypes[candidateTypes.length - 1];\r\n    };\r\n    // Randomize number to spawn between 1 and cfg.perTick (inclusive)\r\n    const maxPerTick = Math.max(1, Math.floor(Number(cfg.perTick) || 1));\r\n    const spawnCount = Math.max(1, Math.floor(rng() * maxPerTick) + 1);\r\n    // spawnCount computed deterministically from the provided seed\r\n  const b = options.bounds || getDefaultBounds();\r\n    const centerY = b.H / 2;\r\n    const baseX = weakest === \"red\" ? b.W * 0.18 : b.W * 0.82;\r\n    for (let i = 0; i < spawnCount; i++) {\r\n      const x = Math.max(0, Math.min(b.W - 1e-6, baseX + (rng() - 0.5) * 120));\r\n      const y = Math.max(\r\n        0,\r\n        Math.min(b.H - 1e-6, centerY + (rng() - 0.5) * 160),\r\n      );\r\n      const type =\r\n        Array.isArray(cfg.shipTypes) && cfg.shipTypes.length\r\n          ? candidateTypes[Math.floor(rng() * candidateTypes.length)] ||\r\n            getDefaultShipType()\r\n          : weightedPick();\r\n      orders.push({ type, team: weakest, x, y });\r\n    }\r\n    // return deterministic orders\r\n    return orders;\r\n  }\r\n  return [] as any[];\r\n}\r\n\r\n// Team fallback default\r\nexport const TEAM_DEFAULT = \"red\";\r\n\r\nexport default TeamsConfig;\r\n\r\n// Helper: call chooseReinforcements using a manager-derived seed (from global RNG)\r\n// This is convenient for callers (like gamemanager) that want to keep\r\n// reinforcements deterministic relative to the global `srand`/`srandom` state.\r\nimport { srandom } from \"../rng\";\r\nexport function chooseReinforcementsWithManagerSeed(\r\n  state: any = {},\r\n  options: any = {},\r\n) {\r\n  const seed = Math.floor(srandom() * 0xffffffff) >>> 0;\r\n  return chooseReinforcements(seed, state, options);\r\n}\r\n", "// Generic object pool\r\nexport type ResetFn<T> = (obj: T) => void;\r\nexport default class Pool<T> {\r\n  private stack: T[] = [];\r\n  private factory: () => T;\r\n  private reset?: ResetFn<T>;\r\n  public created = 0;\r\n\r\n  constructor(factory: () => T, reset?: ResetFn<T>, initialSize = 0) {\r\n    this.factory = factory;\r\n    this.reset = reset;\r\n    for (let i = 0; i < initialSize; i++) this.stack.push(this.factory());\r\n    this.created = this.stack.length;\r\n  }\r\n\r\n  acquire(): T {\r\n    const obj = this.stack.pop();\r\n    if (typeof obj !== \"undefined\") return obj;\r\n    const newObj = this.factory();\r\n    this.created++;\r\n    return newObj;\r\n  }\r\n\r\n  release(obj: T): void {\r\n    if (this.reset) this.reset(obj);\r\n    // Avoid pushing the same object twice which can lead to duplicate\r\n    // references in the pool and subtle reuse bugs.\r\n    if (!this.stack.includes(obj)) this.stack.push(obj);\r\n  }\r\n\r\n  size(): number {\r\n    return this.stack.length;\r\n  }\r\n\r\n  clear(): void {\r\n    this.stack.length = 0;\r\n  }\r\n}\r\n", "import type { GameState } from \"./types\";\r\nimport {\r\n  getShipConfig,\r\n  getDefaultShipType,\r\n  getSizeDefaults,\r\n} from \"./config/entitiesConfig\";\r\n// pooling helpers moved to src/pools; importers should use that module now\r\nimport { TEAM_DEFAULT } from \"./config/teamsConfig\";\r\nimport type { ShipConfigMap, ShipSpec } from \"./types\";\r\nimport Pool from \"./pools/pool\";\r\n\r\n// Pooling helpers were moved to `src/pools` \u2014 import from there directly.\r\n\r\nlet nextId = 1;\r\nexport function genId(): number {\r\n  return nextId++;\r\n}\r\n\r\nexport type Cannon = {\r\n  damage: number;\r\n  rate: number;\r\n  // runtime cooldown (internal) - optional\r\n  __cd?: number;\r\n  // optional range used by behavior logic\r\n  range?: number;\r\n  spread?: number;\r\n  muzzleSpeed?: number;\r\n  bulletRadius?: number;\r\n  bulletTTL?: number;\r\n};\r\n\r\nexport type Ship = {\r\n  id: number;\r\n  type: string;\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  hp: number;\r\n  maxHp: number;\r\n  shield?: number;\r\n  maxShield?: number;\r\n  angle: number;\r\n  team?: string;\r\n  xp?: number;\r\n  level?: number;\r\n  cannons?: Cannon[];\r\n  accel?: number;\r\n  currentAccel?: number;\r\n  throttle?: number;\r\n  steering?: number;\r\n  turnRate?: number;\r\n  radius?: number;\r\n  maxSpeed?: number;\r\n  trail?: { x: number; y: number }[];\r\n  shieldRegen?: number;\r\n  shieldPercent?: number;\r\n  hpPercent?: number;\r\n  armor?: number;\r\n  size?: \"small\" | \"medium\" | \"large\";\r\n  // parentId is set on ships spawned by other entities (e.g. fighters launched by a carrier)\r\n  parentId?: number;\r\n  // Internal carrier timer accumulator (seconds). Not serialized.\r\n  _carrierTimer?: number;\r\n};\r\n\r\nexport function createShip(\r\n  type: string | undefined = undefined,\r\n  x = 0,\r\n  y = 0,\r\n  team = TEAM_DEFAULT,\r\n): Ship {\r\n  const shipCfg = getShipConfig() as ShipConfigMap;\r\n  const availableTypes = Object.keys(shipCfg || {});\r\n  const resolvedType =\r\n    type && shipCfg[type]\r\n      ? type\r\n      : availableTypes.length\r\n        ? availableTypes[0]\r\n        : getDefaultShipType();\r\n  const rawCfg = (shipCfg[resolvedType] ||\r\n    shipCfg[getDefaultShipType()]) as Partial<ShipSpec>;\r\n  // Merge in per-size defaults for any fields not explicitly provided by the\r\n  // ship type config. This keeps configs concise while ensuring sensible\r\n  // defaults for armor/shields per size class.\r\n  const sizeVal =\r\n    (rawCfg as any).size ||\r\n    (rawCfg.radius && rawCfg.radius >= 36\r\n      ? \"large\"\r\n      : rawCfg.radius && rawCfg.radius >= 20\r\n        ? \"medium\"\r\n        : \"small\");\r\n  const sizeDefaults = getSizeDefaults(sizeVal as \"small\" | \"medium\" | \"large\");\r\n  const cfg = Object.assign({}, sizeDefaults, rawCfg) as Partial<ShipSpec>;\r\n  const ship = {\r\n    id: genId(),\r\n    type: resolvedType,\r\n    x,\r\n    y,\r\n    vx: 0,\r\n    vy: 0,\r\n    hp: cfg.maxHp ?? 0,\r\n    maxHp: cfg.maxHp ?? 0,\r\n    shield: cfg.maxShield ?? 0,\r\n    maxShield: cfg.maxShield ?? 0,\r\n    shieldRegen: cfg.shieldRegen ?? 0,\r\n    armor: cfg.armor ?? 0,\r\n    size: (cfg as any).size || sizeVal,\r\n    team,\r\n    xp: 0,\r\n    level: 1,\r\n    cannons: JSON.parse(JSON.stringify(cfg.cannons || [])),\r\n    // Keep raw turret defs here for now; we'll normalize below via helper so\r\n    // normalization logic is centralized and reusable by snapshot handlers.\r\n    turrets: cfg.turrets || [],\r\n    accel: cfg.accel || 0,\r\n    currentAccel: 0,\r\n    throttle: 0,\r\n    steering: 0,\r\n    turnRate: cfg.turnRate || 0,\r\n    radius: cfg.radius || 6,\r\n    // Ensure maxSpeed is always a sensible positive number. Some saved state\r\n    // or malformed configs may have maxSpeed omitted or set to 0 which causes\r\n    // ships to never translate (they can still rotate/fire). Prefer the\r\n    // configured value but fall back to a safe default > 0.\r\n    maxSpeed:\r\n      typeof cfg.maxSpeed === \"number\" && cfg.maxSpeed > 0 ? cfg.maxSpeed : 120,\r\n    angle: 0,\r\n    trail: undefined,\r\n    shieldPercent: 1,\r\n    hpPercent: 1,\r\n  } as Ship;\r\n  // Ensure turrets are normalized to the object shape (idempotent)\r\n  try {\r\n    normalizeTurrets(ship as any);\r\n  } catch (e) {}\r\n  return ship as Ship;\r\n}\r\n\r\n// normalizeTurrets\r\n// Converts turret shorthand arrays ([x,y]) into normalized turret objects\r\n// with default runtime fields. This function is idempotent and safe to call\r\n// on ships coming from snapshots or network/worker messages.\r\nexport function normalizeTurrets(ship: any): void {\r\n  try {\r\n    if (!ship) return;\r\n    const tarr = ship.turrets;\r\n    if (!Array.isArray(tarr)) return;\r\n    ship.turrets = tarr.map((t: any) => {\r\n      if (Array.isArray(t) && t.length === 2) {\r\n        return { position: t, angle: 0, targetAngle: 0, kind: \"basic\" };\r\n      }\r\n      // If it's already an object turret, shallow-copy to avoid mutating\r\n      // shared config objects from imports or serialized defaults.\r\n      if (t && typeof t === \"object\") return Object.assign({}, t);\r\n      return t;\r\n    });\r\n  } catch (e) {}\r\n}\r\n\r\n// normalizeStateShips\r\n// Normalizes turrets for every ship in the provided state, rebuilds a\r\n// shipMap for quick lookups and recomputes teamCounts (keeps red/blue keys).\r\nexport function normalizeStateShips(state: any): void {\r\n  if (!state || typeof state !== \"object\") return;\r\n  try {\r\n    const ships = Array.isArray(state.ships) ? state.ships : [];\r\n    // Normalize each ship's turret defs\r\n    for (const s of ships) {\r\n      try {\r\n        normalizeTurrets(s);\r\n      } catch (e) {}\r\n    }\r\n    // Rebuild shipMap\r\n    try {\r\n      (state as any).shipMap = new Map<number, any>();\r\n      for (const s of ships)\r\n        if (s && typeof s.id !== \"undefined\")\r\n          (state as any).shipMap.set(s.id, s);\r\n    } catch (e) {}\r\n    // Recompute teamCounts, preserve red/blue keys default\r\n    try {\r\n      const counts: Record<string, number> = { red: 0, blue: 0 };\r\n      for (const s of ships) {\r\n        try {\r\n          const t = String((s && (s as any).team) || \"\");\r\n          if (t) counts[t] = (counts[t] || 0) + 1;\r\n        } catch (e) {}\r\n      }\r\n      state.teamCounts = counts;\r\n    } catch (e) {}\r\n  } catch (e) {}\r\n}\r\n\r\nexport type Bullet = {\r\n  id: number;\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  team: string;\r\n  ownerId?: number | null;\r\n  damage: number;\r\n  ttl: number;\r\n  radius?: number;\r\n  bulletRadius?: number;\r\n  bulletTTL?: number;\r\n  kind?: string;\r\n  alive?: boolean;\r\n  prevX?: number;\r\n  prevY?: number;\r\n  _prevX?: number;\r\n  _prevY?: number;\r\n};\r\n\r\nconst bulletPool = new Pool<Bullet>(\r\n  () => ({\r\n    id: 0,\r\n    x: 0,\r\n    y: 0,\r\n    vx: 0,\r\n    vy: 0,\r\n    team: TEAM_DEFAULT,\r\n    ownerId: null,\r\n    damage: 0,\r\n    ttl: 0,\r\n    prevX: 0,\r\n    prevY: 0,\r\n    _prevX: 0,\r\n    _prevY: 0,\r\n  }),\r\n  (b) => {\r\n    /* reset */ b.id = 0;\r\n    b.x = 0;\r\n    b.y = 0;\r\n    b.vx = 0;\r\n    b.vy = 0;\r\n    b.team = TEAM_DEFAULT;\r\n    b.ownerId = null;\r\n    b.damage = 0;\r\n    b.ttl = 0;\r\n    b.prevX = 0;\r\n    b.prevY = 0;\r\n    b._prevX = 0;\r\n    b._prevY = 0;\r\n  },\r\n);\r\n\r\nexport function createBullet(\r\n  x: number,\r\n  y: number,\r\n  vx: number,\r\n  vy: number,\r\n  team = TEAM_DEFAULT,\r\n  ownerId: number | null = null,\r\n  damage = 1,\r\n  ttl = 2.0,\r\n): Bullet {\r\n  const b = bulletPool.acquire();\r\n  b.id = genId();\r\n  b.x = x;\r\n  b.y = y;\r\n  b.vx = vx;\r\n  b.vy = vy;\r\n  b.team = team;\r\n  b.ownerId = ownerId;\r\n  b.damage = damage;\r\n  b.ttl = ttl;\r\n  b.prevX = x;\r\n  b.prevY = y;\r\n  b._prevX = x;\r\n  b._prevY = y;\r\n  b.alive = true;\r\n  return b;\r\n}\r\n\r\nexport function releaseBullet(b: Bullet) {\r\n  try {\r\n    b.alive = false;\r\n  } catch {}\r\n  bulletPool.release(b);\r\n}\r\n\r\nexport interface ExplosionEffect {\r\n  x: number;\r\n  y: number;\r\n  r?: number;\r\n  alive?: boolean;\r\n  _pooled?: boolean;\r\n  [key: string]: unknown;\r\n}\r\nexport interface ShieldHitEffect {\r\n  x: number;\r\n  y: number;\r\n  magnitude?: number;\r\n  alive?: boolean;\r\n  _pooled?: boolean;\r\n  [key: string]: unknown;\r\n}\r\nexport interface HealthHitEffect {\r\n  x: number;\r\n  y: number;\r\n  amount?: number;\r\n  alive?: boolean;\r\n  _pooled?: boolean;\r\n  [key: string]: unknown;\r\n}\r\n\r\nexport function createExplosionEffect(\r\n  init?: Partial<ExplosionEffect>,\r\n): ExplosionEffect {\r\n  return {\r\n    x: init?.x ?? 0,\r\n    y: init?.y ?? 0,\r\n    r: init?.r,\r\n    alive: true,\r\n    _pooled: false,\r\n    ...init,\r\n  };\r\n}\r\nexport function resetExplosionEffect(\r\n  obj: ExplosionEffect,\r\n  init?: Partial<ExplosionEffect>,\r\n) {\r\n  obj.x = init?.x ?? 0;\r\n  obj.y = init?.y ?? 0;\r\n  obj.r = init?.r;\r\n  obj.alive = true;\r\n  obj._pooled = false;\r\n  Object.assign(obj, init);\r\n}\r\nexport function createShieldHitEffect(\r\n  init?: Partial<ShieldHitEffect>,\r\n): ShieldHitEffect {\r\n  return {\r\n    x: init?.x ?? 0,\r\n    y: init?.y ?? 0,\r\n    magnitude: init?.magnitude,\r\n    alive: true,\r\n    _pooled: false,\r\n    ...init,\r\n  };\r\n}\r\nexport function resetShieldHitEffect(\r\n  obj: ShieldHitEffect,\r\n  init?: Partial<ShieldHitEffect>,\r\n) {\r\n  obj.x = init?.x ?? 0;\r\n  obj.y = init?.y ?? 0;\r\n  obj.magnitude = init?.magnitude;\r\n  obj.alive = true;\r\n  obj._pooled = false;\r\n  Object.assign(obj, init);\r\n}\r\nexport function createHealthHitEffect(\r\n  init?: Partial<HealthHitEffect>,\r\n): HealthHitEffect {\r\n  return {\r\n    x: init?.x ?? 0,\r\n    y: init?.y ?? 0,\r\n    amount: init?.amount,\r\n    alive: true,\r\n    _pooled: false,\r\n    ...init,\r\n  };\r\n}\r\nexport function resetHealthHitEffect(\r\n  obj: HealthHitEffect,\r\n  init?: Partial<HealthHitEffect>,\r\n) {\r\n  obj.x = init?.x ?? 0;\r\n  obj.y = init?.y ?? 0;\r\n  obj.amount = init?.amount;\r\n  obj.alive = true;\r\n  obj._pooled = false;\r\n  Object.assign(obj, init);\r\n}\r\n\r\nimport type { PoolEntry, TexturePoolEntry } from './types/pool';\r\n// Provide a default initial GameState for simulation and tests\r\nexport function makeInitialState(): GameState {\r\n  return {\r\n    t: 0,\r\n    ships: [],\r\n    // fast lookup map kept in sync with ships[] where possible\r\n    shipMap: new Map<number, Ship>(),\r\n    // Cached counts per team to avoid per-frame filter allocations\r\n    teamCounts: { red: 0, blue: 0 },\r\n    bullets: [],\r\n    explosions: [],\r\n    shieldHits: [],\r\n    healthHits: [],\r\n    engineTrailsEnabled: true,\r\n    assetPool: {\r\n      textures: new Map<string, PoolEntry<WebGLTexture>>(),\r\n      sprites: new Map<string, PoolEntry<any>>(),\r\n      effects: new Map<string, PoolEntry<any>>(),\r\n      counts: {\r\n        textures: new Map<string, number>(),\r\n        sprites: new Map<string, number>(),\r\n        effects: new Map<string, number>(),\r\n      },\r\n      config: {\r\n        texturePoolSize: 128,\r\n        spritePoolSize: 256,\r\n        effectPoolSize: 128,\r\n        textureOverflowStrategy: \"discard-oldest\",\r\n        spriteOverflowStrategy: \"discard-oldest\",\r\n        effectOverflowStrategy: \"discard-oldest\",\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\n// Update team counts safely. oldTeam/newTeam may be undefined when adding or removing.\r\nexport function updateTeamCount(\r\n  state: GameState,\r\n  oldTeam?: string,\r\n  newTeam?: string,\r\n) {\r\n  try {\r\n    if (oldTeam) {\r\n      state.teamCounts[oldTeam] = Math.max(\r\n        0,\r\n        (state.teamCounts[oldTeam] || 0) - 1,\r\n      );\r\n    }\r\n    if (newTeam) {\r\n      state.teamCounts[newTeam] = (state.teamCounts[newTeam] || 0) + 1;\r\n    }\r\n  } catch (e) {}\r\n}\r\n", "/**\r\n * Returns the engine trail config for a given ship type.\r\n * If not present, returns the default engineTrail animation config.\r\n */\r\nexport function getEngineTrailConfig(type: string): any {\r\n  const vconf = getVisualConfig(type);\r\n  const trailName = (vconf.visuals && vconf.visuals.engineTrail) || 'engineTrail';\r\n  return (AssetsConfig.animations && AssetsConfig.animations[trailName]) || (AssetsConfig.animations && AssetsConfig.animations.engineTrail);\r\n}\r\n/**\r\n * Asset-agnostic sprite provider: returns a sprite object for a given type.\r\n * Supports fallback to vector shapes, 3D models, or SVG files.\r\n * Usage: getSpriteAsset('fighter'), getSpriteAsset('carrier'), etc.\r\n */\r\nexport function getSpriteAsset(type: string): { shape?: Shape2D; model3d?: Model3D; svg?: string } {\r\n  // Prefer an inlined SVG string from AssetsConfig.svgAssets (standalone build)\r\n  // if present and looks like SVG markup. This allows the build-time inlined\r\n  // SVGs to be used directly by the renderer. If not inlined, fall back to\r\n  // any `svg` field on the shapes2d entry (legacy) or model3d/shape data.\r\n  const inlineSvg = (AssetsConfig as any).svgAssets && (AssetsConfig as any).svgAssets[type];\r\n  if (typeof inlineSvg === 'string' && inlineSvg.trim().startsWith('<svg')) {\r\n    return { svg: inlineSvg };\r\n  }\r\n  // For backward compatibility, check shapes2d entry for an embedded svg string\r\n  const shapeEntry = AssetsConfig.shapes2d[type] || AssetsConfig.shapes2d.fighter;\r\n  if ((shapeEntry as any).svg) {\r\n    return { svg: (shapeEntry as any).svg };\r\n  }\r\n  // If model3d is present, use it\r\n  if (shapeEntry.model3d && shapeEntry.model3d.url) {\r\n    return { model3d: shapeEntry.model3d };\r\n  }\r\n  // Fallback to vector shape\r\n  return { shape: shapeEntry };\r\n}\r\n// Basic asset templates for 2D top-down rendering with future 3D model placeholders.\r\n// Orientation: shapes face +X (to the right). Scale is in logical units; renderer\r\n// should scale to entity radius and rotate by entity heading if present.\r\n\r\nexport type PolygonShape = {\r\n  type: 'polygon';\r\n  points: number[][]; // [[x,y], ...]\r\n  strokeWidth?: number;\r\n  model3d?: Model3D | undefined;\r\n};\r\n\r\nexport type CircleShape = {\r\n  type: 'circle';\r\n  r: number;\r\n  strokeWidth?: number;\r\n  model3d?: Model3D | undefined;\r\n};\r\n\r\nexport type CompoundPart = PolygonShape | CircleShape;\r\n\r\nexport type CompoundShape = {\r\n  type: 'compound';\r\n  parts: CompoundPart[];\r\n  strokeWidth?: number;\r\n  model3d?: Model3D | undefined;\r\n};\r\n\r\nexport type Shape2D = PolygonShape | CircleShape | CompoundShape;\r\nexport type TurretVisualConfig = {\r\n  kind: string;\r\n  position: [number, number]; // relative to ship center, in radius units\r\n};\r\n\r\nexport type TurretDefaultConfig = {\r\n  turnRate?: number; // radians per second default\r\n  sprite?: string; // optional sprite key to use for turret visuals\r\n};\r\n\r\nexport type Model3D = {\r\n  url?: string | undefined;\r\n  scale?: number | undefined;\r\n  type?: string | undefined;\r\n  mesh?: string | undefined;\r\n};\r\n\r\nexport type AssetsConfigType = {\r\n  meta: { orientation: string; coordinateSystem: string };\r\n  palette: Record<string, string>;\r\n  shapes2d: Record<string, Shape2D & { turrets?: TurretVisualConfig[] }>;\r\n  // Optional mapping of ship type -> svg filename (for future svg-based rendering)\r\n  svgAssets?: Record<string, string>;\r\n  // Optional explicit mountpoints extracted from SVGs or authored here.\r\n  // Positions are in ship-local radius units (same space as shapes2d.turrets)\r\n  svgMounts?: Record<string, [number, number][]>;\r\n  // Defaults for turret kinds (turn rate, sprite override, etc.)\r\n  turretDefaults?: Record<string, TurretDefaultConfig>;\r\n  animations?: Record<string, any>;\r\n  damageStates?: Record<string, { opacity?: number; accentColor?: string }>;\r\n  visualStateDefaults?: Record<string, { engine?: string; shield?: string; damageParticles?: string }>;\r\n};\r\n\r\nexport const AssetsConfig: AssetsConfigType = {\r\n  meta: {\r\n    orientation: '+X',\r\n    coordinateSystem: 'topdown-2d',\r\n  },\r\n  palette: {\r\n    shipHull: '#b0b7c3',\r\n    shipAccent: '#6c7380',\r\n    bullet: '#ffd166',\r\n    turret: '#94a3b8',\r\n    // Scene background color used by renderers\r\n    background: '#0b1220',\r\n  },\r\n  // 2D vector shapes defined as polygons and circles. Points are unit-sized\r\n  // profiles (roughly radius 1). Renderer should multiply by entity radius or\r\n  // provided scale before drawing.\r\n  shapes2d: {\r\n    fighter: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'polygon', points: [[1.2, 0], [-0.8, 0.6], [-0.5, 0], [-0.8, -0.6]] },\r\n        { type: 'polygon', points: [[0.0, 0.35], [-0.6, 0.65], [-0.35, 0.0]] },\r\n        { type: 'polygon', points: [[0.0, -0.35], [-0.35, 0.0], [-0.6, -0.65]] },\r\n        { type: 'circle', r: 0.5 }\r\n      ],\r\n      strokeWidth: 0.08,\r\n      model3d: { url: undefined, scale: 1, type: 'gltf', mesh: undefined }\r\n    },\r\n    corvette: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'polygon', points: [[1.2, 0], [0.4, 0.7], [-1.0, 0.6], [-1.2, 0], [-1.0, -0.6], [0.4, -0.7]] },\r\n        { type: 'polygon', points: [[1.4, 0.22], [1.2, 0.12], [1.2, -0.12], [1.4, -0.22]] },\r\n        { type: 'circle', r: 0.6 }\r\n      ],\r\n      strokeWidth: 0.08,\r\n      model3d: { url: undefined, scale: 1.4, type: 'gltf', mesh: undefined }\r\n    },\r\n    frigate: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'polygon', points: [[1.3, 0], [0.7, 0.65], [-0.3, 1.0], [-1.3, 0.55], [-1.3, -0.55], [-0.3, -1.0], [0.7, -0.65]] },\r\n        { type: 'circle', r: 0.7 }\r\n      ],\r\n      strokeWidth: 0.1,\r\n      model3d: { url: undefined, scale: 1.8, type: 'gltf', mesh: undefined }\r\n    },\r\n    destroyer: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'polygon', points: [[1.8, 0], [1.0, 0.7], [0.2, 1.0], [-0.8, 0.9], [-1.8, 0.6], [-1.8, -0.6], [-0.8, -0.9], [0.2, -1.0], [1.0, -0.7]] },\r\n        { type: 'circle', r: 1.0 },\r\n        { type: 'polygon', points: [[2.0, 0.3], [1.8, 0.2], [1.8, -0.2], [2.0, -0.3]] }\r\n      ],\r\n      strokeWidth: 0.12,\r\n      model3d: { url: undefined, scale: 2.2, type: 'gltf', mesh: undefined },\r\n      turrets: [\r\n        { kind: 'basic', position: [1.2, 0.8] },\r\n        { kind: 'basic', position: [-1.2, 0.8] },\r\n        { kind: 'basic', position: [1.2, -0.8] },\r\n        { kind: 'basic', position: [-1.2, -0.8] },\r\n        { kind: 'basic', position: [0, 1.5] },\r\n        { kind: 'basic', position: [0, -1.5] }\r\n      ]\r\n    },\r\n    carrier: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'polygon', points: [[2.2, 0], [1.2, 1.2], [-1.0, 1.6], [-2.8, 1.2], [-3.2, 0], [-2.8, -1.2], [-1.0, -1.6], [1.2, -1.2]] },\r\n        { type: 'circle', r: 1.2 },\r\n        { type: 'polygon', points: [[2.6, 0.5], [2.2, 0.3], [2.2, -0.3], [2.6, -0.5]] }\r\n      ],\r\n      strokeWidth: 0.12,\r\n      model3d: { url: undefined, scale: 3.0, type: 'gltf', mesh: undefined },\r\n      turrets: [\r\n        { kind: 'basic', position: [2.0, 1.2] },\r\n        { kind: 'basic', position: [-2.0, 1.2] },\r\n        { kind: 'basic', position: [2.0, -1.2] },\r\n        { kind: 'basic', position: [-2.0, -1.2] }\r\n      ]\r\n    },\r\n    bulletSmall: { type: 'circle', r: 0.18 },\r\n    bulletMedium: { type: 'circle', r: 0.25 },\r\n    bulletLarge: { type: 'circle', r: 0.36 },\r\n    turretBasic: {\r\n      type: 'compound',\r\n      parts: [\r\n        { type: 'circle', r: 0.5 },\r\n        { type: 'polygon', points: [[-0.2, 0.2], [0.7, 0.2], [0.7, -0.2], [-0.2, -0.2]] }\r\n      ],\r\n      strokeWidth: 0.08\r\n    },\r\n    // Small effect/particle shapes for renderer-driven effects\r\n    particleSmall: { type: 'circle', r: 0.12 },\r\n    particleMedium: { type: 'circle', r: 0.22 },\r\n    explosionParticle: { type: 'circle', r: 0.32 },\r\n    shieldRing: { type: 'circle', r: 1.2 }\r\n  }\r\n};\r\n\r\n// Optional mapping to ship SVGs (relative to this file path). These are\r\n// provided as a convenience for renderers that can load and parse the\r\n// inline SVGs to extract mountpoints or render higher-fidelity imagery.\r\n\r\n// For standalone builds, SVGs are inlined as strings. Use globalThis.__INLINE_SVG_ASSETS if present.\r\nif (typeof globalThis !== 'undefined' && (globalThis as any).__INLINE_SVG_ASSETS) {\r\n  (AssetsConfig as any).svgAssets = (globalThis as any).__INLINE_SVG_ASSETS;\r\n} else {\r\n  (AssetsConfig as any).svgAssets = {\r\n    destroyer: './svg/destroyer.svg',\r\n    carrier: './svg/carrier.svg',\r\n    frigate: './svg/frigate.svg',\r\n    corvette: './svg/corvette.svg'\r\n  };\r\n}\r\n\r\n// For environments where SVG mountpoint extraction isn't available yet we\r\n// provide an explicit mapping that mirrors the turrets defined in shapes2d.\r\n(AssetsConfig as any).svgMounts = {\r\n  destroyer: AssetsConfig.shapes2d.destroyer.turrets ? AssetsConfig.shapes2d.destroyer.turrets.map((t: any) => t.position) : [],\r\n  carrier: AssetsConfig.shapes2d.carrier.turrets ? AssetsConfig.shapes2d.carrier.turrets.map((t: any) => t.position) : []\r\n};\r\n\r\n// Turret defaults (radians per second) and optional sprite selection.\r\n(AssetsConfig as any).turretDefaults = {\r\n  basic: { turnRate: Math.PI * 1.5, sprite: 'turretBasic' }\r\n};\r\n\r\n// Animations and visual defaults (align with JS AssetsConfig)\r\n(AssetsConfig as any).animations = {\r\n  engineFlare: {\r\n    type: 'polygon',\r\n    points: [ [0, 0], [-0.3, 0.15], [-0.5, 0], [-0.3, -0.15] ],\r\n    pulseRate: 8,\r\n    // configurable alpha multiplier for engine overlay\r\n    alpha: 0.4,\r\n    // local-space X offset (negative = behind ship)\r\n    offset: -0.9\r\n  },\r\n  shieldEffect: {\r\n    type: 'circle',\r\n    r: 1.2,\r\n    strokeWidth: 0.1,\r\n    color: '#88ccff',\r\n    pulseRate: 2,\r\n    // map shieldPct -> alpha = base + scale * shieldPct\r\n    alphaBase: 0.25,\r\n    alphaScale: 0.75\r\n  },\r\n  damageParticles: {\r\n    type: 'particles',\r\n    color: '#ff6b6b',\r\n    count: 6,\r\n    lifetime: 0.8,\r\n    spread: 0.6\r\n  }\r\n  ,\r\n  engineTrail: {\r\n    type: 'trail',\r\n    color: '#fff0a0', // brighter, warm highlight for good contrast\r\n    maxLength: 120,   // longer trail (was 40)\r\n    width: 0.9,       // thicker trail line (was 0.35)\r\n    fade: 0.6         // older points remain more visible (was 0.35)\r\n  }\r\n};\r\n\r\n(AssetsConfig as any).damageStates = {\r\n  light: { opacity: 0.9, accentColor: '#b0b7c3' },\r\n  moderate: { opacity: 0.75, accentColor: '#d4a06a' },\r\n  heavy: { opacity: 0.5, accentColor: '#ff6b6b' }\r\n};\r\n\r\n(AssetsConfig as any).visualStateDefaults = {\r\n  fighter:   { engine: 'engineFlare', shield: 'shieldEffect', damageParticles: 'damageParticles', engineTrail: 'engineTrail', arcWidth: Math.PI / 12 },\r\n  corvette:  { engine: 'engineFlare', shield: 'shieldEffect', damageParticles: 'damageParticles', engineTrail: 'engineTrail', arcWidth: Math.PI / 12 },\r\n  frigate:   { engine: 'engineFlare', shield: 'shieldEffect', damageParticles: 'damageParticles', engineTrail: 'engineTrail', arcWidth: Math.PI / 12 },\r\n  destroyer: { engine: 'engineFlare', shield: 'shieldEffect', damageParticles: 'damageParticles', engineTrail: 'engineTrail', arcWidth: Math.PI / 12 },\r\n  carrier:   { engine: 'engineFlare', shield: 'shieldEffect', damageParticles: 'damageParticles', engineTrail: 'engineTrail', arcWidth: Math.PI / 12 }\r\n};\r\n\r\n// thresholds for mapping hpPct -> damage state key\r\n(AssetsConfig as any).damageThresholds = { moderate: 0.66, heavy: 0.33 };\r\n(AssetsConfig as any).shieldArcWidth = Math.PI / 12;\r\n\r\nexport function getVisualConfig(type: string) {\r\n  const shape = getShipAsset(type);\r\n  const visuals = (AssetsConfig as any).visualStateDefaults[type] || (AssetsConfig as any).visualStateDefaults.fighter;\r\n  return { shape, visuals, palette: AssetsConfig.palette, animations: (AssetsConfig as any).animations, damageStates: (AssetsConfig as any).damageStates } as any;\r\n}\r\n\r\nexport function getShipAsset(type: string): Shape2D {\r\n  return AssetsConfig.shapes2d[type] || AssetsConfig.shapes2d.fighter;\r\n}\r\n\r\nexport function getBulletAsset(kind: 'small' | 'medium' | 'large' = 'small'): Shape2D {\r\n  if (kind === 'large') return AssetsConfig.shapes2d.bulletLarge;\r\n  if (kind === 'medium') return AssetsConfig.shapes2d.bulletMedium;\r\n  return AssetsConfig.shapes2d.bulletSmall;\r\n}\r\n\r\nexport function getTurretAsset(_kind: 'basic' = 'basic'): Shape2D {\r\n  return AssetsConfig.shapes2d.turretBasic;\r\n}\r\n\r\nexport default AssetsConfig;\r\n", "// Enhanced progression with diminishing returns and extra per-level scalars\r\nexport const progression = {\r\n  xpPerDamage: 1,\r\n  xpPerKill: 50,\r\n  xpToLevel: (level: number) => 100 * Math.pow(1.25, level - 1),\r\n  hpPercentPerLevel: (level: number) => Math.min(0.10, 0.05 + 0.05 / Math.sqrt(level)),\r\n  dmgPercentPerLevel: 0.08,\r\n  shieldPercentPerLevel: 0.06,\r\n  speedPercentPerLevel: 0.03,\r\n  regenPercentPerLevel: 0.04,\r\n};\r\n\r\nexport default progression;\r\n", "import type { PoolEntry, PoolConfig, Disposer } from '../types/pool';\r\n\r\n// Lightweight PoolManager helpers. These are intentionally small and\r\n// runtime-friendly so they can be used in both renderer and simulation code.\r\n\r\nexport const DEFAULT_CONFIG: PoolConfig = {\r\n  max: undefined,\r\n  strategy: 'discard-oldest',\r\n  min: 0,\r\n};\r\n\r\nfunction _incCount(map: Map<string, number> | undefined, key: string, delta: number) {\r\n  if (!map) return;\r\n  const cur = map.get(key) || 0;\r\n  const next = cur + delta;\r\n  if (next <= 0) map.delete(key);\r\n  else map.set(key, next);\r\n}\r\n\r\nexport function makePoolEntry<T>(opts?: {\r\n  config?: Partial<PoolConfig>;\r\n  disposer?: Disposer<T>;\r\n}): PoolEntry<T> {\r\n  return {\r\n    freeList: [],\r\n    allocated: 0,\r\n    config: Object.assign({}, DEFAULT_CONFIG, opts?.config || {}),\r\n    disposer: opts?.disposer,\r\n  } as PoolEntry<T>;\r\n}\r\n\r\nexport function ensureEntryForKey<T>(\r\n  map: Map<string, PoolEntry<T>>,\r\n  key: string,\r\n  opts?: { config?: Partial<PoolConfig>; disposer?: Disposer<T> },\r\n): PoolEntry<T> {\r\n  let e = map.get(key) as PoolEntry<T> | undefined;\r\n  if (!e) {\r\n    e = makePoolEntry<T>(opts);\r\n    map.set(key, e);\r\n  }\r\n  return e;\r\n}\r\n\r\n// Simple helper to release all freeList items via disposer (if present)\r\n// and clear freeList. Returns number of disposed items.\r\nexport async function clearEntryFreeList<T>(entry: PoolEntry<T>): Promise<number> {\r\n  const list = entry.freeList.splice(0);\r\n  let disposed = 0;\r\n  if (entry.disposer) {\r\n    for (const it of list) {\r\n      await entry.disposer(it);\r\n      disposed++;\r\n    }\r\n  }\r\n  return disposed;\r\n}\r\n\r\n// Generic acquire/release helpers implementing overflow semantics.\r\nexport function acquireItem<T>(params: {\r\n  map: Map<string, PoolEntry<T>>;\r\n  counts?: Map<string, number>;\r\n  key: string;\r\n  createFn: () => T;\r\n  globalMax?: number; // fallback max when entry.config.max not set\r\n  globalStrategy?: PoolConfig['strategy'];\r\n  initFn?: (obj: T, initArgs?: any) => void;\r\n  initArgs?: any;\r\n}): T {\r\n  const { map, counts, key, createFn, globalMax, globalStrategy, initFn, initArgs } = params;\r\n  let entry = map.get(key) as PoolEntry<T> | undefined;\r\n  if (!entry) {\r\n    entry = makePoolEntry<T>({ config: { max: globalMax, strategy: globalStrategy } });\r\n    map.set(key, entry);\r\n  }\r\n  const free = entry.freeList;\r\n  if (free.length) {\r\n    const obj = free.pop()! as T;\r\n    try {\r\n      if (initFn) initFn(obj, initArgs);\r\n      else if (initArgs && typeof obj === 'object') Object.assign(obj as any, initArgs);\r\n    } catch {}\r\n    return obj;\r\n  }\r\n  const max = (entry.config && typeof entry.config.max === 'number') ? entry.config.max : (globalMax ?? Infinity);\r\n  const strategy = entry.config?.strategy ?? globalStrategy ?? 'discard-oldest';\r\n  const total = entry.allocated || (counts ? counts.get(key) || 0 : 0);\r\n  if (total < (max || Infinity) || strategy === 'grow') {\r\n    const e = createFn();\r\n    try {\r\n      if (initFn) initFn(e, initArgs);\r\n      else if (initArgs && typeof e === 'object') Object.assign(e as any, initArgs);\r\n    } catch {}\r\n    entry.allocated = (entry.allocated || 0) + 1;\r\n    if (counts) _incCount(counts, key, 1);\r\n    return e;\r\n  }\r\n  if (strategy === 'error') throw new Error(`Pool exhausted for key \"${key}\" (max=${max})`);\r\n  const e = createFn();\r\n  entry.allocated = (entry.allocated || 0) + 1;\r\n  if (counts) _incCount(counts, key, 1);\r\n  return e;\r\n}\r\n\r\nexport function releaseItem<T>(params: {\r\n  map: Map<string, PoolEntry<T>>;\r\n  counts?: Map<string, number>;\r\n  key: string;\r\n  item: T;\r\n  disposeFn?: (t: T) => void;\r\n  globalMax?: number;\r\n  globalStrategy?: PoolConfig['strategy'];\r\n}) {\r\n  const { map, counts, key, item, disposeFn, globalMax, globalStrategy } = params;\r\n  let entry = map.get(key) as PoolEntry<T> | undefined;\r\n  if (!entry) {\r\n    entry = makePoolEntry<T>({ config: { max: globalMax, strategy: globalStrategy } });\r\n    map.set(key, entry);\r\n  }\r\n  const free = entry.freeList;\r\n  if (!free.includes(item as any)) free.push(item as any);\r\n  const max = (entry.config && typeof entry.config.max === 'number') ? entry.config.max : (globalMax ?? Infinity);\r\n  const strategy = entry.config?.strategy ?? globalStrategy ?? 'discard-oldest';\r\n  if (strategy === 'grow') return;\r\n  const countsMap = counts || undefined;\r\n  while (free.length > (max || Infinity)) {\r\n    const victim = strategy === 'discard-oldest' ? free.shift()! : free.pop()!;\r\n    try {\r\n      if (entry!.disposer) entry!.disposer(victim as any);\r\n      else if (disposeFn) disposeFn(victim as any);\r\n    } catch {}\r\n    if (countsMap) _incCount(countsMap, key, -1);\r\n    entry.allocated = Math.max(0, (entry.allocated || 0) - 1);\r\n  }\r\n  if (strategy === 'error' && free.length > (max || Infinity)) {\r\n    const victim = free.pop()!;\r\n    try {\r\n      if (entry!.disposer) entry!.disposer(victim as any);\r\n      else if (disposeFn) disposeFn(victim as any);\r\n    } catch {}\r\n    if (countsMap) _incCount(countsMap, key, -1);\r\n    entry.allocated = Math.max(0, (entry.allocated || 0) - 1);\r\n  }\r\n}\r\n\r\nexport default {\r\n  DEFAULT_CONFIG,\r\n  makePoolEntry,\r\n  ensureEntryForKey,\r\n  clearEntryFreeList,\r\n};\r\n", "import type { GameState } from \"../types\";\r\nimport { acquireItem, releaseItem } from './PoolManager';\r\n\r\n// PoolEntry and Pooled types\r\nexport type PoolEntry<T> = {\r\n  freeList: T[];\r\n  allocated: number;\r\n  config?: { max?: number; strategy?: \"discard-oldest\" | \"grow\" | \"error\" };\r\n  disposer?: (item: T) => void;\r\n};\r\nexport type TexturePoolEntry = PoolEntry<WebGLTexture>;\r\n\r\nexport interface Pooled<T = Record<string, unknown>> {\r\n  reset?: (initArgs?: Partial<T>) => void;\r\n}\r\n\r\nfunction _getStrategy(v: unknown, def: \"discard-oldest\" | \"grow\" | \"error\") {\r\n  return v === \"grow\" || v === \"error\" || v === \"discard-oldest\"\r\n    ? (v as \"discard-oldest\" | \"grow\" | \"error\")\r\n    : def;\r\n}\r\nfunction _incCount(map: Map<string, number>, key: string, delta: number) {\r\n  const cur = map.get(key) || 0;\r\n  const next = cur + delta;\r\n  if (next <= 0) map.delete(key);\r\n  else map.set(key, next);\r\n}\r\n\r\n// Helper: prefer per-entry config.max if set, otherwise use the named global config\r\nfunction entryConfigOr(state: any, key: string, globalName: 'texturePoolSize' | 'spritePoolSize' | 'effectPoolSize') {\r\n  const poolMap = (globalName === 'texturePoolSize' ? state.assetPool.textures : globalName === 'spritePoolSize' ? state.assetPool.sprites : state.assetPool.effects) as Map<string, PoolEntry<any>>;\r\n  const entry = poolMap && poolMap.get ? poolMap.get(key) : undefined;\r\n  if (entry && entry.config && typeof entry.config.max === 'number') return entry.config.max;\r\n  return state.assetPool.config ? state.assetPool.config[globalName] : undefined;\r\n}\r\n\r\nfunction entryStrategyOr(state: any, key: string, globalName: 'textureOverflowStrategy' | 'spriteOverflowStrategy' | 'effectOverflowStrategy') {\r\n  const poolMap = (globalName === 'textureOverflowStrategy' ? state.assetPool.textures : globalName === 'spriteOverflowStrategy' ? state.assetPool.sprites : state.assetPool.effects) as Map<string, PoolEntry<any>>;\r\n  const entry = poolMap && poolMap.get ? poolMap.get(key) : undefined;\r\n  if (entry && entry.config && entry.config.strategy) return entry.config.strategy;\r\n  return state.assetPool.config ? state.assetPool.config[globalName] : undefined;\r\n}\r\n\r\nexport function makePooled<T extends object>(\r\n  obj: T,\r\n  resetFn?: (obj: T, initArgs?: Partial<T>) => void,\r\n): T & Pooled<T> {\r\n  const o = obj as T & Pooled<T>;\r\n  if (typeof o.reset !== \"function\") {\r\n    if (typeof resetFn === \"function\") {\r\n      o.reset = function (initArgs?: Partial<T>) {\r\n        try {\r\n          resetFn(o, initArgs);\r\n        } catch {}\r\n      };\r\n    } else {\r\n      o.reset = function (initArgs?: Partial<T>) {\r\n        if (initArgs && typeof initArgs === \"object\") Object.assign(o, initArgs);\r\n      };\r\n    }\r\n  }\r\n  return o;\r\n}\r\n\r\nexport type PooledFactory<T extends object> = {\r\n  create: () => T;\r\n  reset?: (obj: T, initArgs?: Partial<T>) => void;\r\n};\r\nexport function createPooledFactory<T extends object>(\r\n  createOrFactory: (() => T) | PooledFactory<T>,\r\n  resetFn?: (obj: T, initArgs?: Partial<T>) => void,\r\n): PooledFactory<T> {\r\n  if (typeof createOrFactory === \"function\")\r\n    return { create: createOrFactory as () => T, reset: resetFn };\r\n  const f = createOrFactory as PooledFactory<T>;\r\n  return { create: f.create, reset: f.reset };\r\n}\r\n\r\n// Ensure state.assetPool shape exists and has sensible defaults\r\nexport function ensureAssetPool(state: any) {\r\n  if (!state) return;\r\n  if (!state.assetPool || typeof state.assetPool !== \"object\") {\r\n    state.assetPool = {\r\n      textures: new Map<string, PoolEntry<WebGLTexture>>(),\r\n      sprites: new Map<string, PoolEntry<any>>(),\r\n      effects: new Map<string, PoolEntry<any>>(),\r\n      counts: {\r\n        textures: new Map<string, number>(),\r\n        sprites: new Map<string, number>(),\r\n        effects: new Map<string, number>(),\r\n      },\r\n      config: {\r\n        texturePoolSize: 128,\r\n        spritePoolSize: 256,\r\n        effectPoolSize: 128,\r\n        textureOverflowStrategy: \"discard-oldest\",\r\n        spriteOverflowStrategy: \"discard-oldest\",\r\n        effectOverflowStrategy: \"discard-oldest\",\r\n      },\r\n    } as any;\r\n  } else {\r\n    state.assetPool.textures = state.assetPool.textures || new Map();\r\n    state.assetPool.sprites = state.assetPool.sprites || new Map();\r\n    state.assetPool.effects = state.assetPool.effects || new Map();\r\n    state.assetPool.counts = state.assetPool.counts || {\r\n      textures: new Map<string, number>(),\r\n      sprites: new Map<string, number>(),\r\n      effects: new Map<string, number>(),\r\n    };\r\n    state.assetPool.config = state.assetPool.config || {\r\n      texturePoolSize: 128,\r\n      spritePoolSize: 256,\r\n      effectPoolSize: 128,\r\n      textureOverflowStrategy: \"discard-oldest\",\r\n      spriteOverflowStrategy: \"discard-oldest\",\r\n      effectOverflowStrategy: \"discard-oldest\",\r\n    };\r\n  }\r\n}\r\n\r\nexport function acquireEffect<T extends object>(\r\n  state: GameState,\r\n  key: string,\r\n  createFn: () => T & Pooled<T>,\r\n  initArgs?: Partial<T>,\r\n): T & Pooled<T> {\r\n  ensureAssetPool(state);\r\n  // Delegate to PoolManager.acquireItem to centralize overflow semantics\r\n  const poolMap = state.assetPool.effects as Map<string, PoolEntry<T & Pooled<T>>>;\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const counts = state.assetPool.counts!.effects as Map<string, number>;\r\n  return acquireItem<T & Pooled<T>>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    createFn: createFn as any,\r\n    globalMax: state.assetPool.config.effectPoolSize,\r\n    globalStrategy: _getStrategy(state.assetPool.config.effectOverflowStrategy, 'discard-oldest'),\r\n    initFn: (obj: T & Pooled<T>, args?: Partial<T>) => {\r\n      try {\r\n        if (typeof obj.reset === 'function') obj.reset(args);\r\n        else if (args && typeof args === 'object') Object.assign(obj as any, args);\r\n      } catch {}\r\n    },\r\n    initArgs,\r\n  }) as T & Pooled<T>;\r\n}\r\n\r\nexport function releaseEffect<T extends object>(\r\n  state: GameState,\r\n  key: string,\r\n  effect: T & Pooled<T>,\r\n  disposeFn?: (e: T) => void,\r\n) {\r\n  ensureAssetPool(state);\r\n  const poolMap = state.assetPool.effects as Map<string, PoolEntry<T & Pooled<T>>>;\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const counts = state.assetPool.counts!.effects as Map<string, number>;\r\n  return releaseItem<T & Pooled<T>>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    item: effect,\r\n    disposeFn: disposeFn as any,\r\n    globalMax: state.assetPool.config.effectPoolSize,\r\n    globalStrategy: _getStrategy(state.assetPool.config.effectOverflowStrategy, 'discard-oldest'),\r\n  });\r\n}\r\n\r\nexport function acquireTexture(\r\n  state: GameState,\r\n  key: string,\r\n  createFn: () => WebGLTexture,\r\n): WebGLTexture {\r\n  ensureAssetPool(state);\r\n  const poolMap = state.assetPool.textures as Map<string, TexturePoolEntry>;\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const counts = state.assetPool.counts!.textures as Map<string, number>;\r\n  return acquireItem<WebGLTexture>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    createFn: createFn as any,\r\n    globalMax: entryConfigOr(state, key, 'texturePoolSize'),\r\n    globalStrategy: entryStrategyOr(state, key, 'textureOverflowStrategy'),\r\n  });\r\n}\r\n\r\nexport function releaseTexture(\r\n  state: GameState,\r\n  key: string,\r\n  tex: WebGLTexture,\r\n  disposeFn?: (t: WebGLTexture) => void,\r\n) {\r\n  ensureAssetPool(state);\r\n  const poolMap = state.assetPool.textures as Map<string, TexturePoolEntry>;\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const counts = state.assetPool.counts!.textures as Map<string, number>;\r\n  return releaseItem<WebGLTexture>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    item: tex,\r\n    disposeFn: disposeFn as any,\r\n    globalMax: entryConfigOr(state, key, 'texturePoolSize'),\r\n    globalStrategy: entryStrategyOr(state, key, 'textureOverflowStrategy'),\r\n  });\r\n}\r\n\r\nexport function acquireSprite<T extends object>(\r\n  state: GameState,\r\n  key: string,\r\n  createFn: () => T & Pooled<T>,\r\n  initArgs?: Partial<T>,\r\n): T & Pooled<T> {\r\n  ensureAssetPool(state);\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const poolMap = state.assetPool.sprites as Map<string, PoolEntry<T & Pooled<T>>>;\r\n  const counts = state.assetPool.counts!.sprites as Map<string, number>;\r\n  return acquireItem<T & Pooled<T>>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    createFn: createFn as any,\r\n    globalMax: state.assetPool.config.spritePoolSize,\r\n    globalStrategy: _getStrategy(state.assetPool.config.spriteOverflowStrategy, 'discard-oldest'),\r\n    initFn: (obj: T & Pooled<T>, args?: Partial<T>) => {\r\n      try {\r\n        if (typeof obj.reset === 'function') obj.reset(args);\r\n        else if (args && typeof args === 'object') Object.assign(obj as any, args);\r\n      } catch {}\r\n    },\r\n    initArgs,\r\n  }) as T & Pooled<T>;\r\n}\r\n\r\nexport function releaseSprite<T extends object>(\r\n  state: GameState,\r\n  key: string,\r\n  sprite: T & Pooled<T>,\r\n  disposeFn?: (s: T) => void,\r\n) {\r\n  ensureAssetPool(state);\r\n  state.assetPool.counts = state.assetPool.counts || { textures: new Map(), sprites: new Map(), effects: new Map() } as any;\r\n  const poolMap = state.assetPool.sprites as Map<string, PoolEntry<T & Pooled<T>>>;\r\n  const counts = state.assetPool.counts!.sprites as Map<string, number>;\r\n  return releaseItem<T & Pooled<T>>({\r\n    map: poolMap,\r\n    counts,\r\n    key,\r\n    item: sprite,\r\n    disposeFn: disposeFn as any,\r\n    globalMax: state.assetPool.config.spritePoolSize,\r\n    globalStrategy: _getStrategy(state.assetPool.config.spriteOverflowStrategy, 'discard-oldest'),\r\n  });\r\n}\r\n\r\nexport default {} as any;\r\n", "export const SHIELD = {\r\n  ttl: 0.4, particleCount: 6, particleTTL: 0.5, particleColor: '#88ccff', particleSize: 2,\r\n  // arcWidth (radians) for shield hit visual/particle spread centered on hitAngle\r\n  // NOTE: Used in assetsConfig.ts visualStateDefaults and renderer logic. If not consumed, consider removing.\r\n  arcWidth: Math.PI / 6, // TODO: Ensure renderer/particle logic uses this or remove if redundant\r\n};\r\n\r\nexport const HEALTH = {\r\n  ttl: 0.6, particleCount: 8, particleTTL: 0.6, particleColor: '#ffb3b3', particleSize: 2.5,\r\n};\r\n\r\nexport const EXPLOSION = {\r\n  particleCount: 30, particleTTL: 1.2, particleColor: '#ffaa33', particleSize: 3, minSpeed: 20, maxSpeed: 140,\r\n  // TODO: Unify particle effect configs with assetsConfig.ts animations for maintainability\r\n};\r\n\r\nexport const FALLBACK_POSITIONS = [\r\n  { x: 100, y: 100, team: 'red' },\r\n  { x: 700, y: 500, team: 'blue' }\r\n];\r\n\r\nexport const STARS = { twinkle: true, redrawInterval: 500, count: 140 };\r\n\r\nexport default { SHIELD, HEALTH, EXPLOSION, STARS, FALLBACK_POSITIONS };\r\n", "\r\nexport function createGameManager({\r\n  useWorker = false,\r\n  renderer = null,\r\n  seed = 12345,\r\n  createSimWorker: createSimWorkerFactory,\r\n}: any = {}) {\r\n  function _evaluateAndEmit(dt: number) {\r\n    const result = evaluateReinforcement(dt, state, continuousOptions);\r\n    if (result && Array.isArray(result.spawned) && result.spawned.length) {\r\n      lastReinforcement = {\r\n        spawned: result.spawned,\r\n        timestamp: Date.now(),\r\n        options: { ...continuousOptions },\r\n      };\r\n      emit(\"reinforcements\", { spawned: result.spawned });\r\n    }\r\n  }\r\n  let state: GameState = makeInitialState();\r\n  let running = false;\r\n  const listeners = new Map<string, Function[]>();\r\n  const workerReadyCbs: Function[] = [];\r\n  let simWorker: any = null;\r\n  let _workerReadyHandler: Function | null = null;\r\n  let _workerSnapshotHandler: Function | null = null;\r\n  let _workerReinforcementsHandler: Function | null = null;\r\n  let workerReady = false;\r\n  let lastReinforcement: { spawned: any[]; timestamp: number; options: any } = {\r\n    spawned: [],\r\n    timestamp: 0,\r\n    options: {},\r\n  };\r\n  let continuous = false;\r\n  let continuousOptions: any = {};\r\n  let last = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\r\n  let acc = 0;\r\n  const score = { red: 0, blue: 0 };\r\n  const internal = { state, bounds: SIM.bounds };\r\n\r\n  function emit(type: string, msg: any) {\r\n    emitManagerEvent(listeners, type, msg);\r\n  }\r\n  function on(evt: string, cb: Function) {\r\n    const arr = listeners.get(evt) || [];\r\n    arr.push(cb);\r\n    listeners.set(evt, arr);\r\n  }\r\n  function off(evt: string, cb: Function) {\r\n    const arr = listeners.get(evt) || [];\r\n    const i = arr.indexOf(cb);\r\n    if (i !== -1) arr.splice(i, 1);\r\n  }\r\n  function destroy() {\r\n    running = false;\r\n    try {\r\n      if (simWorker) {\r\n        try {\r\n          if (typeof simWorker.off === \"function\") {\r\n            try { if (_workerReadyHandler) simWorker.off(\"ready\", _workerReadyHandler); } catch (e) {}\r\n            try { if (_workerSnapshotHandler) simWorker.off(\"snapshot\", _workerSnapshotHandler); } catch (e) {}\r\n            try { if (_workerReinforcementsHandler) simWorker.off(\"reinforcements\", _workerReinforcementsHandler); } catch (e) {}\r\n          }\r\n        } catch (e) {}\r\n        try { if (typeof simWorker.terminate === \"function\") simWorker.terminate(); else if (typeof simWorker.close === \"function\") simWorker.close(); else if (typeof simWorker.post === \"function\") simWorker.post({ type: \"stop\" }); } catch (e) {}\r\n        simWorker = null;\r\n      }\r\n    } catch (e) {}\r\n    workerReady = false;\r\n    workerReadyCbs.length = 0;\r\n  }\r\n  function start() {\r\n    if (!running) {\r\n      running = true;\r\n      last = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\r\n      runLoop();\r\n    }\r\n  }\r\n  function pause() {\r\n    running = false;\r\n  }\r\n  function resetManager() {\r\n    state = makeInitialState();\r\n    if (simWorker)\r\n      try {\r\n        simWorker.post({ type: \"command\", cmd: \"setState\", args: { state } });\r\n      } catch (e) {}\r\n  }\r\n  function stepOnce(dt = SIM.DT_MS / 1000) {\r\n    const n = Number(dt) || SIM.DT_MS / 1000;\r\n    step(n);\r\n  }\r\n  function step(dtSeconds: number) {\r\n    const clampedDt = Math.min(dtSeconds, 0.05);\r\n    if (!simWorker) {\r\n      try { applySimpleAI(state, clampedDt, SIM.bounds); } catch (e) {}\r\n      try { simulateStep(state, clampedDt, SIM.bounds); } catch (e) {}\r\n    } else {\r\n      try { simWorker.post && simWorker.post({ type: \"snapshotRequest\" }); } catch (e) {}\r\n    }\r\n    _evaluateAndEmit(clampedDt);\r\n    if (renderer && typeof renderer.renderState === \"function\") {\r\n      try {\r\n        renderer.renderState({\r\n          ships: state.ships,\r\n          bullets: state.bullets,\r\n          flashes: state.flashes,\r\n          shieldFlashes: state.shieldFlashes,\r\n          healthFlashes: state.healthFlashes,\r\n          t: state.t,\r\n        });\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  function runLoop() {\r\n    if (!running) return;\r\n    const now = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\r\n    acc += now - last;\r\n    last = now;\r\n    if (acc > 250) acc = 250;\r\n    while (acc >= SIM.DT_MS) {\r\n      step(SIM.DT_MS / 1000);\r\n      acc -= SIM.DT_MS;\r\n    }\r\n    try { requestAnimationFrame(runLoop); } catch (e) { setTimeout(runLoop, SIM.DT_MS); }\r\n  }\r\n  function setContinuousEnabled(v: boolean = false) {\r\n    continuous = !!v;\r\n    if (simWorker) {\r\n      try { simWorker.post({ type: \"setContinuous\", value: !!v }); } catch (e) {}\r\n    } else {\r\n      if (continuous) {\r\n        const result = evaluateReinforcement(SIM.DT_MS / 1000, state, continuousOptions);\r\n        if (result && Array.isArray(result.spawned) && result.spawned.length) {\r\n          lastReinforcement = {\r\n            spawned: result.spawned,\r\n            timestamp: Date.now(),\r\n            options: { ...continuousOptions },\r\n          };\r\n          emit(\"reinforcements\", { spawned: result.spawned });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function isContinuousEnabled() { return !!continuous; }\r\n  function setContinuousOptions(opts: any = {}) {\r\n    continuousOptions = { ...continuousOptions, ...opts };\r\n    if (simWorker)\r\n      try { simWorker.post({ type: \"setContinuousOptions\", opts: continuousOptions }); } catch (e) {}\r\n  }\r\n  function getContinuousOptions() { return { ...continuousOptions }; }\r\n  function setReinforcementIntervalManager(seconds: number) {\r\n    setReinforcementInterval(seconds);\r\n    if (simWorker)\r\n      try { simWorker.post({ type: \"setReinforcementInterval\", seconds }); } catch (e) {}\r\n  }\r\n  function getReinforcementIntervalManager() { return getReinforcementInterval(); }\r\n  function isRunning() { return running; }\r\n  function isWorker() { return !!simWorker && !!workerReady; }\r\n  function onWorkerReady(cb: Function) { if (typeof cb === \"function\") workerReadyCbs.push(cb); }\r\n  function offWorkerReady(cb: Function) { const i = workerReadyCbs.indexOf(cb); if (i !== -1) workerReadyCbs.splice(i, 1); }\r\n  function spawnShip(team: string = \"red\", type?: string) {\r\n    try {\r\n      const shipType = type || getDefaultShipType();\r\n      const b = SIM.bounds;\r\n      const x = Math.max(0, Math.min(b.W - 1e-6, srandom() * b.W));\r\n      const y = Math.max(0, Math.min(b.H - 1e-6, srandom() * b.H));\r\n      const ship = createShip(shipType, x, y, team);\r\n      state.ships.push(ship);\r\n      return ship;\r\n    } catch (e) { return null; }\r\n  }\r\n  function formFleets() {\r\n    try {\r\n      state.ships.length = 0;\r\n      const bounds = SIM.bounds;\r\n      const seedVal = Math.floor(srandom() * 0xffffffff) >>> 0;\r\n      const ships = makeInitialFleets(seedVal, bounds, createShip);\r\n      for (const ship of ships) {\r\n        state.ships.push(ship);\r\n      }\r\n    } catch (e) {}\r\n  }\r\n  function reseedManager(newSeed: number = Math.floor(srandom() * 0xffffffff)) {\r\n    _seed = newSeed >>> 0;\r\n    srand(_seed);\r\n    if (simWorker)\r\n      try { simWorker.post({ type: \"setSeed\", seed: _seed }); } catch (e) {}\r\n  }\r\n  function getLastReinforcement() { return { ...lastReinforcement }; }\r\n  function snapshot() {\r\n    return {\r\n      ships: state.ships.slice(),\r\n      bullets: state.bullets.slice(),\r\n      t: state.t,\r\n      teamCounts: state.teamCounts ? { ...state.teamCounts } : {},\r\n      flashes: state.flashes ? state.flashes.slice() : [],\r\n      shieldFlashes: state.shieldFlashes ? state.shieldFlashes.slice() : [],\r\n      healthFlashes: state.healthFlashes ? state.healthFlashes.slice() : [],\r\n    };\r\n  }\r\n  // Worker setup (optional, not used in current UI)\r\n  try {\r\n    if (useWorker) {\r\n      const factory = createSimWorkerFactory || createSimWorker;\r\n      let simWorkerUrl;\r\n      try {\r\n        simWorkerUrl = typeof import.meta !== \"undefined\" && import.meta.url ? new URL(\"./simWorker.js\", import.meta.url).href : \"./simWorker.js\";\r\n      } catch (e) { simWorkerUrl = \"./simWorker.js\"; }\r\n      simWorker = factory(simWorkerUrl);\r\n      _workerReadyHandler = () => {\r\n        workerReady = true;\r\n        for (const cb of workerReadyCbs.slice()) { try { cb(); } catch (e) {} }\r\n      };\r\n      simWorker.on && simWorker.on(\"ready\", _workerReadyHandler);\r\n      _workerSnapshotHandler = (m: any) => { if (m && m.state) state = m.state; };\r\n      simWorker.on && simWorker.on(\"snapshot\", _workerSnapshotHandler);\r\n      _workerReinforcementsHandler = (m: any) => { emit(\"reinforcements\", m); };\r\n      simWorker.on && simWorker.on(\"reinforcements\", _workerReinforcementsHandler);\r\n      try {\r\n        simWorker.post({ type: \"init\", seed, bounds: SIM.bounds, simDtMs: SIM.DT_MS, state });\r\n        simWorker.post({ type: \"start\" });\r\n      } catch (e) {}\r\n    }\r\n  } catch (e) { simWorker = null; }\r\n\r\n  return {\r\n    on,\r\n    off,\r\n    start,\r\n    pause,\r\n    reset: resetManager,\r\n    stepOnce,\r\n    setContinuousEnabled,\r\n    isContinuousEnabled,\r\n    setContinuousOptions,\r\n    getContinuousOptions,\r\n    setReinforcementInterval: setReinforcementIntervalManager,\r\n    getReinforcementInterval: getReinforcementIntervalManager,\r\n    isRunning,\r\n    isWorker,\r\n    onWorkerReady,\r\n    offWorkerReady,\r\n    spawnShip,\r\n    reseed: reseedManager,\r\n    getLastReinforcement,\r\n    snapshot,\r\n    score,\r\n    formFleets,\r\n    destroy,\r\n    _internal: internal,\r\n  };\r\n}\r\n\r\nexport default createGameManager;\r\nexport function releaseParticle(state: GameState, p?: Particle) {\r\n  if (!p) return;\r\n  const key = \"particle\";\r\n  try {\r\n    releaseEffect(state, key, p, (x) => {\r\n      /* no-op */\r\n    });\r\n  } catch {}\r\n  const idx = (state.particles || []).indexOf(p);\r\n  if (idx !== -1) (state.particles || []).splice(idx, 1);\r\n}\r\n// Minimal TypeScript shim that re-exports the existing JavaScript runtime implementation.\r\n// Import the runtime as a namespace and re-export value bindings to avoid\r\n// circular alias issues. Types are defined in `gamemanager.d.ts`.\r\n\r\n// Ported from gamemanager.js, now canonical TypeScript implementation\r\nimport {\r\n  makeInitialState,\r\n  createShip,\r\n  Ship,\r\n  Bullet,\r\n  genId,\r\n  ExplosionEffect,\r\n  ShieldHitEffect,\r\n  HealthHitEffect,\r\n  createExplosionEffect,\r\n  resetExplosionEffect,\r\n  createShieldHitEffect,\r\n  resetShieldHitEffect,\r\n  createHealthHitEffect,\r\n  resetHealthHitEffect,\r\n  normalizeTurrets,\r\n  normalizeStateShips,\r\n} from \"./entities\";\r\nimport { updateTeamCount } from \"./entities\";\r\nimport { PARTICLE_DEFAULTS } from \"./config/entitiesConfig\";\r\nimport { applySimpleAI } from \"./behavior\";\r\nimport { simulateStep } from \"./simulate\";\r\nimport { SIM } from \"./config/simConfig\";\r\nimport { srand, srandom } from \"./rng\";\r\nimport { createSimWorker } from \"./createSimWorker\";\r\nimport {\r\n  acquireEffect,\r\n  releaseEffect,\r\n  acquireSprite,\r\n  releaseSprite,\r\n  makePooled,\r\n} from \"./pools\";\r\nimport {\r\n  SHIELD,\r\n  HEALTH,\r\n  EXPLOSION,\r\n  STARS,\r\n  FALLBACK_POSITIONS,\r\n} from \"./config/gamemanagerConfig\";\r\nimport type { ShipConfigMap, GameState } from \"./types\";\r\nimport { getShipConfig, getDefaultShipType } from \"./config/entitiesConfig\";\r\nimport {\r\n  chooseReinforcementsWithManagerSeed,\r\n  makeInitialFleets,\r\n  TeamsConfig,\r\n} from \"./config/teamsConfig\";\r\n\r\n// All runtime arrays are now managed via GameState for determinism and lifecycle control.\r\n// Bullet pooling\r\n// Bullets: support optional GameState-backed pooling. If `state` is provided,\r\n// use state.assetPool.sprites keyed by 'bullet', otherwise fallback to legacy in-memory pool.\r\nexport function acquireBullet(\r\n  state: GameState,\r\n  opts: Partial<Bullet> = {},\r\n): Bullet {\r\n  // Defensive: accept minimal/mocked state objects in tests by ensuring\r\n  // required collections exist. Do not overwrite existing richer assetPool.\r\n  if (!state) state = makeInitialState() as GameState;\r\n  (state as any).bullets = (state as any).bullets || [];\r\n  (state as any).assetPool = (state as any).assetPool || {\r\n    textures: new Map(),\r\n    sprites: new Map(),\r\n    effects: new Map(),\r\n    counts: {\r\n      textures: new Map(),\r\n      sprites: new Map(),\r\n      effects: new Map(),\r\n    },\r\n    config: {\r\n      texturePoolSize: 128,\r\n      spritePoolSize: 256,\r\n      effectPoolSize: 128,\r\n      textureOverflowStrategy: \"discard-oldest\",\r\n      spriteOverflowStrategy: \"discard-oldest\",\r\n      effectOverflowStrategy: \"discard-oldest\",\r\n    },\r\n  };\r\n  // Use state-backed sprite pool keyed by 'bullet'\r\n  const key = \"bullet\";\r\n  const b = acquireSprite(\r\n    state,\r\n    key,\r\n    () =>\r\n      makePooled(\r\n        { ...opts, id: genId(), alive: true } as any,\r\n        (o: any, initArgs?: any) => Object.assign(o, initArgs),\r\n      ),\r\n    opts,\r\n  ) as Bullet & any;\r\n  // push into the state-active array so simulation sees it\r\n  (state.bullets ||= []).push(b as Bullet);\r\n  return b;\r\n}\r\n\r\nexport function releaseBullet(state: GameState, b?: Bullet): void {\r\n  if (!b) return;\r\n  if (!b.alive) return; // Prevent double-free\r\n  b.alive = false;\r\n  // remove from the state's active bullets\r\n  const arr = state.bullets || ([] as Bullet[]);\r\n  const idx = arr.indexOf(b as Bullet);\r\n  if (idx !== -1) arr.splice(idx, 1);\r\n  releaseSprite(state, \"bullet\", b as any, undefined);\r\n}\r\n\r\n// Explosion pooling\r\nexport function acquireExplosion(\r\n  state: GameState,\r\n  opts: Partial<ExplosionEffect> = {},\r\n): ExplosionEffect {\r\n  const key = \"explosion\";\r\n  const e = acquireEffect<ExplosionEffect>(\r\n    state,\r\n    key,\r\n    () => makePooled(createExplosionEffect(opts), resetExplosionEffect),\r\n    opts,\r\n  );\r\n  (state.explosions ||= []).push(e);\r\n  return e;\r\n}\r\n\r\nexport function releaseExplosion(state: GameState, e?: ExplosionEffect) {\r\n  if (!e) return;\r\n  if (e._pooled) return;\r\n  if (!e.alive) return;\r\n  e.alive = false;\r\n  e._pooled = true;\r\n  const arr = state.explosions || ([] as ExplosionEffect[]);\r\n  const idx = arr.indexOf(e);\r\n  if (idx !== -1) arr.splice(idx, 1);\r\n  releaseEffect(state, \"explosion\", e, undefined);\r\n}\r\n\r\n// ShieldHit pooling\r\nexport function acquireShieldHit(\r\n  state: GameState,\r\n  opts: Partial<ShieldHitEffect> = {},\r\n): ShieldHitEffect {\r\n  const key = \"shieldHit\";\r\n  const sh = acquireEffect<ShieldHitEffect>(\r\n    state,\r\n    key,\r\n    () => makePooled(createShieldHitEffect(opts), resetShieldHitEffect),\r\n    opts,\r\n  );\r\n  (state.shieldHits ||= []).push(sh);\r\n  return sh;\r\n}\r\n\r\nexport function releaseShieldHit(state: GameState, sh?: ShieldHitEffect) {\r\n  if (!sh) return;\r\n  if (sh._pooled) return;\r\n  const arr = state.shieldHits || ([] as ShieldHitEffect[]);\r\n  const i = arr.indexOf(sh);\r\n  if (i !== -1) arr.splice(i, 1);\r\n  sh.alive = false;\r\n  sh._pooled = true;\r\n  releaseEffect(state, \"shieldHit\", sh, undefined);\r\n}\r\n\r\n// HealthHit pooling\r\nexport function acquireHealthHit(\r\n  state: GameState,\r\n  opts: Partial<HealthHitEffect> = {},\r\n): HealthHitEffect {\r\n  const key = \"healthHit\";\r\n  const hh = acquireEffect<HealthHitEffect>(\r\n    state,\r\n    key,\r\n    () => makePooled(createHealthHitEffect(opts), resetHealthHitEffect),\r\n    opts,\r\n  );\r\n  (state.healthHits ||= []).push(hh);\r\n  return hh;\r\n}\r\n\r\nexport function releaseHealthHit(state: GameState, hh?: HealthHitEffect) {\r\n  if (!hh) return;\r\n  if (hh._pooled) return;\r\n  const arr = state.healthHits || ([] as HealthHitEffect[]);\r\n  const i = arr.indexOf(hh);\r\n  if (i !== -1) arr.splice(i, 1);\r\n  hh.alive = false;\r\n  hh._pooled = true;\r\n  releaseEffect(state, \"healthHit\", hh, undefined);\r\n}\r\n\r\nexport const config = {\r\n  shield: { ...SHIELD },\r\n  health: { ...HEALTH },\r\n  explosion: { ...EXPLOSION },\r\n  stars: { ...STARS },\r\n};\r\n\r\nlet _seed: number | null = null;\r\nlet _reinforcementInterval: number =\r\n  TeamsConfig.continuousReinforcement?.interval ?? 5.0;\r\nlet _reinforcementAccumulator = 0;\r\nlet _starCanvasVersion = 0;\r\nlet starCanvas: HTMLCanvasElement | null = null;\r\nlet _lastSimulateFrameId: number | null = null;\r\nlet _doubleSimStrict = false;\r\n\r\nexport function setDoubleSimStrict(v: boolean = false) {\r\n  _doubleSimStrict = !!v;\r\n}\r\n\r\nexport class Particle {\r\n  x: number;\r\n  y: number;\r\n  vx: number;\r\n  vy: number;\r\n  ttl: number;\r\n  life: number;\r\n  color: string;\r\n  size: number;\r\n  alive: boolean;\r\n  _pooled?: boolean; // Add pooled flag to prevent double-free\r\n  constructor(x = 0, y = 0, vx = 0, vy = 0, ttl = 1, color = \"#fff\", size = 2) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.vx = vx;\r\n    this.vy = vy;\r\n    this.ttl = ttl;\r\n    this.life = ttl;\r\n    this.color = color;\r\n    this.size = size;\r\n    this.alive = true;\r\n    this._pooled = false;\r\n  }\r\n}\r\n\r\nexport function acquireParticle(\r\n  state: GameState,\r\n  x: number,\r\n  y: number,\r\n  opts: Partial<Particle> = {},\r\n): Particle {\r\n  const key = \"particle\";\r\n  const poolConfig = state.assetPool?.config || {};\r\n  const maxSize = poolConfig.effectPoolSize ?? 128;\r\n  const overflowStrategy = poolConfig.effectOverflowStrategy ?? \"discard-oldest\";\r\n  // Defensive: prune oldest if pool is full\r\n  if ((state.particles?.length ?? 0) >= maxSize) {\r\n    if (overflowStrategy === \"discard-oldest\" && state.particles?.length) {\r\n      state.particles?.shift();\r\n    } else if (overflowStrategy === \"error\") {\r\n      // Do not add new particle, return null\r\n      return null as any;\r\n    } // \"grow\" allows pool to grow\r\n  }\r\n  // Create a pooled Particle instance\r\n  const p = acquireEffect<Particle>(\r\n    state,\r\n    key,\r\n    () => makePooled(new Particle(x, y, opts.vx ?? 0, opts.vy ?? 0, opts.ttl ?? PARTICLE_DEFAULTS.ttl, opts.color ?? PARTICLE_DEFAULTS.color, opts.size ?? PARTICLE_DEFAULTS.size), undefined),\r\n    {\r\n      x,\r\n      y,\r\n      vx: opts.vx ?? 0,\r\n      vy: opts.vy ?? 0,\r\n      ttl: opts.ttl ?? PARTICLE_DEFAULTS.ttl,\r\n      color: opts.color ?? PARTICLE_DEFAULTS.color,\r\n      size: opts.size ?? PARTICLE_DEFAULTS.size,\r\n    },\r\n  );\r\n  // Rehydrate properties\r\n  p.x = x;\r\n  p.y = y;\r\n  p.vx = opts.vx ?? 0;\r\n  p.vy = opts.vy ?? 0;\r\n  p.ttl = opts.ttl ?? PARTICLE_DEFAULTS.ttl;\r\n  p.life = p.ttl;\r\n  p.color = opts.color ?? PARTICLE_DEFAULTS.color;\r\n  p.size = opts.size ?? PARTICLE_DEFAULTS.size;\r\n  p.alive = true;\r\n  (state.particles ||= []).push(p);\r\n  return p;\r\n}\r\n\r\nexport function createStarCanvas(\r\n  state: GameState,\r\n  W = 800,\r\n  H = 600,\r\n  bg = \"#041018\",\r\n): HTMLCanvasElement | null {\r\n  if (!state || !Array.isArray(state.stars)) return null;\r\n  try {\r\n    const c =\r\n      typeof document !== \"undefined\" && document.createElement\r\n        ? document.createElement(\"canvas\")\r\n        : null;\r\n    if (!c) return null;\r\n    c.width = Math.max(1, Math.floor(W));\r\n    c.height = Math.max(1, Math.floor(H));\r\n    const ctx = c.getContext && c.getContext(\"2d\");\r\n    if (ctx) {\r\n      ctx.fillStyle = bg;\r\n      ctx.fillRect(0, 0, c.width, c.height);\r\n      for (const s of state.stars) {\r\n        const alpha = Math.max(\r\n          0,\r\n          Math.min(1, s.a != null ? s.a : s.baseA != null ? s.baseA : 1),\r\n        );\r\n        ctx.beginPath();\r\n        ctx.fillStyle = `rgba(255,255,255,${alpha})`;\r\n        const rr = Math.max(0.2, s.r || 0.5);\r\n        ctx.arc(s.x || 0, s.y || 0, rr, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n    }\r\n    _starCanvasVersion = (_starCanvasVersion || 0) + 1;\r\n    (c as any)._version = _starCanvasVersion;\r\n    starCanvas = c;\r\n    return c;\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function getStarCanvasVersion() {\r\n  return _starCanvasVersion;\r\n}\r\n\r\nexport function setReinforcementInterval(seconds: number) {\r\n  _reinforcementInterval =\r\n    Number(seconds) || (TeamsConfig.continuousReinforcement?.interval ?? 5.0);\r\n}\r\nexport function getReinforcementInterval() {\r\n  return _reinforcementInterval;\r\n}\r\n\r\nfunction emitManagerEvent(\r\n  map: Map<string, Function[]>,\r\n  type: string,\r\n  data: any,\r\n) {\r\n  const arr = map.get(type) || [];\r\n  for (const cb of arr.slice()) {\r\n    try {\r\n      if (typeof cb === \"function\") cb(data);\r\n    } catch (e) {}\r\n  }\r\n}\r\n\r\nfunction evaluateReinforcement(\r\n  dt: number,\r\n  state: GameState,\r\n  continuousOptions: any = {},\r\n): { spawned: any[] } | null {\r\n  _reinforcementAccumulator += dt;\r\n  if (_reinforcementAccumulator >= _reinforcementInterval) {\r\n    _reinforcementAccumulator = 0;\r\n    try {\r\n      if (typeof chooseReinforcementsWithManagerSeed === \"function\") {\r\n        const orders = chooseReinforcementsWithManagerSeed(state, {\r\n          ...continuousOptions,\r\n          bounds: SIM.bounds,\r\n          enabled: true,\r\n        });\r\n        if (Array.isArray(orders) && orders.length) {\r\n          const spawned: any[] = [];\r\n          for (const o of orders) {\r\n            try {\r\n              const ship = createShip(\r\n                o.type || getDefaultShipType(),\r\n                o.x || 100,\r\n                o.y || 100,\r\n                o.team || \"red\",\r\n              );\r\n              state.ships.push(ship);\r\n              try {\r\n                (state as any).shipMap &&\r\n                  (state as any).shipMap.set(ship.id, ship);\r\n              } catch (e) {}\r\n              try {\r\n                updateTeamCount(state, undefined, ship.team);\r\n              } catch (e) {}\r\n              spawned.push(ship);\r\n            } catch (e) {}\r\n          }\r\n          return { spawned };\r\n        }\r\n      }\r\n      const fallback = getDefaultShipType();\r\n      const r = createShip(\r\n        fallback,\r\n        FALLBACK_POSITIONS[0].x,\r\n        FALLBACK_POSITIONS[0].y,\r\n        FALLBACK_POSITIONS[0].team,\r\n      );\r\n      const b = createShip(\r\n        fallback,\r\n        FALLBACK_POSITIONS[1].x,\r\n        FALLBACK_POSITIONS[1].y,\r\n        FALLBACK_POSITIONS[1].team,\r\n      );\r\n      state.ships.push(r);\r\n      try {\r\n        (state as any).shipMap && (state as any).shipMap.set(r.id, r);\r\n      } catch (e) {}\r\n      try {\r\n        updateTeamCount(state, undefined, String(r.team));\r\n      } catch (e) {}\r\n      state.ships.push(b);\r\n      try {\r\n        (state as any).shipMap && (state as any).shipMap.set(b.id, b);\r\n      } catch (e) {}\r\n      try {\r\n        updateTeamCount(state, undefined, String(b.team));\r\n      } catch (e) {}\r\n      return { spawned: [r, b] };\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function simulate(dt: number, W = 800, H = 600) {\r\n  try {\r\n    const now =\r\n      typeof performance !== \"undefined\" && performance.now\r\n        ? performance.now()\r\n        : Date.now();\r\n    const frame = Math.floor(now / 4);\r\n    if (_lastSimulateFrameId === frame) {\r\n      const msg =\r\n        \"[gamemanager] detected simulate() called multiple times in same frame\";\r\n      if (_doubleSimStrict) throw new Error(msg);\r\n      else console.warn(msg);\r\n    }\r\n    _lastSimulateFrameId = frame;\r\n  } catch (e) {}\r\n  // Build a canonical GameState using makeInitialState to ensure assetPool exists\r\n  const state: GameState = makeInitialState();\r\n  (state as any).t = 0;\r\n  // No global arrays; all arrays are managed via GameState\r\n  evaluateReinforcement(dt, state);\r\n  try {\r\n    simulateStep(state, dt, SIM.bounds);\r\n  } catch (e) {}\r\n  // No global state to clear; callers should pass `state` explicitly to helpers.\r\n  return state;\r\n}\r\n\r\n\r\nexport function processStateEvents(state: any, dt: number = 0) {\r\n  return state;\r\n}\r\n", "export const EVASIVE_DURATION = 0.8; // seconds\r\nexport const TURN_RATES = { default: 4.0 } as const; // radians per second typical turn rate\r\nexport const EVASIVE_THRUST_MULT = 1.5; // multiplier for thrust during evasive maneuvers\r\nexport const SEPARATION_MULT = 0.6; // separation force multiplier between ships\r\n\r\n// AI logic thresholds and decision timer\r\nexport const AI_THRESHOLDS = {\r\n  decisionTimerMin: 0.5,\r\n  decisionTimerMax: 2.0,\r\n  hpEvadeThreshold: 0.35,\r\n  randomLow: 0.15,\r\n  randomHigh: 0.85,\r\n};\r\n\r\n// Ship movement global defaults (used if not per-ship)\r\nexport const SHIP_MOVEMENT_DEFAULTS = {\r\n  maxSpeed: 160,\r\n  maxAccel: 5,\r\n};\r\n\r\nexport default {\r\n  EVASIVE_DURATION,\r\n  TURN_RATES,\r\n  EVASIVE_THRUST_MULT,\r\n  SEPARATION_MULT,\r\n  AI_THRESHOLDS,\r\n  SHIP_MOVEMENT_DEFAULTS,\r\n};\r\n", "// behavior.ts - deterministic, simple AI for steering and firing\r\n// Uses seeded RNG for any randomness so results are reproducible.\r\nimport { srandom, srange } from \"./rng\";\r\nimport { createBullet } from \"./entities\";\r\nimport { acquireBullet } from \"./gamemanager\";\r\nimport { AI_THRESHOLDS, SHIP_MOVEMENT_DEFAULTS } from \"./config/behaviorConfig\";\r\nimport { BULLET_DEFAULTS, getShipConfig } from \"./config/entitiesConfig\";\r\nimport { TEAM_DEFAULT } from \"./config/teamsConfig\";\r\n\r\ntype ShipLike = {\r\n  id?: number;\r\n  x?: number;\r\n  y?: number;\r\n  vx?: number;\r\n  vy?: number;\r\n  team?: string;\r\n  hp?: number;\r\n  maxHp?: number;\r\n  cannons?: any[];\r\n  accel?: number; // max acceleration from config\r\n  currentAccel?: number; // dynamic, set by AI/gamemanager, 0..accel\r\n  radius?: number;\r\n  turnRate?: number;\r\n  damage?: number;\r\n  dmg?: number;\r\n  maxSpeed?: number; // NEW: max speed per ship\r\n  steering?: number; // NEW: steering intent (-1..1)\r\n  throttle?: number; // NEW: throttle intent (0..1)\r\n  __ai?: any;\r\n  turrets?: any[];\r\n  angle?: number;\r\n  type?: string; // Added for config sync\r\n};\r\n\r\nimport type { GameState } from \"./types\";\r\nimport { getDefaultBounds } from './config/simConfig';\r\ntype State = GameState;\r\n\r\nfunction len2(vx: number, vy: number) {\r\n  return vx * vx + vy * vy;\r\n}\r\nconst DEFAULT_BULLET_RANGE =\r\n  typeof BULLET_DEFAULTS.range === \"number\" ? BULLET_DEFAULTS.range : 300;\r\nfunction withinRange(\r\n  sx: number,\r\n  sy: number,\r\n  tx: number,\r\n  ty: number,\r\n  range: number,\r\n) {\r\n  const dx = tx - sx;\r\n  const dy = ty - sy;\r\n  return dx * dx + dy * dy <= range * range;\r\n}\r\nfunction clampSpeed(s: ShipLike, max: number) {\r\n  const v2 = len2(s.vx || 0, s.vy || 0);\r\n\r\n  const max2 = max * max;\r\n  if (v2 > max2 && v2 > 0) {\r\n    const inv = max / Math.sqrt(v2);\r\n    s.vx = (s.vx || 0) * inv;\r\n    s.vy = (s.vy || 0) * inv;\r\n  }\r\n}\r\n\r\nexport { clampSpeed };\r\n\r\nfunction aimWithSpread(from: ShipLike, to: ShipLike, spread = 0) {\r\n  let dx = (to.x || 0) - (from.x || 0);\r\n  let dy = (to.y || 0) - (from.y || 0);\r\n  const d = Math.hypot(dx, dy) || 1;\r\n  dx /= d;\r\n  dy /= d;\r\n  if (spread > 0) {\r\n    const ang = Math.atan2(dy, dx);\r\n    const jitter = srange(-spread, spread);\r\n    const na = ang + jitter;\r\n    return { x: Math.cos(na), y: Math.sin(na) };\r\n  }\r\n  return { x: dx, y: dy };\r\n}\r\n\r\nfunction tryFire(state: State, ship: ShipLike, target: ShipLike, dt: number) {\r\n  // Legacy cannons (single target, all fire at once)\r\n  if (Array.isArray(ship.cannons) && ship.cannons.length > 0) {\r\n    for (const c of ship.cannons) {\r\n      if (typeof c.__cd !== \"number\") c.__cd = 0;\r\n      c.__cd -= dt;\r\n      if (c.__cd > 0) continue;\r\n      const range =\r\n        typeof c.range === \"number\" ? c.range : DEFAULT_BULLET_RANGE;\r\n      if (\r\n        !withinRange(\r\n          ship.x || 0,\r\n          ship.y || 0,\r\n          target.x || 0,\r\n          target.y || 0,\r\n          range,\r\n        )\r\n      )\r\n        continue;\r\n      const spread = typeof c.spread === \"number\" ? c.spread : 0;\r\n      const dir = aimWithSpread(ship, target, spread);\r\n      const speed =\r\n        typeof c.muzzleSpeed === \"number\"\r\n          ? c.muzzleSpeed\r\n          : BULLET_DEFAULTS.muzzleSpeed;\r\n      const dmg =\r\n        typeof c.damage === \"number\"\r\n          ? c.damage\r\n          : typeof ship.damage === \"number\"\r\n            ? ship.damage\r\n            : typeof ship.dmg === \"number\"\r\n              ? ship.dmg\r\n              : BULLET_DEFAULTS.damage;\r\n      const ttl =\r\n        typeof c.bulletTTL === \"number\" ? c.bulletTTL : BULLET_DEFAULTS.ttl;\r\n      const radius =\r\n        typeof c.bulletRadius === \"number\"\r\n          ? c.bulletRadius\r\n          : BULLET_DEFAULTS.radius;\r\n      const vx = dir.x * speed;\r\n      const vy = dir.y * speed;\r\n      const b = Object.assign(\r\n        acquireBullet(state, {\r\n          x: ship.x || 0,\r\n          y: ship.y || 0,\r\n          vx,\r\n          vy,\r\n          team: ship.team || TEAM_DEFAULT,\r\n          ownerId: ship.id || null,\r\n          damage: dmg,\r\n          ttl,\r\n        }),\r\n        { radius },\r\n      );\r\n      const rate = typeof c.rate === \"number\" && c.rate > 0 ? c.rate : 1;\r\n      c.__cd = 1 / rate;\r\n    }\r\n  }\r\n  // Multi-turret support: each turret fires independently\r\n  if (Array.isArray(ship.turrets) && ship.turrets.length > 0) {\r\n    for (const [i, turret] of ship.turrets.entries()) {\r\n      if (!turret) continue;\r\n      if (typeof turret.__cd !== \"number\") turret.__cd = 0;\r\n      turret.__cd -= dt;\r\n      if (turret.__cd > 0) continue;\r\n      // Target selection per turret\r\n      let turretTarget: ShipLike | null = null;\r\n      if (turret.targeting === \"nearest\") {\r\n        const enemies = (state.ships || []).filter(\r\n          (sh) => sh && sh.team !== ship.team,\r\n        );\r\n        let minDist = Infinity;\r\n        for (const enemy of enemies) {\r\n          const dx = (enemy.x || 0) - (ship.x || 0);\r\n          const dy = (enemy.y || 0) - (ship.y || 0);\r\n          const d2 = dx * dx + dy * dy;\r\n          if (d2 < minDist) {\r\n            minDist = d2;\r\n            turretTarget = enemy;\r\n          }\r\n        }\r\n      } else if (turret.targeting === \"random\") {\r\n        const enemies = (state.ships || []).filter(\r\n          (sh) => sh && sh.team !== ship.team,\r\n        );\r\n        if (enemies.length)\r\n          turretTarget = enemies[Math.floor(srandom() * enemies.length)];\r\n      } else if (turret.targeting === \"focus\") {\r\n        // Use ship's main target if available (O(1) via shipMap)\r\n        if (ship.__ai && ship.__ai.targetId != null) {\r\n          const tId = ship.__ai.targetId as number | string | null;\r\n          turretTarget =\r\n            (state as any).shipMap && typeof tId !== \"undefined\" && tId !== null\r\n              ? (state as any).shipMap.get(Number(tId)) || null\r\n              : (state.ships || []).find((sh) => sh && sh.id === tId) || null;\r\n        }\r\n      } else {\r\n        // Default: nearest\r\n        const enemies = (state.ships || []).filter(\r\n          (sh) => sh && sh.team !== ship.team,\r\n        );\r\n        let minDist = Infinity;\r\n        for (const enemy of enemies) {\r\n          const dx = (enemy.x || 0) - (ship.x || 0);\r\n          const dy = (enemy.y || 0) - (ship.y || 0);\r\n          const d2 = dx * dx + dy * dy;\r\n          if (d2 < minDist) {\r\n            minDist = d2;\r\n            turretTarget = enemy;\r\n          }\r\n        }\r\n      }\r\n      if (!turretTarget) continue;\r\n      // Fire from turret position (relative to ship center, using config radius)\r\n      const spread = typeof turret.spread === \"number\" ? turret.spread : 0.05;\r\n      const dir = aimWithSpread(ship, turretTarget, spread);\r\n      const speed =\r\n        typeof turret.muzzleSpeed === \"number\"\r\n          ? turret.muzzleSpeed\r\n          : BULLET_DEFAULTS.muzzleSpeed;\r\n      const dmg =\r\n        typeof turret.damage === \"number\"\r\n          ? turret.damage\r\n          : typeof ship.damage === \"number\"\r\n            ? ship.damage\r\n            : BULLET_DEFAULTS.damage;\r\n      const ttl =\r\n        typeof turret.bulletTTL === \"number\"\r\n          ? turret.bulletTTL\r\n          : BULLET_DEFAULTS.ttl;\r\n      const radius =\r\n        typeof turret.bulletRadius === \"number\"\r\n          ? turret.bulletRadius\r\n          : BULLET_DEFAULTS.radius;\r\n      // Always use config radius for turret position\r\n      const angle = ship.angle || 0;\r\n      // Get latest config radius for this ship type\r\n      const shipType = ship.type || \"fighter\";\r\n      const shipCfg = getShipConfig()[shipType];\r\n      const configRadius =\r\n        shipCfg && typeof shipCfg.radius === \"number\"\r\n          ? shipCfg.radius\r\n          : ship.radius || 12;\r\n      // Accept both object-style turrets ({ position: [x,y] }) and tuple-style\r\n      // shorthand ([x,y]) which the renderer commonly uses. Support both here\r\n      // so bullets spawn from the same mountpoints that are drawn.\r\n      const pos =\r\n        Array.isArray(turret) && turret.length === 2\r\n          ? turret\r\n          : turret && Array.isArray((turret as any).position)\r\n            ? (turret as any).position\r\n            : [0, 0];\r\n      const [tx, ty] = pos;\r\n      const turretX =\r\n        (ship.x || 0) +\r\n        Math.cos(angle) * tx * configRadius -\r\n        Math.sin(angle) * ty * configRadius;\r\n      const turretY =\r\n        (ship.y || 0) +\r\n        Math.sin(angle) * tx * configRadius +\r\n        Math.cos(angle) * ty * configRadius;\r\n      const range =\r\n        typeof turret.range === \"number\" ? turret.range : DEFAULT_BULLET_RANGE;\r\n      const dxT = (turretTarget.x || 0) - turretX;\r\n      const dyT = (turretTarget.y || 0) - turretY;\r\n      if (dxT * dxT + dyT * dyT > range * range) continue;\r\n      const vx = dir.x * speed;\r\n      const vy = dir.y * speed;\r\n      const b = Object.assign(\r\n        acquireBullet(state, {\r\n          x: turretX,\r\n          y: turretY,\r\n          vx,\r\n          vy,\r\n          team: ship.team || TEAM_DEFAULT,\r\n          ownerId: ship.id || null,\r\n          damage: dmg,\r\n          ttl,\r\n        }),\r\n        { radius },\r\n      );\r\n      turret.__cd =\r\n        typeof turret.cooldown === \"number\" && turret.cooldown > 0\r\n          ? turret.cooldown\r\n          : 1.0;\r\n    }\r\n  }\r\n}\r\n\r\nfunction ensureShipAiState(s: ShipLike) {\r\n  if (!s.__ai) {\r\n    s.__ai = { state: \"idle\", decisionTimer: 0, targetId: null };\r\n  }\r\n  return s.__ai;\r\n}\r\n\r\nfunction chooseNewTarget(state: State, ship: ShipLike) {\r\n  const enemies = (state.ships || []).filter(\r\n    (sh) => sh && sh.team !== ship.team,\r\n  );\r\n  if (!enemies.length) return null;\r\n  const idx = Math.floor(srandom() * enemies.length);\r\n  return enemies[idx];\r\n}\r\n\r\nfunction steerAway(\r\n  s: ShipLike,\r\n  tx: number,\r\n  ty: number,\r\n  accel: number,\r\n  dt: number,\r\n) {\r\n  const dx = (s.x || 0) - tx;\r\n  const dy = (s.y || 0) - ty;\r\n  const d = Math.hypot(dx, dy) || 1;\r\n  const nx = dx / d;\r\n  const ny = dy / d;\r\n  s.vx = (s.vx || 0) + nx * accel * dt;\r\n  s.vy = (s.vy || 0) + ny * accel * dt;\r\n}\r\n\r\nexport function applySimpleAI(\r\n  state: State,\r\n  dt: number,\r\n  bounds = getDefaultBounds(),\r\n) {\r\n  if (!state || !Array.isArray(state.ships)) return;\r\n  for (const s of state.ships) {\r\n    const ai = ensureShipAiState(s);\r\n    ai.decisionTimer = Math.max(0, (ai.decisionTimer || 0) - dt);\r\n\r\n    let target: ShipLike | null = null;\r\n    if (ai.targetId != null)\r\n      target =\r\n        (state as any).shipMap &&\r\n        typeof ai.targetId !== \"undefined\" &&\r\n        ai.targetId !== null\r\n          ? (state as any).shipMap.get(Number(ai.targetId)) || null\r\n          : (state.ships || []).find((sh) => sh && sh.id === ai.targetId) ||\r\n            null;\r\n    if (!target) target = chooseNewTarget(state, s);\r\n    if (target) ai.targetId = target.id;\r\n\r\n    // Set throttle and steering dynamically based on intent\r\n    const maxAccel = typeof s.accel === \"number\" ? s.accel : 100;\r\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\r\n    s.steering = typeof s.steering === \"number\" ? s.steering : 0;\r\n    s.throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\r\n\r\n    if (!target) {\r\n      // Idle: no acceleration, no steering\r\n      s.throttle = 0;\r\n      s.steering = 0;\r\n      ai.state = \"idle\";\r\n    } else {\r\n      if (ai.decisionTimer <= 0) {\r\n        const hpFrac = (s.hp || 0) / Math.max(1, s.maxHp || 1);\r\n        const rnd = srandom();\r\n        if (\r\n          hpFrac < AI_THRESHOLDS.hpEvadeThreshold ||\r\n          rnd < AI_THRESHOLDS.randomLow\r\n        )\r\n          ai.state = \"evade\";\r\n        else if (rnd < AI_THRESHOLDS.randomHigh) ai.state = \"engage\";\r\n        else ai.state = \"idle\";\r\n        ai.decisionTimer =\r\n          AI_THRESHOLDS.decisionTimerMin +\r\n          srandom() *\r\n            (AI_THRESHOLDS.decisionTimerMax - AI_THRESHOLDS.decisionTimerMin);\r\n        // If ship has ready cannons and target is within any cannon's range,\r\n        // prefer engage to make immediate firing deterministic in minimal test states.\r\n        try {\r\n          if (\r\n            ai.state !== \"engage\" &&\r\n            Array.isArray(s.cannons) &&\r\n            s.cannons.length > 0\r\n          ) {\r\n            for (const c of s.cannons) {\r\n              const ready = typeof c.__cd !== \"number\" || c.__cd <= 0;\r\n              const range =\r\n                typeof c.range === \"number\" ? c.range : DEFAULT_BULLET_RANGE;\r\n              if (\r\n                ready &&\r\n                target &&\r\n                withinRange(\r\n                  s.x || 0,\r\n                  s.y || 0,\r\n                  target.x || 0,\r\n                  target.y || 0,\r\n                  range,\r\n                )\r\n              ) {\r\n                ai.state = \"engage\";\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        } catch (e) {}\r\n      }\r\n\r\n      // Calculate desired angle to target\r\n      const dx = (target.x || 0) - (s.x || 0);\r\n      const dy = (target.y || 0) - (s.y || 0);\r\n      const desiredAngle = Math.atan2(dy, dx);\r\n      const currentAngle = typeof s.angle === \"number\" ? s.angle : 0;\r\n      let da = desiredAngle - currentAngle;\r\n      while (da < -Math.PI) da += Math.PI * 2;\r\n      while (da > Math.PI) da -= Math.PI * 2;\r\n      // Normalize steering to -1..1 using config\r\n      const steeringNorm = Math.PI / 2; // could be config if needed\r\n      const steering = Math.max(-1, Math.min(1, da / steeringNorm));\r\n\r\n      if (ai.state === \"engage\") {\r\n        s.throttle = 1;\r\n        s.steering = steering;\r\n        tryFire(state, s, target, dt);\r\n      } else if (ai.state === \"evade\") {\r\n        s.throttle = 0.8; // could be config if needed\r\n        // Steer away from target\r\n        const awayAngle = Math.atan2(\r\n          (s.y || 0) - (target.y || 0),\r\n          (s.x || 0) - (target.x || 0),\r\n        );\r\n        let daAway = awayAngle - currentAngle;\r\n        while (daAway < -Math.PI) daAway += Math.PI * 2;\r\n        while (daAway > Math.PI) daAway -= Math.PI * 2;\r\n        s.steering = Math.max(-1, Math.min(1, daAway / steeringNorm));\r\n      } else {\r\n        s.throttle = 0;\r\n        s.steering = 0;\r\n      }\r\n    }\r\n    clampSpeed(s, maxSpeed);\r\n  }\r\n}\r\n\r\nexport function getShipAiState(ship: ShipLike) {\r\n  if (!ship || !ship.__ai) return null;\r\n  const { targetId, ...rest } = ship.__ai;\r\n  return Object.assign({}, rest);\r\n}\r\n\r\nexport default { applySimpleAI, getShipAiState };\r\n", "// Lightweight spatial grid for 2D entity partitioning\r\n// Lightweight spatial grid for 2D entity partitioning\r\nexport default class SpatialGrid {\r\n  private cellSize: number;\r\n  private grid: Map<string, any[]>;\r\n\r\n  // simple pooled instances to avoid per-frame allocations\r\n  // pool keyed by cellSize to avoid reuse mismatch; cap instances per key\r\n  private static _pools: Map<number, SpatialGrid[]> = new Map();\r\n  private static _perKeyCap = 4;\r\n\r\n  static acquire(cellSize: number = 64) {\r\n    const key = cellSize | 0;\r\n    const pool = this._pools.get(key) || [];\r\n    const inst = pool.pop();\r\n    if (inst) {\r\n      inst.cellSize = cellSize;\r\n      return inst;\r\n    }\r\n    return new SpatialGrid(cellSize);\r\n  }\r\n\r\n  static release(inst: SpatialGrid) {\r\n    const key = (inst.cellSize || 64) | 0;\r\n    inst.clear();\r\n    let pool = this._pools.get(key);\r\n    if (!pool) {\r\n      pool = [];\r\n      this._pools.set(key, pool);\r\n    }\r\n    if (pool.length < this._perKeyCap) pool.push(inst);\r\n    // else drop instance and let GC collect\r\n  }\r\n\r\n  constructor(cellSize: number = 64) {\r\n    this.cellSize = cellSize;\r\n    this.grid = new Map();\r\n  }\r\n\r\n  private key(cx: number, cy: number) {\r\n    return cx + \",\" + cy;\r\n  }\r\n\r\n  insert(entity: any) {\r\n    const cx = Math.floor((entity.x || 0) / this.cellSize);\r\n    const cy = Math.floor((entity.y || 0) / this.cellSize);\r\n    const k = this.key(cx, cy);\r\n    let bucket = this.grid.get(k);\r\n    if (!bucket) {\r\n      bucket = [];\r\n      this.grid.set(k, bucket);\r\n    }\r\n    bucket.push(entity);\r\n  }\r\n\r\n  queryRadius(x: number, y: number, radius: number) {\r\n    const minCx = Math.floor((x - radius) / this.cellSize);\r\n    const maxCx = Math.floor((x + radius) / this.cellSize);\r\n    const minCy = Math.floor((y - radius) / this.cellSize);\r\n    const maxCy = Math.floor((y + radius) / this.cellSize);\r\n    const results: any[] = [];\r\n    const seen = new Set<any>();\r\n    for (let cx = minCx; cx <= maxCx; cx++) {\r\n      for (let cy = minCy; cy <= maxCy; cy++) {\r\n        const bucket = this.grid.get(this.key(cx, cy));\r\n        if (!bucket) continue;\r\n        for (const e of bucket) {\r\n          if (!seen.has(e)) {\r\n            seen.add(e);\r\n            results.push(e);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  // clear internal storage for reuse\r\n  clear() {\r\n    this.grid.clear();\r\n  }\r\n}\r\n\r\n// Utility: segment-circle intersection test used for swept collisions\r\nexport function segmentIntersectsCircle(\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number,\r\n  cx: number,\r\n  cy: number,\r\n  r: number,\r\n) {\r\n  // Translate so circle at origin\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const fx = x1 - cx;\r\n  const fy = y1 - cy;\r\n\r\n  const a = dx * dx + dy * dy;\r\n  const b = 2 * (fx * dx + fy * dy);\r\n  const c = fx * fx + fy * fy - r * r;\r\n\r\n  // Solve quadratic a*t^2 + b*t + c = 0\r\n  let discriminant = b * b - 4 * a * c;\r\n  if (discriminant < 0) return false;\r\n  discriminant = Math.sqrt(discriminant);\r\n  const t1 = (-b - discriminant) / (2 * a);\r\n  const t2 = (-b + discriminant) / (2 * a);\r\n  // If either t within [0,1], segment intersects\r\n  if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) return true;\r\n  return false;\r\n}\r\n", "// simulate.ts - TypeScript implementation ported from simulate.js\r\nimport { srange, srand, srandom } from \"./rng\";\r\nimport { createShip, updateTeamCount, normalizeTurrets } from \"./entities\";\r\nimport { getShipConfig } from \"./config/entitiesConfig\";\r\nimport AssetsConfig from \"./config/assets/assetsConfig\";\r\nimport { progression as progressionCfg } from \"./config/progressionConfig\";\r\nimport { SIM, boundaryBehavior } from \"./config/simConfig\";\r\nimport { clampSpeed } from \"./behavior\";\r\nimport {\r\n  acquireBullet,\r\n  releaseBullet,\r\n  acquireExplosion,\r\n  releaseExplosion,\r\n  acquireShieldHit,\r\n  releaseShieldHit,\r\n  acquireHealthHit,\r\n  releaseHealthHit,\r\n  releaseParticle,\r\n} from \"./gamemanager\";\r\nimport type { GameState } from \"./types\";\r\nimport * as SpatialGridModule from \"./spatialGrid\";\r\n// typed as any to avoid strict import/typing issues in this hotpath\r\nconst SpatialGrid: any =\r\n  (SpatialGridModule as any).default || SpatialGridModule;\r\nconst segmentIntersectsCircle: any = (SpatialGridModule as any)\r\n  .segmentIntersectsCircle;\r\n\r\nexport type Bounds = { W: number; H: number };\r\n\r\n// SIM constants migrated to simConfig.ts\r\n// Use SIM.DT_MS and SIM.MAX_ACC_MS instead\r\n\r\nfunction dist2(a: { x: number; y: number }, b: { x: number; y: number }) {\r\n  const dx = a.x - b.x;\r\n  const dy = a.y - b.y;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\nexport function simulateStep(\r\n  state: GameState,\r\n  dtSeconds: number,\r\n  bounds: Bounds,\r\n) {\r\n  pruneAll(state, dtSeconds, bounds);\r\n  // Advance time\r\n  state.t = (state.t || 0) + dtSeconds;\r\n\r\n  // Move bullets and handle boundary behavior\r\n  for (let i = (state.bullets || []).length - 1; i >= 0; i--) {\r\n    const b = state.bullets[i];\r\n    // store previous position for swept collision tests (both legacy and\r\n    // internal names). Some compiled code reads _prevX/_prevY while other\r\n    // paths read prevX/prevY; keep them synchronized.\r\n    const prevXVal = typeof b.x === \"number\" ? b.x : 0;\r\n    const prevYVal = typeof b.y === \"number\" ? b.y : 0;\r\n    b.prevX = prevXVal;\r\n    b.prevY = prevYVal;\r\n    (b as any)._prevX = prevXVal;\r\n    (b as any)._prevY = prevYVal;\r\n    b.x += (b.vx || 0) * dtSeconds;\r\n    b.y += (b.vy || 0) * dtSeconds;\r\n    b.ttl = (b.ttl || 0) - dtSeconds;\r\n    let outX = b.x < 0 || b.x >= bounds.W;\r\n    let outY = b.y < 0 || b.y >= bounds.H;\r\n    let outOfBounds = outX || outY;\r\n    let remove = false;\r\n    if (b.ttl <= 0) remove = true;\r\n    else if (outOfBounds) {\r\n      switch (boundaryBehavior.bullets) {\r\n        case \"remove\":\r\n          remove = true;\r\n          break;\r\n        case \"wrap\":\r\n          if (b.x < 0) b.x += bounds.W;\r\n          if (b.x >= bounds.W) b.x -= bounds.W;\r\n          if (b.y < 0) b.y += bounds.H;\r\n          if (b.y >= bounds.H) b.y -= bounds.H;\r\n          break;\r\n        case \"bounce\":\r\n          if (outX) {\r\n            b.vx = -(b.vx || 0);\r\n            b.x = Math.max(0, Math.min(bounds.W, b.x));\r\n          }\r\n          if (outY) {\r\n            b.vy = -(b.vy || 0);\r\n            b.y = Math.max(0, Math.min(bounds.H, b.y));\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    if (remove) {\r\n      try {\r\n        releaseBullet(state, b);\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  // Batched in-place pruning for all high-frequency event arrays\r\n  function pruneAll(state: GameState, dtSeconds: number, bounds: Bounds) {\r\n    // Ensure all event arrays are initialized\r\n  state.particles = state.particles || [];\r\n  state.explosions = state.explosions || [];\r\n  state.shieldHits = state.shieldHits || [];\r\n  state.healthHits = state.healthHits || [];\r\n  state.flashes = state.flashes || [];\r\n  state.shieldFlashes = state.shieldFlashes || [];\r\n  state.healthFlashes = state.healthFlashes || [];\r\n    // Bullets: prune expired/out-of-bounds\r\n    let writeBullet = 0;\r\n    for (let read = 0; read < state.bullets.length; read++) {\r\n      const b = state.bullets[read];\r\n      const prevXVal = typeof b.x === \"number\" ? b.x : 0;\r\n      const prevYVal = typeof b.y === \"number\" ? b.y : 0;\r\n      b.prevX = prevXVal;\r\n      b.prevY = prevYVal;\r\n      (b as any)._prevX = prevXVal;\r\n      (b as any)._prevY = prevYVal;\r\n      b.x += (b.vx || 0) * dtSeconds;\r\n      b.y += (b.vy || 0) * dtSeconds;\r\n      b.ttl = (b.ttl || 0) - dtSeconds;\r\n      let outX = b.x < 0 || b.x >= bounds.W;\r\n      let outY = b.y < 0 || b.y >= bounds.H;\r\n      let outOfBounds = outX || outY;\r\n      let remove = false;\r\n      if (b.ttl <= 0) remove = true;\r\n      else if (outOfBounds) {\r\n        switch (boundaryBehavior.bullets) {\r\n          case \"remove\":\r\n            remove = true;\r\n            break;\r\n          case \"wrap\":\r\n            if (b.x < 0) b.x += bounds.W;\r\n            if (b.x >= bounds.W) b.x -= bounds.W;\r\n            if (b.y < 0) b.y += bounds.H;\r\n            if (b.y >= bounds.H) b.y -= bounds.H;\r\n            break;\r\n          case \"bounce\":\r\n            if (outX) {\r\n              b.vx = -(b.vx || 0);\r\n              b.x = Math.max(0, Math.min(bounds.W, b.x));\r\n            }\r\n            if (outY) {\r\n              b.vy = -(b.vy || 0);\r\n              b.y = Math.max(0, Math.min(bounds.H, b.y));\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      if (!remove) {\r\n        state.bullets[writeBullet++] = b;\r\n      } else {\r\n        releaseBullet(state, b);\r\n      }\r\n    }\r\n    state.bullets.length = writeBullet;\r\n\r\n    // Particles: prune expired\r\n    let writeParticle = 0;\r\n    for (let read = 0; read < state.particles.length; read++) {\r\n      const p = state.particles[read];\r\n      p.life = (p.life || p.ttl || 0) - dtSeconds;\r\n      if (p.life > 0) {\r\n        state.particles[writeParticle++] = p;\r\n      } else {\r\n        releaseParticle(p);\r\n      }\r\n    }\r\n    state.particles.length = writeParticle;\r\n\r\n    // Explosions: prune expired\r\n    let writeExplosion = 0;\r\n    for (let read = 0; read < state.explosions.length; read++) {\r\n      const e = state.explosions[read];\r\n      e.life = (e.life || e.ttl || 0) - dtSeconds;\r\n      if (e.life > 0) {\r\n        state.explosions[writeExplosion++] = e;\r\n      } else {\r\n        releaseExplosion(e);\r\n      }\r\n    }\r\n    state.explosions.length = writeExplosion;\r\n\r\n    // ShieldHits: prune out-of-bounds\r\n    let writeShield = 0;\r\n    for (let read = 0; read < state.shieldHits.length; read++) {\r\n      const sh = state.shieldHits[read];\r\n      if (\r\n        typeof sh.x === \"number\" &&\r\n        typeof sh.y === \"number\" &&\r\n        sh.x >= 0 &&\r\n        sh.x < bounds.W &&\r\n        sh.y >= 0 &&\r\n        sh.y < bounds.H\r\n      ) {\r\n        state.shieldHits[writeShield++] = sh;\r\n      } else {\r\n        releaseShieldHit(sh);\r\n      }\r\n    }\r\n    state.shieldHits.length = writeShield;\r\n\r\n    // HealthHits: prune out-of-bounds\r\n    let writeHealth = 0;\r\n    for (let read = 0; read < state.healthHits.length; read++) {\r\n      const hh = state.healthHits[read];\r\n      if (\r\n        typeof hh.x === \"number\" &&\r\n        typeof hh.y === \"number\" &&\r\n        hh.x >= 0 &&\r\n        hh.x < bounds.W &&\r\n        hh.y >= 0 &&\r\n        hh.y < bounds.H\r\n      ) {\r\n        state.healthHits[writeHealth++] = hh;\r\n      } else {\r\n        releaseHealthHit(hh);\r\n      }\r\n    }\r\n    state.healthHits.length = writeHealth;\r\n  }\r\n\r\n  // Move ships and update heading\r\n  for (let si = (state.ships || []).length - 1; si >= 0; si--) {\r\n    const s = state.ships[si];\r\n    // --- Physics-based movement ---\r\n    const throttle = typeof s.throttle === \"number\" ? s.throttle : 0;\r\n    const steering = typeof s.steering === \"number\" ? s.steering : 0;\r\n    const accel = typeof s.accel === \"number\" ? s.accel : 0;\r\n    const turnRate = typeof s.turnRate === \"number\" ? s.turnRate : 3;\r\n    const maxSpeed = typeof s.maxSpeed === \"number\" ? s.maxSpeed : 160;\r\n    const angle = typeof s.angle === \"number\" ? s.angle : 0;\r\n\r\n    // Update angle based on steering\r\n    const maxTurn = turnRate * Math.abs(steering) * dtSeconds;\r\n    if (steering !== 0) {\r\n      let a = angle + Math.sign(steering) * maxTurn;\r\n      while (a < -Math.PI) a += Math.PI * 2;\r\n      while (a > Math.PI) a -= Math.PI * 2;\r\n      s.angle = a;\r\n    }\r\n\r\n    // Update velocity based on throttle and angle\r\n    const actualAccel = accel * throttle;\r\n    if (actualAccel > 0) {\r\n      s.vx = (s.vx || 0) + Math.cos(s.angle || 0) * actualAccel * dtSeconds;\r\n      s.vy = (s.vy || 0) + Math.sin(s.angle || 0) * actualAccel * dtSeconds;\r\n    }\r\n\r\n    // Apply friction/damping to velocity (from simConfig)\r\n    const friction = typeof SIM.friction === \"number\" ? SIM.friction : 0.98;\r\n    s.vx = (s.vx || 0) * friction;\r\n    s.vy = (s.vy || 0) * friction;\r\n\r\n    // Clamp speed using shared function\r\n    clampSpeed(s, maxSpeed);\r\n\r\n    // Move ship\r\n    s.x += (s.vx || 0) * dtSeconds;\r\n    s.y += (s.vy || 0) * dtSeconds;\r\n    // Boundary behavior for ships\r\n    const r = typeof s.radius === \"number\" ? s.radius : 12;\r\n    let outX = s.x < -r || s.x > bounds.W + r;\r\n    let outY = s.y < -r || s.y > bounds.H + r;\r\n    let outOfBounds = outX || outY;\r\n    let remove = false;\r\n    if (outOfBounds) {\r\n      switch (boundaryBehavior.ships) {\r\n        case \"remove\":\r\n          remove = true;\r\n          break;\r\n        case \"wrap\":\r\n          if (s.x < -r) s.x += bounds.W + r * 2;\r\n          if (s.x > bounds.W + r) s.x -= bounds.W + r * 2;\r\n          if (s.y < -r) s.y += bounds.H + r * 2;\r\n          if (s.y > bounds.H + r) s.y -= bounds.H + r * 2;\r\n          break;\r\n        case \"bounce\":\r\n          if (outX) {\r\n            s.vx = -(s.vx || 0);\r\n            s.x = Math.max(-r, Math.min(bounds.W + r, s.x));\r\n          }\r\n          if (outY) {\r\n            s.vy = -(s.vy || 0);\r\n            s.y = Math.max(-r, Math.min(bounds.H + r, s.y));\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    if (remove) {\r\n      const rem = state.ships.splice(si, 1);\r\n      if (rem && rem.length) {\r\n        try {\r\n          (state as any).shipMap && (state as any).shipMap.delete(rem[0].id);\r\n        } catch (e) {}\r\n        try {\r\n          if (rem[0] && rem[0].team)\r\n            state.teamCounts[rem[0].team] = Math.max(\r\n              0,\r\n              (state.teamCounts[rem[0].team] || 0) - 1,\r\n            );\r\n        } catch (e) {}\r\n      }\r\n    }\r\n    // --- Turret per-frame integration: advance turret.angle toward targetAngle using turnRate ---\r\n    try {\r\n      // Basic turret AI: if turret has no explicit targetAngle, aim at nearest enemy ship\r\n      try {\r\n        if (\r\n          Array.isArray(state.ships) &&\r\n          Array.isArray((s as any).turrets) &&\r\n          (s as any).turrets.length\r\n        ) {\r\n          for (let ti = 0; ti < (s as any).turrets.length; ti++) {\r\n            try {\r\n              const t = (s as any).turrets[ti];\r\n              if (!t || Array.isArray(t)) continue; // skip tuple mounts\r\n              // If caller already provided a targetAngle, don't override\r\n              if (typeof t.targetAngle === \"number\") continue;\r\n              // Find nearest enemy ship (team different from s.team)\r\n              let best: any = null;\r\n              let bestDist = Infinity;\r\n              for (const other of state.ships || []) {\r\n                if (!other || other.id === s.id) continue;\r\n                if (other.team === s.team) continue;\r\n                const dx = (other.x || 0) - (s.x || 0);\r\n                const dy = (other.y || 0) - (s.y || 0);\r\n                const d2 = dx * dx + dy * dy;\r\n                if (d2 < bestDist) {\r\n                  bestDist = d2;\r\n                  best = other;\r\n                }\r\n              }\r\n              if (best) {\r\n                t.targetAngle = Math.atan2(\r\n                  (best.y || 0) - (s.y || 0),\r\n                  (best.x || 0) - (s.x || 0),\r\n                );\r\n              }\r\n            } catch (e) {}\r\n          }\r\n        }\r\n      } catch (e) {}\r\n      // Normalize turret definitions via single helper so tuple shorthand\r\n      // ([x,y]) and object turrets are made consistent across systems.\r\n      try {\r\n        normalizeTurrets(s as any);\r\n      } catch (e) {}\r\n      // Ensure per-turret numeric fields and integrate turret angles\r\n      if (Array.isArray((s as any).turrets) && (s as any).turrets.length) {\r\n        const turretDefs = (s as any).turrets;\r\n        for (let ti = 0; ti < turretDefs.length; ti++) {\r\n          try {\r\n            const t = turretDefs[ti];\r\n            if (!t) continue;\r\n            // Ensure numeric fields exist and perform per-turret integration\r\n            t.angle =\r\n              typeof t.angle === \"number\"\r\n                ? t.angle\r\n                : typeof (s as any).turretAngle === \"number\"\r\n                  ? (s as any).turretAngle\r\n                  : s.angle || 0;\r\n            t.targetAngle =\r\n              typeof t.targetAngle === \"number\"\r\n                ? t.targetAngle\r\n                : typeof t.desiredAngle === \"number\"\r\n                  ? t.desiredAngle\r\n                  : t.angle;\r\n            // Determine turret turnRate: use instance value, else turretDefaults by kind, else fallback\r\n            let defaultTurn = Math.PI * 1.5;\r\n            try {\r\n              const td =\r\n                (AssetsConfig as any).turretDefaults &&\r\n                (AssetsConfig as any).turretDefaults[t.kind || \"basic\"];\r\n              if (td && typeof td.turnRate === \"number\")\r\n                defaultTurn = td.turnRate;\r\n            } catch (e) {}\r\n            const maxTurn =\r\n              (typeof t.turnRate === \"number\" ? t.turnRate : defaultTurn) *\r\n              dtSeconds;\r\n            // Shortest angular difference\r\n            let diff = t.targetAngle - t.angle;\r\n            while (diff < -Math.PI) diff += Math.PI * 2;\r\n            while (diff > Math.PI) diff -= Math.PI * 2;\r\n            const step = Math.sign(diff) * Math.min(Math.abs(diff), maxTurn);\r\n            t.angle = t.angle + step;\r\n            // Normalize angle into -PI..PI\r\n            while (t.angle < -Math.PI) t.angle += Math.PI * 2;\r\n            while (t.angle > Math.PI) t.angle -= Math.PI * 2;\r\n            turretDefs[ti] = t;\r\n          } catch (e) {}\r\n        }\r\n      }\r\n    } catch (e) {}\r\n    // Carrier spawning: if this ship type has a carrier config, accumulate\r\n    // a per-ship timer and spawn fighters as children up to maxFighters.\r\n    try {\r\n      const shipCfg =\r\n        getShipConfig && typeof getShipConfig === \"function\"\r\n          ? getShipConfig()\r\n          : {};\r\n      const typeCfg = shipCfg && s.type ? shipCfg[s.type] : undefined;\r\n      if (typeCfg && (typeCfg as any).carrier) {\r\n        const carrierCfg = (typeCfg as any).carrier;\r\n        // ensure timer exists\r\n        (s as any)._carrierTimer = (s as any)._carrierTimer || 0;\r\n        (s as any)._carrierTimer += dtSeconds;\r\n        const cooldown = Number(carrierCfg.fighterCooldown) || 1.5;\r\n        if ((s as any)._carrierTimer >= cooldown) {\r\n          (s as any)._carrierTimer = 0;\r\n          // count existing fighters spawned by this carrier\r\n          const existing = (state.ships || []).filter(\r\n            (sh: any) => sh && sh.parentId === s.id && sh.type === \"fighter\",\r\n          ).length;\r\n          const maxF = Number(carrierCfg.maxFighters) || 0;\r\n          const spawnPer = Number(carrierCfg.spawnPerCooldown) || 1;\r\n          const canSpawn = Math.max(0, maxF - existing);\r\n          let toSpawn = Math.min(canSpawn, spawnPer);\r\n          while (toSpawn > 0) {\r\n            const angle = srandom() * Math.PI * 2;\r\n            const dist = (s.radius || 20) + 8 + srandom() * 8;\r\n            const nx = (s.x || 0) + Math.cos(angle) * dist;\r\n            const ny = (s.y || 0) + Math.sin(angle) * dist;\r\n            try {\r\n              const f = createShip(\"fighter\", nx, ny, s.team);\r\n              f.parentId = s.id;\r\n              f.angle = s.angle;\r\n              (state.ships ||= []).push(f);\r\n              try {\r\n                (state as any).shipMap && (state as any).shipMap.set(f.id, f);\r\n              } catch (e) {}\r\n              try {\r\n                updateTeamCount(state as any, undefined, String(f.team));\r\n              } catch (e) {}\r\n            } catch (e) {}\r\n            toSpawn--;\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  // Bullet collisions\r\n  // Use spatial grid to reduce collision checks from O(N*M) to local queries\r\n  // Acquire a pooled grid instance and reuse it between frames to avoid allocations\r\n  const cellSize = (SIM && (SIM as any).gridCellSize) || 64;\r\n  const grid = SpatialGrid.acquire(cellSize);\r\n  const ships = state.ships || [];\r\n  for (let i = 0; i < ships.length; i++) grid.insert(ships[i]);\r\n  // Track ships removed during collision processing to avoid double-collision\r\n  const removedShipIds = new Set<any>();\r\n\r\n  for (let bi = (state.bullets || []).length - 1; bi >= 0; bi--) {\r\n    const b = state.bullets[bi];\r\n    const searchRadius = (b.radius || 1) + 64; // conservative search radius (cell-sized)\r\n    const candidates = grid.queryRadius(b.x || 0, b.y || 0, searchRadius);\r\n    let collided = false;\r\n    for (let ci = 0; ci < candidates.length; ci++) {\r\n      const s = candidates[ci];\r\n      if (!s || removedShipIds.has(s.id)) continue;\r\n      if (s.team === b.team) continue;\r\n      const r = (s.radius || 6) + (b.radius || 1);\r\n      // Swept collision: check segment from previous bullet pos (if available) to current pos\r\n      const bxPrev =\r\n        typeof (b as any)._prevX === \"number\"\r\n          ? (b as any)._prevX\r\n          : b.x - (b.vx || 0) * dtSeconds;\r\n      const byPrev =\r\n        typeof (b as any)._prevY === \"number\"\r\n          ? (b as any)._prevY\r\n          : b.y - (b.vy || 0) * dtSeconds;\r\n      const didHit =\r\n        dist2(b, s) <= r * r ||\r\n        segmentIntersectsCircle(\r\n          bxPrev,\r\n          byPrev,\r\n          b.x || 0,\r\n          b.y || 0,\r\n          s.x || 0,\r\n          s.y || 0,\r\n          r,\r\n        );\r\n      if (didHit) {\r\n        const attacker =\r\n          typeof b.ownerId === \"number\" || typeof b.ownerId === \"string\"\r\n            ? (state as any).shipMap &&\r\n              (state as any).shipMap.get(Number(b.ownerId))\r\n            : (undefined as any);\r\n        let dealtToShield = 0;\r\n        let dealtToHealth = 0;\r\n        const shield = s.shield || 0;\r\n        if (shield > 0) {\r\n          const absorbed = Math.min(shield, b.damage || 0);\r\n          s.shield = shield - absorbed;\r\n          const hitAngle = Math.atan2(\r\n            (b.y || 0) - (s.y || 0),\r\n            (b.x || 0) - (s.x || 0),\r\n          );\r\n          (state.shieldHits ||= []).push(\r\n            acquireShieldHit(state, {\r\n              id: s.id,\r\n              x: b.x,\r\n              y: b.y,\r\n              team: s.team,\r\n              amount: absorbed,\r\n              hitAngle,\r\n            }),\r\n          );\r\n          // expose damage event for renderer (shield hit)\r\n          (state.damageEvents ||= []).push({\r\n            id: s.id,\r\n            type: \"shield\",\r\n            amount: absorbed,\r\n            x: b.x,\r\n            y: b.y,\r\n            team: s.team,\r\n            attackerId: attacker && attacker.id,\r\n          });\r\n          const remaining = (b.damage || 0) - absorbed;\r\n          if (remaining > 0) {\r\n            // Apply armor reduction to damage dealt to hull. Each armor point\r\n            // reduces incoming hull damage by 10% (config uses small integers).\r\n            const armor = s.armor || 0;\r\n            const dmgMul = Math.max(0, 1 - 0.1 * armor);\r\n            const dealt = Math.max(0, remaining * dmgMul);\r\n            s.hp -= dealt;\r\n            (state.healthHits ||= []).push(\r\n              acquireHealthHit(state, {\r\n                id: s.id,\r\n                x: b.x,\r\n                y: b.y,\r\n                team: s.team,\r\n                amount: dealt,\r\n              }),\r\n            );\r\n            // expose damage event for renderer (health hit)\r\n            (state.damageEvents ||= []).push({\r\n              id: s.id,\r\n              type: \"hp\",\r\n              amount: dealt,\r\n              x: b.x,\r\n              y: b.y,\r\n              team: s.team,\r\n              attackerId: attacker && attacker.id,\r\n            });\r\n          }\r\n          dealtToShield = absorbed;\r\n          // remaining damage after shields, reduced by armor\r\n          const remainingAfterShield = Math.max(0, (b.damage || 0) - absorbed);\r\n          const armorAfterShield = s.armor || 0;\r\n          dealtToHealth = Math.max(\r\n            0,\r\n            remainingAfterShield * Math.max(0, 1 - 0.1 * armorAfterShield),\r\n          );\r\n        } else {\r\n          // No shields - apply armor reduction directly to bullet damage\r\n          const armor = s.armor || 0;\r\n          const dmgMulNoShield = Math.max(0, 1 - 0.1 * armor);\r\n          const dealtNoShield = Math.max(0, (b.damage || 0) * dmgMulNoShield);\r\n          s.hp -= dealtNoShield;\r\n          (state.healthHits ||= []).push(\r\n            acquireHealthHit(state, {\r\n              id: s.id,\r\n              x: b.x,\r\n              y: b.y,\r\n              team: s.team,\r\n              amount: dealtNoShield,\r\n            }),\r\n          );\r\n          // expose damage event for renderer (health hit)\r\n          (state.damageEvents ||= []).push({\r\n            id: s.id,\r\n            type: \"hp\",\r\n            amount: dealtNoShield,\r\n            x: b.x,\r\n            y: b.y,\r\n            team: s.team,\r\n            attackerId: attacker && attacker.id,\r\n          });\r\n          dealtToHealth = dealtNoShield;\r\n        }\r\n\r\n        // Update percent fields for renderer convenience\r\n        s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\r\n        s.shieldPercent =\r\n          typeof s.maxShield === \"number\" && s.maxShield > 0\r\n            ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield))\r\n            : 0;\r\n        // XP for damage\r\n        if (attacker) {\r\n          attacker.xp =\r\n            (attacker.xp || 0) +\r\n            (dealtToShield + dealtToHealth) * (progressionCfg.xpPerDamage || 0);\r\n          while (\r\n            (attacker.xp || 0) >= progressionCfg.xpToLevel(attacker.level || 1)\r\n          ) {\r\n            attacker.xp -= progressionCfg.xpToLevel(attacker.level || 1);\r\n            attacker.level = (attacker.level || 1) + 1;\r\n            // Support function or number scalars for progression\r\n            const resolveScalar = (s: any, lvl: number) =>\r\n              typeof s === \"function\" ? s(lvl) : s || 0;\r\n            const lvl = attacker.level || 1;\r\n            const hpScalar = resolveScalar(\r\n              progressionCfg.hpPercentPerLevel,\r\n              lvl,\r\n            );\r\n            const shScalar = resolveScalar(\r\n              progressionCfg.shieldPercentPerLevel,\r\n              lvl,\r\n            );\r\n            const dmgScalar = resolveScalar(\r\n              progressionCfg.dmgPercentPerLevel,\r\n              lvl,\r\n            );\r\n            const speedScalar = resolveScalar(\r\n              (progressionCfg as any).speedPercentPerLevel,\r\n              lvl,\r\n            );\r\n            const regenScalar = resolveScalar(\r\n              (progressionCfg as any).regenPercentPerLevel,\r\n              lvl,\r\n            );\r\n\r\n            const hpMul = 1 + hpScalar;\r\n            const shMul = 1 + shScalar;\r\n            const dmgMul = 1 + dmgScalar;\r\n\r\n            attacker.maxHp = (attacker.maxHp || 0) * hpMul;\r\n            attacker.hp = Math.min(attacker.maxHp, (attacker.hp || 0) * hpMul);\r\n            if (typeof attacker.maxShield === \"number\") {\r\n              attacker.maxShield = (attacker.maxShield || 0) * shMul;\r\n              attacker.shield = Math.min(\r\n                attacker.maxShield,\r\n                (attacker.shield || 0) * shMul,\r\n              );\r\n            }\r\n            if (Array.isArray(attacker.cannons)) {\r\n              for (const c of attacker.cannons) {\r\n                if (typeof c.damage === \"number\") c.damage *= dmgMul;\r\n              }\r\n            }\r\n            // Apply optional speed and shield regen increases\r\n            if (\r\n              typeof speedScalar === \"number\" &&\r\n              typeof attacker.accel === \"number\"\r\n            )\r\n              attacker.accel = attacker.accel * (1 + speedScalar);\r\n            if (\r\n              typeof regenScalar === \"number\" &&\r\n              typeof attacker.shieldRegen === \"number\"\r\n            )\r\n              attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\r\n          }\r\n        }\r\n\r\n        try {\r\n          releaseBullet(state, b);\r\n        } catch (e) {\r\n          try {\r\n            state.bullets.splice(bi, 1);\r\n          } catch (e) {}\r\n        }\r\n        collided = true;\r\n        // No need to check other candidates for this bullet\r\n        if (s.hp <= 0) {\r\n          if (attacker) {\r\n            attacker.xp = (attacker.xp || 0) + (progressionCfg.xpPerKill || 0);\r\n            while (\r\n              (attacker.xp || 0) >=\r\n              progressionCfg.xpToLevel(attacker.level || 1)\r\n            ) {\r\n              attacker.xp -= progressionCfg.xpToLevel(attacker.level || 1);\r\n              attacker.level = (attacker.level || 1) + 1;\r\n              const resolveScalar = (s: any, lvl: number) =>\r\n                typeof s === \"function\" ? s(lvl) : s || 0;\r\n              const lvl = attacker.level || 1;\r\n              const hpScalar = resolveScalar(\r\n                progressionCfg.hpPercentPerLevel,\r\n                lvl,\r\n              );\r\n              const shScalar = resolveScalar(\r\n                progressionCfg.shieldPercentPerLevel,\r\n                lvl,\r\n              );\r\n              const dmgScalar = resolveScalar(\r\n                progressionCfg.dmgPercentPerLevel,\r\n                lvl,\r\n              );\r\n              const speedScalar = resolveScalar(\r\n                (progressionCfg as any).speedPercentPerLevel,\r\n                lvl,\r\n              );\r\n              const regenScalar = resolveScalar(\r\n                (progressionCfg as any).regenPercentPerLevel,\r\n                lvl,\r\n              );\r\n\r\n              const hpMul = 1 + hpScalar;\r\n              const shMul = 1 + shScalar;\r\n              const dmgMul = 1 + dmgScalar;\r\n              attacker.maxHp = (attacker.maxHp || 0) * hpMul;\r\n              attacker.hp = Math.min(\r\n                attacker.maxHp,\r\n                (attacker.hp || 0) * hpMul,\r\n              );\r\n              if (typeof attacker.maxShield === \"number\") {\r\n                attacker.maxShield = (attacker.maxShield || 0) * shMul;\r\n                attacker.shield = Math.min(\r\n                  attacker.maxShield,\r\n                  (attacker.shield || 0) * shMul,\r\n                );\r\n              }\r\n              if (Array.isArray(attacker.cannons)) {\r\n                for (const c of attacker.cannons) {\r\n                  if (typeof c.damage === \"number\") c.damage *= dmgMul;\r\n                }\r\n              }\r\n              if (\r\n                typeof speedScalar === \"number\" &&\r\n                typeof attacker.accel === \"number\"\r\n              )\r\n                attacker.accel = attacker.accel * (1 + speedScalar);\r\n              if (\r\n                typeof regenScalar === \"number\" &&\r\n                typeof attacker.shieldRegen === \"number\"\r\n              )\r\n                attacker.shieldRegen = attacker.shieldRegen * (1 + regenScalar);\r\n            }\r\n          }\r\n          (state.explosions ||= []).push(\r\n            acquireExplosion(state, {\r\n              x: s.x,\r\n              y: s.y,\r\n              team: s.team,\r\n              life: 0.5,\r\n              ttl: 0.5,\r\n            }),\r\n          );\r\n          // remove from ships array and mark as removed for this frame\r\n          const idx = (state.ships || []).findIndex(\r\n            (sh: any) => sh && sh.id === s.id,\r\n          );\r\n          if (idx >= 0) {\r\n            state.ships.splice(idx, 1);\r\n            try {\r\n              (state as any).shipMap && (state as any).shipMap.delete(s.id);\r\n            } catch (e) {}\r\n            try {\r\n              if (s && s.team)\r\n                state.teamCounts[s.team] = Math.max(\r\n                  0,\r\n                  (state.teamCounts[s.team] || 0) - 1,\r\n                );\r\n            } catch (e) {}\r\n          }\r\n          removedShipIds.add(s.id);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    // continue to next bullet\r\n  }\r\n  // release pooled grid for reuse next frame\r\n  SpatialGrid.release(grid);\r\n\r\n  // Shield regen\r\n  for (const s of state.ships || []) {\r\n    if (s.maxShield)\r\n      s.shield = Math.min(\r\n        s.maxShield,\r\n        (s.shield || 0) + (s.shieldRegen || 0) * dtSeconds,\r\n      );\r\n  }\r\n\r\n  // refresh percent convenience fields after regen\r\n  for (const s of state.ships || []) {\r\n    s.hpPercent = Math.max(0, Math.min(1, (s.hp || 0) / (s.maxHp || 1)));\r\n    s.shieldPercent =\r\n      typeof s.maxShield === \"number\" && s.maxShield > 0\r\n        ? Math.max(0, Math.min(1, (s.shield || 0) / s.maxShield))\r\n        : 0;\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nexport default { simulateStep };\r\n", "// src/simWorker.ts - simulation worker implementation (compiled to JS and loaded as module Worker)\r\nimport { simulateStep } from './simulate';\r\nimport { applySimpleAI } from './behavior';\r\nimport { srand } from './rng';\r\nimport { normalizeTurrets, normalizeStateShips } from './entities';\r\nimport type { /* Bounds type can be extended in src/types if needed */ } from './types';\r\nimport { getDefaultBounds } from './config/simConfig';\r\n\r\ntype Bounds = { W: number; H: number };\r\n\r\nlet state: any = null;\r\nlet bounds: Bounds = getDefaultBounds();\r\nlet simDtMs = 16;\r\nlet running = false;\r\nlet acc = 0;\r\nlet last = 0;\r\n\r\nfunction postSnapshot() {\r\n\ttry {\r\n\t\tpostMessage({ type: 'snapshot', state });\r\n\t\t// Clear transient event arrays so the worker does not repeatedly resend\r\n\t\t// the same events on every snapshot. The snapshot is cloned by postMessage\r\n\t\t// so it's safe to clear them here.\r\n\t\ttry { clearTransientEvents(state); } catch (e) { /* ignore */ }\r\n\t} catch (e) {\r\n\t\t// ignore\r\n\t}\r\n}\r\n\r\n// exported for tests: clear transient worker event arrays after snapshot\r\nexport function clearTransientEvents(s: any) {\r\n  if (!s || typeof s !== 'object') return;\r\n  try {\r\n    if (Array.isArray(s.explosions)) s.explosions.length = 0;\r\n    if (Array.isArray(s.shieldHits)) s.shieldHits.length = 0;\r\n    if (Array.isArray(s.healthHits)) s.healthHits.length = 0;\r\n  } catch (e) { /* ignore */ }\r\n}\r\n\r\nfunction tick() {\r\n\tif (!running) return;\r\n\tconst now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();\r\n\tif (!last) last = now;\r\n\tacc += now - last; last = now;\r\n\tif (acc > 250) acc = 250;\r\n\t\twhile (acc >= simDtMs) {\r\n\t\t\ttry {\r\n\t\t\t\t\t// Apply deterministic AI before physics step\r\n\t\t\t\t\tapplySimpleAI(state as any, simDtMs / 1000, bounds);\r\n\t\t\t\t\tsimulateStep(state, simDtMs / 1000, bounds);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconst errAny: any = e as any;\r\n\t\t\t\tconst stack = errAny && errAny.stack ? errAny.stack : '';\r\n\t\t\t\tpostMessage({ type: 'error', message: String(e), stack });\r\n\t\t\t}\r\n\t\t\tacc -= simDtMs;\r\n\t\t}\r\n\tpostSnapshot();\r\n\tsetTimeout(tick, 0);\r\n}\r\n\r\n(self as any).onmessage = (ev: MessageEvent) => {\r\n\tconst msg = ev.data;\r\n\ttry {\r\n\t\tswitch (msg && msg.type) {\r\n\t\t\tcase 'init':\r\n\t\t\t\tif (typeof msg.seed === 'number') srand(msg.seed);\r\n\t\t\t\tif (msg.bounds) bounds = msg.bounds;\r\n\t\t\t\tif (typeof msg.simDtMs === 'number') simDtMs = msg.simDtMs;\r\n\t\t\t\tif (msg.state) {\r\n\t\t\t\t\tstate = msg.state;\r\n\t\t\t\t\ttry { normalizeStateShips(state); } catch (e) {}\r\n\t\t\t\t}\r\n\t\t\t\tpostMessage({ type: 'ready' });\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'start':\r\n\t\t\t\tif (!state) { postMessage({ type: 'error', message: 'no state' }); break; }\r\n\t\t\t\trunning = true; acc = 0; last = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); tick();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'stop':\r\n\t\t\t\trunning = false;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'snapshotRequest':\r\n\t\t\t\tpostSnapshot();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'setSeed':\r\n\t\t\t\tif (typeof msg.seed === 'number') { srand(msg.seed); }\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'command':\r\n\t\t\t\tif (msg.cmd === 'spawnShip' && state) {\r\n\t\t\t\t\ttry { normalizeTurrets(msg.args.ship); } catch (e) {}\r\n\t\t\t\t\tstate.ships.push(msg.args.ship);\r\n\t\t\t\t\ttry { (state as any).shipMap && (state as any).shipMap.set(msg.args.ship.id, msg.args.ship); } catch (e) {}\r\n\t\t\t\t\ttry { const tt = String((msg.args.ship as any).team || ''); state.teamCounts[tt] = (state.teamCounts[tt] || 0) + 1; } catch (e) {}\r\n\t\t\t\t} else if (msg.cmd === 'spawnShipBullet' && state) {\r\n\t\t\t\t\tstate.bullets.push(msg.args.bullet);\r\n\t\t\t\t} else if (msg.cmd === 'setState') {\r\n\t\t\t\t\tstate = msg.args.state;\r\n\t\t\t\t\ttry { normalizeStateShips(state); } catch (e) {}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// ignore\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} catch (err: any) {\r\n\t\tconst stack = err && (err as any).stack ? (err as any).stack : '';\r\n\t\tpostMessage({ type: 'error', message: String(err), stack });\r\n\t}\r\n};\r\n\r\nexport default null;\r\n"],
  "mappings": "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",
  "names": ["state", "state", "e", "state", "state", "state", "state", "state", "bounds", "SpatialGrid", "segmentIntersectsCircle", "state", "bounds", "dtSeconds", "maxTurn", "angle", "s", "lvl", "e"]
}
