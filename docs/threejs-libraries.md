# Recommended TypeScript-Friendly Libraries for three.js Games

This document lists recommended libraries for a three.js-based TypeScript project (like SpaceAutoBattler). It includes rationale, compatibility notes, installation commands (PowerShell/npm), and minimal integration guidance tailored to this codebase structure (separate simulation core and renderer).

## Assumptions

- Project uses `three@^0.179.1` and TypeScript (ESM).

- Renderer and simulation are separated; simulation should remain deterministic and renderer should be visual-only.

- Prefer well-typed libraries and ESM imports.

## High-value libraries

1. three-stdlib

- Use for controls and helpers (OrbitControls, loaders, etc.).

- Already present in the repo; keep and use from renderer side.

- Install: `npm install three-stdlib --save`

2. @types/three

- Keep types aligned with the three version.

- Install: `npm install -D @types/three`

3. GLTF Loading / model pipeline

- Use GLTFLoader from three/examples or three-stdlib, and consider Draco compression for smaller models.

- Integration: wrap loader calls in `src/core/assetLoader.ts` and cache via `GameState.assetPool`.

4. GSAP (animation)

- Good for timelines and camera/UI tweens.

- Install: `npm install gsap --save`

- Integration: Use in `src/renderer` for camera and visual-only transitions.

5. Rapier3D (physics)

- Use `@dimforge/rapier3d-compat` for deterministic physics in simulation.

- Install: `npm install @dimforge/rapier3d-compat --save`

- Integration: Run in `simWorker.ts` or `src/core/physics.ts`. Keep physics stepping separate from renderer.

6. three-mesh-bvh

- Efficient spatial queries and raycast acceleration for complex scenes.

- Install: `npm install three-mesh-bvh --save`

- Integration: Build BVH after model load in renderer or precompute offline.

7. postprocessing

- Modern shader-based postprocessing (bloom, FXAA, film, etc.).

- Install: `npm install postprocessing --save`

- Integration: Create `src/renderer/effects.ts` to manage passes.

1. pixi.js (optional)

- If you need advanced 2D overlays or UI separate from WebGL, consider Pixi.

- Install: `npm install pixi.js --save`

- Integration: Render Pixi on top of the three canvas or in a separate overlay.

1. lru-cache & idb-keyval (already present)

- Use for asset caching and persistence via `GameState.assetPool`.

1. Vite or esbuild (dev tooling)

- Vite for dev server; esbuild is already present for builds.

- Install Vite as dev: `npm install -D vite`

1. three-gpu-pathtracer or WebGPU helpers (experimental)

- For advanced rendering experiments only.

## TypeScript & bundling tips

- Keep `@types/three` aligned with `three`.

- Use ESM imports throughout: `import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'` or from `three-stdlib`.

- WASM-based libraries (rapier) should be loaded in the simulation worker and not in the renderer.

- Avoid packages that bundle their own `three` instance; use the canonical `three` package.

## Quick install commands (PowerShell)

```powershell
npm install gsap @dimforge/rapier3d-compat three-mesh-bvh postprocessing --save
npm install -D vite @types/three
```

## Minimal integration patterns

- AssetLoader: centralized loader with caching. Exposes `loadModel(url): Promise<ModelHandle>`.

- RendererEffectsManager: wrap postprocessing with enable/disable toggles.

- PhysicsStepper: encapsulates Rapier world and step function used by the simulation loop.

## Next steps

- Pick top 2-3 libraries to add (I recommend: `gsap`, `@dimforge/rapier3d-compat`, `three-mesh-bvh`).

- I can add them to `package.json` and scaffold small integration files if you want.

---

Document generated by the repository assistant on 2025-08-28.
